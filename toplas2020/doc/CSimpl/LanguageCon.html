<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory LanguageCon (Isabelle2020: April 2020)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory LanguageCon</h1>

<span class="command">theory</span> <span class="name">LanguageCon</span><br/>
<span class="keyword">imports</span> <a href="../../AFP/EmbSimpl/Language.html"><span class="name">Language</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
    Author:      David Sanan
    Maintainer:  David Sanan, sanan at ntu edu sg
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      LanguageCon.thy
    Author:     Norbert Schirmer, TU Muenchen
    Author:     David Sanan, NTU

Copyright (C) 2015-2016 David Sanan 
Some rights reserved, NTU
This library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The Simpl Syntax *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>LanguageCon</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Library.Old_Recdef&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;EmbSimpl.Language&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The Core Language *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We use a shallow embedding of boolean expressions as well as assertions
as sets of states. 
*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;s</span><span> </span><span>bexp</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;s</span><span> </span><span>assn</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span>dead</span><span> </span><span class="tfree">&#39;s</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;p</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;f</span><span class="delimiter">,</span><span> </span><span>dead</span><span> </span><span class="tfree">&#39;e</span><span class="delimiter">)</span><span> </span><span>com</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>Skip</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Basic</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;s&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;e option&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Spec</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#215; &#39;s) set&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;e option&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Seq</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s ,&#39;p, &#39;f,&#39;e) com&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p, &#39;f,&#39;e) com&quot;</span></span></span><span>    
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Cond</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>While</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Call</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;p&quot;</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>DynCom</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) com&quot;</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Guard</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com&quot;</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Throw</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Catch</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Await</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) Language.com&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;e option&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>sequential</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s,&#39;p,&#39;f) Language.com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential Skip = Language.Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (Basic f e) = Language.Basic f&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (Spec r e) = Language.Spec r&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = Language.Seq (sequential c<span class="hidden">&#8681;</span><sub>1</sub>) (sequential c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Language.Cond b (sequential c<span class="hidden">&#8681;</span><sub>1</sub>) (sequential c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (While b c) = Language.While b (sequential c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (Call p) = Language.Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (DynCom c) = Language.DynCom (&#955;s. (sequential (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (Guard f g c) = Language.Guard f g (sequential c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential Throw = Language.Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Language.Catch (sequential c<span class="hidden">&#8681;</span><sub>1</sub>) (sequential c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequential (Await b ca e) = Language.Skip&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>parallel</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f)  Language.com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel Language.Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.Basic f) = Basic f None&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.Spec r) = Spec r None&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = Seq (parallel c<span class="hidden">&#8681;</span><sub>1</sub>) (parallel c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (parallel c<span class="hidden">&#8681;</span><sub>1</sub>) (parallel c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.While b c) = While b (parallel c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.DynCom c) = DynCom (&#955;s. (parallel (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.Guard f g c) = Guard f g (parallel c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel Language.Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;parallel (Language.Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (parallel c<span class="hidden">&#8681;</span><sub>1</sub>) (parallel c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>noawaits</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits Skip = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (Basic f e) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (Spec r e) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (noawaits c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noawaits c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (noawaits c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noawaits c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (While b c) = (noawaits c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (Call p) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (DynCom c) = (&#8704;s. noawaits (c s))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (Guard f g c) = noawaits c&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits Throw = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (noawaits c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noawaits c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits (Await b cn e) = False&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Derived Language Constructs *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>raise</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;s) &#8658; &#39;e option &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;raise f e = Seq (Basic f e) Throw&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>condCatch</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; &#39;s bexp &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;condCatch c<span class="hidden">&#8681;</span><sub>1</sub> b c<span class="hidden">&#8681;</span><sub>2</sub> = Catch c<span class="hidden">&#8681;</span><sub>1</sub> (Cond b c<span class="hidden">&#8681;</span><sub>2</sub> Throw)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bind</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;v) &#8658; (&#39;v &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com) &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bind e c = DynCom (&#955;s. c (e s))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bseq</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bseq = Seq&quot;</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>block</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;s&#8658;&#39;s,&#39;e option, (&#39;s, &#39;p, &#39;f, &#39;e) com, &#39;s&#8658;&#39;s&#8658;&#39;s, &#39;e option, &#39;s&#8658;&#39;s&#8658;(&#39;s, &#39;p, &#39;f, &#39;e) com]&#8658;(&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;block init ei bdy return er c =
    DynCom (&#955;s. (Seq (Catch (Seq (Basic init ei) bdy) (Seq (Basic (return s) er) Throw)) 
                            (DynCom (&#955;t. Seq (Basic (return s) er) (c s t))))
                        )&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>call</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s&#8658;&#39;s) &#8658; &#39;e option &#8658; &#39;p &#8658; (&#39;s &#8658; &#39;s &#8658; &#39;s)&#8658; &#39;e option &#8658; (&#39;s&#8658;&#39;s&#8658;(&#39;s, &#39;p, &#39;f, &#39;e) com)&#8658;(&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;call init ei p return er c = block init ei (Call p) return er c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>dynCall</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;s) &#8658; &#39;e option &#8658; (&#39;s &#8658; &#39;p) &#8658; 
             (&#39;s &#8658; &#39;s &#8658; &#39;s) &#8658; &#39;e option &#8658; (&#39;s &#8658; &#39;s &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com) &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;dynCall init ei p return er c = DynCom (&#955;s. call init ei (p s) return er c)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>fcall</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s&#8658;&#39;s) &#8658; &#39;e option &#8658; &#39;p &#8658; (&#39;s &#8658; &#39;s &#8658; &#39;s)&#8658; &#39;e option &#8658; (&#39;s &#8658; &#39;v) &#8658; (&#39;v&#8658;(&#39;s, &#39;p, &#39;f, &#39;e) com)
            &#8658;(&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;fcall init ei p return er result c = call init ei p return er (&#955;s t. c (result t))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>lem</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;x &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658;(&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lem x c = c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>switch</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;v) &#8658; (&#39;v set &#215; (&#39;s, &#39;p, &#39;f, &#39;e) com) list &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;switch v [] = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;switch v (Vc#vs) = Cond {s. v s &#8712; fst Vc} (snd Vc) (switch v vs)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>guaranteeStrip</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f &#8658; &#39;s set &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;guaranteeStrip f g c = Guard f g c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>guaranteeStripPair</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f &#8658; &#39;s set &#8658; (&#39;f &#215; &#39;s set)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;guaranteeStripPair f g = (f,g)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;f &#215; &#39;s set ) list &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;guards [] c = c&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;guards (g#gs) c = Guard (fst g) (snd g) (guards gs c)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>while</span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;f &#215; &#39;s set) list &#8658; &#39;s bexp &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;while gs b c = guards gs (While b (Seq c (guards gs Skip)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>whileAnno</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp &#8658; &#39;s assn &#8658; (&#39;s &#215; &#39;s) assn &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;whileAnno b I V c = While b c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>whileAnnoG</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;f &#215; &#39;s set) list &#8658; &#39;s bexp &#8658; &#39;s assn &#8658; (&#39;s &#215; &#39;s) assn &#8658; 
     (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;whileAnnoG gs b I V c = while gs b c&quot;</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>specAnno</span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; &#39;s assn) &#8658; (&#39;a &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com) &#8658; 
                         (&#39;a &#8658; &#39;s assn) &#8658; (&#39;a &#8658; &#39;s assn) &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;specAnno P c Q A = (c undefined)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>whileAnnoFix</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp &#8658; (&#39;a &#8658; &#39;s assn) &#8658; (&#39;a &#8658; (&#39;s &#215; &#39;s) assn) &#8658; (&#39;a &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com) &#8658; 
     (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;whileAnnoFix b I V c = While b (c undefined)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>whileAnnoGFix</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;f &#215; &#39;s set) list &#8658; &#39;s bexp &#8658; (&#39;a &#8658; &#39;s assn) &#8658; (&#39;a &#8658; (&#39;s &#215; &#39;s) assn) &#8658; 
     (&#39;a &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com) &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;whileAnnoGFix gs b I V c = while gs b (c undefined)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>if_rel</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; bool) &#8658; (&#39;s &#8658; &#39;s) &#8658; (&#39;s &#8658; &#39;s) &#8658; (&#39;s &#8658; &#39;s) &#8658; (&#39;s &#215; &#39;s) set&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;if_rel b f g h = {(s,t). if b s then t = f s else t = g s &#8744; t = h s}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_guaranteeStripPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (guaranteeStripPair f g) = f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStripPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_guaranteeStripPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (guaranteeStripPair f g) = g&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStripPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Operations on Simpl-Syntax *}</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Normalisation of Sequential Composition: @{text &quot;sequence&quot;}, @{text &quot;flatten&quot;} and @{text &quot;normalize&quot;} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>flatten</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com list&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten Skip = [Skip]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Basic f e) = [Basic f e]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Spec r e) = [Spec r e]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = flatten c<span class="hidden">&#8681;</span><sub>1</sub> @ flatten c<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = [Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (While b c) = [While b c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Call p) = [Call p]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (DynCom c) = [DynCom c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Guard f g c) = [Guard f g c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten Throw = [Throw]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = [Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Await b ca e) = [Await b ca e]&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>flattenc</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com list&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc Skip = [Skip]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (Basic f e) = [Basic f e]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (Spec r e) = [Spec r e]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = [Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = [Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (While b c) = [While b c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (Call p) = [Call p]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (DynCom c) = [DynCom c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (Guard f g c) = [Guard f g c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc Throw = [Throw]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = flattenc c<span class="hidden">&#8681;</span><sub>1</sub> @ flattenc c<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (Await b ca e) = [Await b ca e]&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>sequence</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com) &#8658; 
                      (&#39;s, &#39;p, &#39;f, &#39;e) com list &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequence seq [] = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequence seq (c#cs) = (case cs of [] &#8658; c
                        | _ &#8658; seq c (sequence seq cs))&quot;</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>normalize</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Basic f e) = Basic f e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Spec r e) = Spec r e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = sequence Seq
                            ((flatten (normalize c<span class="hidden">&#8681;</span><sub>1</sub>)) @ (flatten (normalize c<span class="hidden">&#8681;</span><sub>2</sub>)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (normalize c<span class="hidden">&#8681;</span><sub>1</sub>) (normalize c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (While b c) = While b (normalize c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (DynCom c) = DynCom (&#955;s. (normalize (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Guard f g c) = Guard f g (normalize c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (normalize c<span class="hidden">&#8681;</span><sub>1</sub>) (normalize c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Await b ca e) = Await b (Language.normalize ca) e&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>normalizec</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (Basic f e) = Basic f e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (Spec r e) = Spec r e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = Seq (normalizec c<span class="hidden">&#8681;</span><sub>1</sub>) (normalizec c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (normalizec c<span class="hidden">&#8681;</span><sub>1</sub>) (normalizec c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (While b c) = While b (normalizec c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (DynCom c) = DynCom (&#955;s. (normalizec (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (Guard f g c) = Guard f g (normalizec c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = sequence Catch
                            ((flattenc (normalizec c<span class="hidden">&#8681;</span><sub>1</sub>)) @ (flattenc (normalizec c<span class="hidden">&#8681;</span><sub>2</sub>)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (Await b ca e) = Await b (Language.normalize ca) e&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten c &#8800; []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>    
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_nonEmpty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc c &#8800; []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_single</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;c &#8712; set (flatten c&#39;). flatten c = [c]&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>             </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>            </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>           </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>          </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>          </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>       </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>      </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>     </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_single</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;c &#8712; set (flattenc c&#39;). flattenc c = [c]&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>             </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>            </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>           </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>          </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>         </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>       </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>      </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>     </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_sequence_id</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;cs&#8800;[];&#8704;c &#8712; set cs. flatten c = [c]&#10215; &#10233; flatten (sequence Seq cs) = cs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_sequence_id</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;cs&#8800;[];&#8704;c &#8712; set cs. flattenc c = [c]&#10215; &#10233; flattenc (sequence Catch cs) = cs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_app</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (sequence Seq (flatten c1 @ flatten c2)) = flatten c1 @ flatten c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>flatten_sequence_id</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>flatten_single</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_app</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (sequence Catch (flattenc c1 @ flattenc c2)) = flattenc c1 @ flattenc c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>flattenc_sequence_id</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flattenc_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>flattenc_single</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_sequence_flatten</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (sequence Seq (flatten c)) = flatten c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_app</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma &quot;Seq (sequence Seq (flatten c1)) c2&#39; = sequence Seq (flatten (Seq c1 c2&#39;))&quot;
proof (induct c1) print_cases
  case Skip 
  then have &quot;sequence Seq (flatten Skip) = Skip&quot; by auto
   have &quot;sequence Seq (Skip#(flatten c2&#39;)) = sequence Seq (flatten (Seq Skip c2&#39;))&quot; by auto
   also have &quot;sequence Seq (Skip#(flatten c2&#39;)) = Seq Skip (sequence Seq (flatten c2&#39;))&quot;
     using flatten_nonEmpty sequence.simps(2)[of Seq Skip &quot;flatten c2&#39;&quot;]
     by (simp add: LanguageCon.flatten_nonEmpty list.case_eq_if)  
   finally show ?case
   have &quot;LanguageCon.com.Seq Skip c2&#39; = 
         LanguageCon.com.Seq (LanguageCon.sequence LanguageCon.com.Seq (LanguageCon.flatten LanguageCon.com.Skip)) c2&#39;&quot;
   by auto 
  finally show ?case
  then 
qed(auto)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_sequence_flattenc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (sequence Catch (flattenc c)) = flattenc c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flattenc_app</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_flatten_normalize</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sequence Seq (flatten (normalize c)) = normalize c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>flatten_app</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_flattenc_normalize</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sequence Catch (flattenc (normalizec c)) = normalizec c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>flattenc_app</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_normalize</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x xs. flatten (normalize c) = x#xs 
       &#10233; (case xs of [] &#8658; normalize c = x 
              | (x&#39;#xs&#39;) &#8658; normalize c= Seq x (sequence Seq xs))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize (Seq c1 c2)) = x # xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (sequence Seq (flatten (normalize c1) @ flatten (normalize c2))) = 
          x#xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x_xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize c1) @ flatten (normalize c2) = x # xs&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_app</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize c1)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>flatten_nonEmpty</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x1</span><span> </span><span>xs1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x_xs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> 
</span><span>      </span><span>x_x1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=x1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xs_rest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs1@flatten (normalize c2)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Seq.hyps</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons_x1_xs1</span><span class="delimiter">]</span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize c1 = x1&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span>Nil</span><span> </span><span>x_x1</span><span> </span><span>xs_rest</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize c2)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Seq.hyps</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons_x1_xs1</span><span class="delimiter">]</span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize c1 = Seq x1 (sequence Seq xs1)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span>Nil</span><span> </span><span>x_x1</span><span> </span><span>xs_rest</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize c2)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_normalizec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x xs. flattenc (normalizec c) = x#xs 
       &#10233; (case xs of [] &#8658; normalizec c = x 
              | (x&#39;#xs&#39;) &#8658; normalizec c= Catch x (sequence Catch xs))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catch</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (normalizec (Catch c1 c2)) = x # xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (sequence Catch (flattenc (normalizec c1) @ flattenc (normalizec c2))) = 
          x#xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x_xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (normalizec c1) @ flattenc (normalizec c2) = x # xs&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flattenc_app</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (normalizec c1)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>flattenc_nonEmpty</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x1</span><span> </span><span>xs1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x_xs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> 
</span><span>      </span><span>x_x1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=x1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xs_rest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs1@flattenc (normalizec c2)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Catch.hyps</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons_x1_xs1</span><span class="delimiter">]</span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec c1 = x1&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span>Nil</span><span> </span><span>x_x1</span><span> </span><span>xs_rest</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (normalizec c2)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flattenc_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Catch.hyps</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons_x1_xs1</span><span class="delimiter">]</span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec c1 = Catch x1 (sequence Catch xs1)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span>Nil</span><span> </span><span>x_x1</span><span> </span><span>xs_rest</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (normalizec c2)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flattenc_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_raise</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (raise f e) = [Basic f e, Throw]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (condCatch c1 b c2) = [condCatch c1 b c2]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (bind e c) = [bind e c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (bseq c1 c2) = flatten c1 @ flatten c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (block init ei bdy return er result) = [block init ei bdy return er result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (call init ei p return er result) = [call init ei p return er result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (dynCall init ei p return er result) = [dynCall init ei p return er result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (fcall init ei p return er result c) = [fcall init ei p return er result c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (switch v Vcs) = [switch v Vcs]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Vcs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (guaranteeStrip f g c) = [guaranteeStrip f g c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (while gs b c) = [while gs b c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (whileAnno b I V c) = [whileAnno b I V c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (whileAnnoG gs b I V c) = [whileAnnoG gs b I V c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (specAnno P c Q A) = flatten (c undefined)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flatten_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>flatten.simps</span><span> </span><span>flatten_raise</span><span> </span><span>flatten_condCatch</span><span> </span><span>flatten_bind</span><span>
</span><span>  </span><span>flatten_block</span><span> </span><span>flatten_call</span><span> </span><span>flatten_dynCall</span><span> </span><span>flatten_fcall</span><span> </span><span>flatten_switch</span><span>
</span><span>  </span><span>flatten_guaranteeStrip</span><span>
</span><span>  </span><span>flatten_while</span><span> </span><span>flatten_whileAnno</span><span> </span><span>flatten_whileAnnoG</span><span> </span><span>flatten_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_raise</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (raise f e) = raise f e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (condCatch c1 b c2) = condCatch (normalize c1) b (normalize c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (bind e c) = bind e (&#955;v. normalize (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (bseq c1 c2) = sequence bseq
                            ((flatten (normalize c1)) @ (flatten (normalize c2)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (block init ei bdy return er c) = 
                         block init ei (normalize bdy) return er (&#955;s t. normalize (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize bdy)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>drule</span><span> </span><span>flatten_normalize</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize (c s sa))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize bdy) = P&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>flatten_normalize</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>lista</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (call init ei p return er c) = call init ei p return er (&#955;i t. normalize (c i t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (dynCall init ei p return er c) = 
    dynCall init ei p return er (&#955;s t. normalize (c s t))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (fcall init ei p return er result c) = 
    fcall init ei p return er result (&#955;v. normalize (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (switch v Vcs) = switch v (map (&#955;(V,c). (V,normalize c)) Vcs)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Vcs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (guaranteeStrip f g c) = guaranteeStrip f g (normalize c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_guards</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (guards gs c) = guards gs (normalize c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Sequencial composition with guards in the body is not preserved by
        normalize *}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (while gs b c) = guards gs
      (While b (sequence Seq (flatten (normalize c) @ flatten (guards gs Skip))))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (whileAnno b I V c) = whileAnno b I V (normalize c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (whileAnnoG gs b I V c) = guards gs
      (While b (sequence Seq (flatten (normalize c) @ flatten (guards gs Skip))))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (specAnno P c Q A) = specAnno P (&#955;s. normalize (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>normalize_simps</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>normalize.simps</span><span> </span><span>normalize_raise</span><span> </span><span>normalize_condCatch</span><span> </span><span>normalize_bind</span><span>
</span><span>  </span><span>normalize_block</span><span> </span><span>normalize_call</span><span> </span><span>normalize_dynCall</span><span> </span><span>normalize_fcall</span><span> </span><span>normalize_switch</span><span>
</span><span>  </span><span>normalize_guaranteeStrip</span><span> </span><span>normalize_guards</span><span> 
</span><span>  </span><span>normalize_while</span><span> </span><span>normalize_whileAnno</span><span> </span><span>normalize_whileAnnoG</span><span> </span><span>normalize_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_raise</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (raise f e) = [Seq (Basic f e) Throw]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (condCatch c1 b c2) = flattenc c1 @ [Cond b c2 Throw]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (bind e c) = [bind e c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (bseq c1 c2) = [Seq c1 c2]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (block init ei bdy return er result) = [block init ei bdy return er result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (call init ei p return er result) = [call init ei p return er result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (dynCall init ei p return er result) = [dynCall init ei p return er result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (fcall init ei p return er result c) = [fcall init ei p return er result c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (switch v Vcs) = [switch v Vcs]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Vcs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (guaranteeStrip f g c) = [guaranteeStrip f g c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (while gs b c) = [while gs b c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (whileAnno b I V c) = [whileAnno b I V c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (whileAnnoG gs b I V c) = [whileAnnoG gs b I V c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flattenc_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flattenc (specAnno P c Q A) = flattenc (c undefined)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flattenc_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>flattenc.simps</span><span>  </span><span>flattenc_condCatch</span><span> </span><span>flattenc_bind</span><span>
</span><span>  </span><span>flattenc_block</span><span> </span><span>flattenc_call</span><span> </span><span>flattenc_dynCall</span><span> </span><span>flattenc_fcall</span><span> </span><span>flattenc_switch</span><span>
</span><span>  </span><span>flattenc_guaranteeStrip</span><span>
</span><span>  </span><span>flattenc_while</span><span> </span><span>flattenc_whileAnno</span><span> </span><span>flattenc_whileAnnoG</span><span> </span><span>flattenc_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_raise</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (raise f e) = raise f e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_condCatch</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (condCatch c1 b c2) = sequence Catch ((flattenc (normalizec c1))@ [Cond b (normalizec c2) Throw])&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_bind</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (bind e c) = bind e (&#955;v. normalizec (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_bseq</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (bseq c1 c2) =  bseq (normalizec c1)  (normalizec c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_block</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (block init ei bdy return er c) = 
                         block init ei (normalizec bdy) return er (&#955;s t. normalizec (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span> </span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_call</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (call init ei p return er c) = call init ei p return er (&#955;i t. normalizec (c i t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span> </span><span>normalizec_block</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_dynCall</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (dynCall init ei p return er c) = 
    dynCall init ei p return er (&#955;s t. normalizec (c s t))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span> </span><span>normalizec_call</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_fcall</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (fcall init ei p return er result c) = 
    fcall init ei p return er result (&#955;v. normalizec (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span> </span><span>normalizec_call</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_switch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (switch v Vcs) = switch v (map (&#955;(V,c). (V,normalizec c)) Vcs)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Vcs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_guaranteeStrip</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (guaranteeStrip f g c) = guaranteeStrip f g (normalizec c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_guards</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (guards gs c) = guards gs (normalizec c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Sequencial composition with guards in the body is not preserved by
        normalize *}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_while</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (while gs b c) = guards gs
      (While b (Seq  (normalizec c)  (guards gs Skip)))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span> </span><span>normalizec_guards</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_whileAnno</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (whileAnno b I V c) = whileAnno b I V (normalizec c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_whileAnnoG</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (whileAnnoG gs b I V c) = guards gs
      (While b (Seq (normalizec c) (guards gs Skip)))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span> </span><span>normalizec_while</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalizec_specAnno</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalizec (specAnno P c Q A) = specAnno P (&#955;s. normalizec (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemmas normalizec_simps = 
  normalizec.simps normalizec_raise normalizec_condCatch normalizec_bind
  normalizec_block normalizec_call normalizec_dynCall normalizec_fcall normalizec_switch
  normalizec_guaranteeStrip normalizec_guards 
  normalizec_while normalizec_whileAnno normalizec_whileAnnoG normalizec_specAnno*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Stripping Guards: @{text &quot;strip_guards&quot;} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>strip_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f set &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Basic f e) = Basic f e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Spec r e) = Spec r e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (Seq (strip_guards F c<span class="hidden">&#8681;</span><sub>1</sub>) (strip_guards F c<span class="hidden">&#8681;</span><sub>2</sub>))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (strip_guards F c<span class="hidden">&#8681;</span><sub>1</sub>) (strip_guards F c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (While b c) = While b (strip_guards F c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (DynCom c) = DynCom (&#955;s. (strip_guards F (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Guard f g c) = (if f &#8712; F then strip_guards F c
                                  else Guard f g (strip_guards F c))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (strip_guards F c<span class="hidden">&#8681;</span><sub>1</sub>) (strip_guards F c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Await b ca e) = Await b (Language.strip_guards F ca) e&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_await_strip_guards_eq</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>noawaits</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Language.strip_guards F (sequential t)) = (sequential (strip_guards F t))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>noawaits</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strip</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f set &#8658; 
                   (&#39;p &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com option) &#8658; (&#39;p &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com option)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip F &#915; = (&#955;p. map_option (strip_guards F) (&#915; p))&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_simp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(strip F &#915;) p = map_option (strip_guards F) (&#915; p)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>strip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dom_strip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dom (strip F &#915;) = dom &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (strip_guards F c) = strip_guards F c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Language.strip_guards_idem</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip F (strip F &#915;) = strip F &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; x&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>strip_guards_idem</span><span> </span><span>strip_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_raise</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (raise f e) = raise f e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (condCatch c1 b c2) = 
    condCatch (strip_guards F c1) b (strip_guards F c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (bind e c) = bind e (&#955;v. strip_guards F (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (bseq c1 c2) = bseq (strip_guards F c1) (strip_guards F c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (block init ei bdy return er c) =
    block init ei (strip_guards F bdy) return er (&#955;s t. strip_guards F (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (call init ei p return er c) =
     call init ei p return er (&#955;s t. strip_guards F (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (dynCall init ei p return er c) =
     dynCall init ei p return er (&#955;s t. strip_guards F (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (fcall init ei p return er result c) =
     fcall init ei p return er result (&#955;v. strip_guards F (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (switch v Vc) =
    switch v (map (&#955;(V,c). (V,strip_guards F c)) Vc)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Vc</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (guaranteeStrip f g c) = 
    (if f &#8712; F then strip_guards F c 
     else guaranteeStrip f g (strip_guards F c))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>guaranteeStripPair_split_conv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;case_prod c (guaranteeStripPair f g) = c f g&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStripPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_guards</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (guards gs c) =
        guards (filter (&#955;(f,g). f &#8713; F) gs) (strip_guards F c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (while gs b  c) = 
     while (filter (&#955;(f,g). f &#8713; F) gs) b (strip_guards F c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (whileAnno b I V c) = whileAnno b I V (strip_guards F c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span>  </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (whileAnnoG gs b I V c) = 
     whileAnnoG (filter (&#955;(f,g). f &#8713; F) gs) b I V (strip_guards F c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (specAnno P c Q A) = 
    specAnno P (&#955;s. strip_guards F (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>strip_guards_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>strip_guards.simps</span><span> </span><span>strip_guards_raise</span><span> 
</span><span>  </span><span>strip_guards_condCatch</span><span> </span><span>strip_guards_bind</span><span> </span><span>strip_guards_bseq</span><span> </span><span>strip_guards_block</span><span>
</span><span>  </span><span>strip_guards_dynCall</span><span> </span><span>strip_guards_fcall</span><span> </span><span>strip_guards_switch</span><span> 
</span><span>  </span><span>strip_guards_guaranteeStrip</span><span> </span><span>guaranteeStripPair_split_conv</span><span> </span><span>strip_guards_guards</span><span>
</span><span>  </span><span>strip_guards_while</span><span> </span><span>strip_guards_whileAnno</span><span> </span><span>strip_guards_whileAnnoG</span><span>
</span><span>  </span><span>strip_guards_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Marking Guards: @{text &quot;mark_guards&quot;} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>mark_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f &#8658; (&#39;s,&#39;p,&#39;g, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Basic g e) = Basic g e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Spec r e) = Spec r e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (Seq (mark_guards f c<span class="hidden">&#8681;</span><sub>1</sub>) (mark_guards f c<span class="hidden">&#8681;</span><sub>2</sub>))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (mark_guards f c<span class="hidden">&#8681;</span><sub>1</sub>) (mark_guards f c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (While b c) = While b (mark_guards f c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (DynCom c) = DynCom (&#955;s. (mark_guards f (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Guard f&#39; g c) = Guard f g (mark_guards f c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (mark_guards f c<span class="hidden">&#8681;</span><sub>1</sub>) (mark_guards f c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Await b ca e) = Await b (Language.mark_guards f ca) e&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_raise</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (raise g e) = raise g e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (condCatch c1 b c2) = 
    condCatch (mark_guards f c1) b (mark_guards f c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (bind e c) = bind e (&#955;v. mark_guards f (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (bseq c1 c2) = bseq (mark_guards f c1) (mark_guards f c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (block init ei bdy return er c) =
    block init ei (mark_guards f bdy) return er (&#955;s t. mark_guards f (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (call init ei p return er c) =
     call init ei p return er (&#955;s t. mark_guards f (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (dynCall init ei p return er c) =
     dynCall init ei p return er (&#955;s t. mark_guards f (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (fcall init ei p return er result c) =
     fcall init ei p return er result (&#955;v. mark_guards f (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (switch v vs) = 
     switch v (map (&#955;(V,c). (V,mark_guards f c)) vs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>vs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (guaranteeStrip f&#39; g c) = guaranteeStrip f g (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_guards</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (guards gs c) = guards (map (&#955;(f&#39;,g). (f,g)) gs) (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (while gs b c) = 
    while (map (&#955;(f&#39;,g). (f,g)) gs) b (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (whileAnno b I V c) = whileAnno b I V (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (whileAnnoG gs b I V c) = 
    whileAnnoG (map (&#955;(f&#39;,g). (f,g)) gs) b I V (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span> </span><span>whileAnnoG_def</span><span> </span><span>while_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (specAnno P c Q A) = 
    specAnno P (&#955;s. mark_guards f (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mark_guards_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>mark_guards.simps</span><span> </span><span>mark_guards_raise</span><span> 
</span><span>  </span><span>mark_guards_condCatch</span><span> </span><span>mark_guards_bind</span><span> </span><span>mark_guards_bseq</span><span> </span><span>mark_guards_block</span><span>
</span><span>  </span><span>mark_guards_dynCall</span><span> </span><span>mark_guards_fcall</span><span> </span><span>mark_guards_switch</span><span> 
</span><span>  </span><span>mark_guards_guaranteeStrip</span><span> </span><span>guaranteeStripPair_split_conv</span><span> </span><span>mark_guards_guards</span><span>
</span><span>  </span><span>mark_guards_while</span><span> </span><span>mark_guards_whileAnno</span><span> </span><span>mark_guards_whileAnnoG</span><span>
</span><span>  </span><span>mark_guards_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_Guard</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard c = (case c of Guard f g c&#39; &#8658; True | _ &#8658; False)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Guard_basic_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard Skip = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Basic f ev) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Spec r ev) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Seq c1 c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Cond b c1 c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (While b c) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Call p) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (DynCom C) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Guard F g c) = True&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Throw) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Catch c1 c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (raise f ev) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (condCatch c1 b c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (bind e cv) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (bseq c1 c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (block init ei bdy return er cont) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (call init ei p return er cont) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (dynCall init ei P return er cont) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (fcall init ei p return er result cont&#39;) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (whileAnno b I V c) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (guaranteeStrip F g c) = True&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Await b ca ev) = False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>raise_def</span><span> </span><span>condCatch_def</span><span> </span><span>bind_def</span><span> </span><span>bseq_def</span><span>
</span><span>          </span><span>block_def</span><span> </span><span>call_def</span><span> </span><span>dynCall_def</span><span> </span><span>fcall_def</span><span> </span><span>whileAnno_def</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Guard_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (switch v Vc) = False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Vc</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>is_Guard_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>is_Guard_basic_simps</span><span> </span><span>is_Guard_switch</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>dest_Guard</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;f &#215; &#39;s set &#215; (&#39;s, &#39;p, &#39;f, &#39;e) com)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dest_Guard (Guard f g c) = (f,g,c)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dest_Guard_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dest_Guard (guaranteeStrip f g c) = (f,g,c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>dest_Guard_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>dest_Guard.simps</span><span> </span><span>dest_Guard_guaranteeStrip</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Merging Guards: @{text merge_guards}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>merge_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Basic g e) = Basic g e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Spec r e) = Spec r e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (Seq (merge_guards c<span class="hidden">&#8681;</span><sub>1</sub>) (merge_guards c<span class="hidden">&#8681;</span><sub>2</sub>))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (merge_guards c<span class="hidden">&#8681;</span><sub>1</sub>) (merge_guards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (While b c) = While b (merge_guards c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (DynCom c) = DynCom (&#955;s. (merge_guards (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Await b ca e) = Await b (Language.merge_guards ca) e&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&quot;merge_guards (Guard f g c) = 
    (case (merge_guards c) of
      Guard f&#39; g&#39; c&#39; &#8658; if f=f&#39; then Guard f (g &#8745; g&#39;) c&#39; 
                        else Guard f g (Guard f&#39; g&#39; c&#39;)
     | _ &#8658;  Guard f g (merge_guards c))&quot;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the following version works better with derived language constructs *)</span></span></span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Guard f g c) = 
    (let c&#39; = (merge_guards c)
     in if is_Guard c&#39; 
        then let (f&#39;,g&#39;,c&#39;&#39;) = dest_Guard c&#39; 
             in if f=f&#39; then Guard f (g &#8745; g&#39;) c&#39;&#39; 
                        else Guard f g (Guard f&#39; g&#39; c&#39;&#39;)
        else Guard f g c&#39;)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (merge_guards c<span class="hidden">&#8681;</span><sub>1</sub>) (merge_guards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Skip &#10233; c = Skip&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Basic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Basic f e &#10233; c = Basic f e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Spec r e &#10233; c = Spec r e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Seq c1 c2 &#10233; 
    &#8707;c1&#39; c2&#39;. c = Seq c1&#39; c2&#39; &#8743; merge_guards c1&#39; = c1 &#8743; merge_guards c2&#39; = c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Cond b c1 c2 &#10233; 
    &#8707;c1&#39; c2&#39;. c = Cond b c1&#39; c2&#39; &#8743; merge_guards c1&#39; = c1 &#8743; merge_guards c2&#39; = c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_While</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = While b c&#39; &#10233; 
    &#8707;c&#39;&#39;. c = While b c&#39;&#39;  &#8743; merge_guards c&#39;&#39; = c&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Call</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Call p &#10233; c = Call p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_DynCom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = DynCom c&#39; &#10233; 
    &#8707;c&#39;&#39;. c = DynCom c&#39;&#39;  &#8743; (&#955;s. (merge_guards (c&#39;&#39; s))) = c&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Throw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Throw &#10233; c = Throw&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Catch c1 c2 &#10233; 
    &#8707;c1&#39; c2&#39;. c = Catch c1&#39; c2&#39; &#8743; merge_guards c1&#39; = c1 &#8743; merge_guards c2&#39; = c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Guard</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Guard f g c&#39; &#10233; &#8707;c&#39;&#39; f&#39; g&#39;. c = Guard f&#39; g&#39; c&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Await</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Await b c&#39; e &#10233; 
      &#8707;c&#39;&#39;. c = Await b c&#39;&#39; e &#8743; Language.merge_guards c&#39;&#39; = c&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_guards_res_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_guards_res_Skip</span><span> </span><span>merge_guards_res_Basic</span><span> 
</span><span> </span><span>merge_guards_res_Spec</span><span> </span><span>merge_guards_res_Seq</span><span> </span><span>merge_guards_res_Cond</span><span> 
</span><span> </span><span>merge_guards_res_While</span><span> </span><span>merge_guards_res_Call</span><span>
</span><span> </span><span>merge_guards_res_DynCom</span><span> </span><span>merge_guards_res_Throw</span><span> </span><span>merge_guards_res_Catch</span><span> 
</span><span> </span><span>merge_guards_res_Guard</span><span> </span><span>merge_guards_res_Await</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_raise</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (raise g e) = raise g e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (condCatch c1 b c2) = 
    condCatch (merge_guards c1) b (merge_guards c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (bind e c) = bind e (&#955;v. merge_guards (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (bseq c1 c2) = bseq (merge_guards c1) (merge_guards c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (block init ei bdy return er c) =
    block init ei (merge_guards bdy) return er (&#955;s t. merge_guards (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (call init ei p return er c) =
     call init ei p return er (&#955;s t. merge_guards (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (dynCall init ei p return er c) =
     dynCall init ei p return er (&#955;s t. merge_guards (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (fcall init ei p return er result c) =
     fcall init ei p return er result (&#955;v. merge_guards (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (switch v vs) = 
     switch v (map (&#955;(V,c). (V,merge_guards c)) vs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>vs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (guaranteeStrip f g c) = 
    (let c&#39; = (merge_guards c)
     in if is_Guard c&#39; 
        then let (f&#39;,g&#39;,c&#39;) = dest_Guard c&#39; 
             in if f=f&#39; then Guard f (g &#8745; g&#39;) c&#39; 
                        else Guard f g (Guard f&#39; g&#39; c&#39;)
        else Guard f g c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (whileAnno b I V c) = whileAnno b I V (merge_guards c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (specAnno P c Q A) = 
    specAnno P (&#955;s. merge_guards (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* @{term &quot;merge_guards&quot;} for guard-lists as in @{const guards}, @{const while}
 and @{const whileAnnoG} may have funny effects since the guard-list has to
 be merged with the body statement too.*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_guards_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_guards.simps</span><span> </span><span>merge_guards_raise</span><span> 
</span><span>  </span><span>merge_guards_condCatch</span><span> </span><span>merge_guards_bind</span><span> </span><span>merge_guards_bseq</span><span> </span><span>merge_guards_block</span><span>
</span><span>  </span><span>merge_guards_dynCall</span><span> </span><span>merge_guards_fcall</span><span> </span><span>merge_guards_switch</span><span> 
</span><span>  </span><span>merge_guards_guaranteeStrip</span><span> </span><span>merge_guards_whileAnno</span><span> </span><span>merge_guards_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>noguards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards Skip = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Basic f e) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Spec r e ) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (noguards c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noguards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (noguards c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noguards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (While b c) = (noguards c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Call p) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (DynCom c) = (&#8704;s. noguards (c s))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Guard f g c) = False&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards Throw = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (noguards c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noguards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Await b c e) = (Language.noguards c) &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noawaits_noguards_seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits c &#10233; noguards c = Language.noguards (sequential c)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noguards_strip_guards</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;noguards (strip_guards UNIV c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>noguards_strip_guards</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>nothrows</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows Skip = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Basic f e) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Spec r e) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (nothrows c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; nothrows c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (nothrows c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; nothrows c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (While b c) = nothrows c&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Call p) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (DynCom c) = (&#8704;s. nothrows (c s))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Guard f g c) = nothrows c&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows Throw = False&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (nothrows c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; nothrows c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Await b cn e) = Language.nothrows cn&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noawaits_nothrows_seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;noawaits c &#10233; nothrows c = Language.nothrows (sequential c)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Intersecting Guards: @{text &quot;c<span class="hidden">&#8681;</span><sub>1</sub> &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c<span class="hidden">&#8681;</span><sub>2</sub>&quot;}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>com_rel</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;s, &#39;p, &#39;f, &#39;e) com &#215; (&#39;s, &#39;p, &#39;f, &#39;e) com) set&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(c1, Seq c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2, Seq c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c1, Cond b c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2, Cond b c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, While b c) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c x, DynCom c) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Guard f g c) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c1, Catch c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2, Catch c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Skip) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Basic f e) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Spec r e) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Seq c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Cond b c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, While b c1) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Call p) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, DynCom c1) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Guard f g c1) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Throw) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Catch c1 c2) &#8712; com_rel&quot;</span></span></span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Await b cn e) &#8712; com_rel&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_com_rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf com_rel&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wfUNIVI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>            </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>           </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>          </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>         </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>
</span><span>                </span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>        </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>
</span><span>               </span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>       </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>      </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>     </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>inter_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#215; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com option&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span>  </span><span>inter_guards_syntax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) LanguageCon.com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) LanguageCon.com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) LanguageCon.com option&quot;</span></span></span><span>
</span><span>           </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>20</span><span class="delimiter">,</span><span>20</span><span class="delimiter">]</span><span> </span><span>19</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((c::(&#39;s, &#39;p, &#39;f, &#39;e) com) &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> (d::(&#39;s, &#39;p, &#39;f, &#39;e) com)) == LanguageCon.inter_guards (c,d)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">recdef</span></span><span> </span><span>inter_guards</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_image com_rel fst&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;(Skip &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Skip) = Some Skip&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Basic f1 e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Basic f2 e2) = (if (f1=f2) &#8743; (e1=e2) then Some (Basic f1 e1) else None)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Spec r1 e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Spec r2 e2) = (if (r1=r2) &#8743; (e1=e2) then Some (Spec r1 e1) else None)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq a1 a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Seq b1 b2) = 
   (case (a1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b1) of
      None &#8658; None
    | Some c1 &#8658; (case (a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b2) of
                    None &#8658; None
                  | Some c2 &#8658; Some (Seq c1 c2)))&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Cond cnd1 t1 e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Cond cnd2 t2 e2) = 
   (if (cnd1=cnd2) 
    then (case (t1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> t2) of 
            None &#8658; None
          | Some t &#8658; (case (e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> e2) of
                         None &#8658; None
                       | Some e &#8658; Some (Cond cnd1 t e)))
    else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(While cnd1 c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> While cnd2 c2) = 
    (if (cnd1=cnd2 )
     then (case (c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) of
             None &#8658; None
           | Some c &#8658; Some (While cnd1 c))
     else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Call p1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Call p2) = 
   (if p1 = p2
    then Some (Call p1)
    else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(DynCom P1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> DynCom P2) = 
   (if (&#8704;s. ((P1 s) &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> (P2 s)) &#8800; None)
   then Some (DynCom (&#955;s.  the ((P1 s) &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> (P2 s))))
   else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Guard m1 g1 c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Guard m2 g2 c2) = 
   (if m1=m2 then
       (case (c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) of
          None &#8658; None
        | Some c &#8658; Some (Guard m1 (g1 &#8745; g2) c))
    else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Throw &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Throw) = Some Throw&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch a1 a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Catch b1 b2) = 
   (case (a1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b1) of
      None &#8658; None
    | Some c1 &#8658; (case (a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b2) of
                    None &#8658; None
                  | Some c2 &#8658; Some (Catch c1 c2)))&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;(Await cnd1 ca1 e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Await cnd2 ca2 e2) = 
 (if (cnd1=cnd2 &#8743; e1=e2) then 
       (case (ca1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> ca2) of
             None &#8658; None
           | Some c &#8658; Some (Await cnd1 c e1))
     else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(c &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> d) = None&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">hints</span></span><span> </span><span>cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span> </span><span>if_cong</span><span>  
</span><span>       </span><span>recdef_wf</span><span class="delimiter">:</span><span> </span><span>wf_com_rel</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>com_rel.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_strip_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;(c::(&#39;s, &#39;p, &#39;f, &#39;e) com). ((c1::(&#39;s, &#39;p, &#39;f, &#39;e) com) &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> (c2::(&#39;s, &#39;p, &#39;f, &#39;e) com)) = Some c  &#10233; 
    (strip_guards UNIV c = strip_guards UNIV c1) &#8743; 
    (strip_guards UNIV c = strip_guards UNIV c2)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c1</span><span> </span><span>c2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>inter_guards.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>8</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>inter_guards_strip_eq</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;c. (c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c &#10233; (c2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c1) = Some c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c1</span><span> </span><span>c2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>inter_guards.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>7</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>dest</span><span class="delimiter">:</span><span>inter_guards_sym</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Skip &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c = (c2=Skip &#8743; c=Skip)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Basic</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((Basic f e1) &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c = (c2=Basic f e1 &#8743; c=Basic f e1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Spec</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((Spec r e1) &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c = (c2=Spec r e1 &#8743; c=Spec r e1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Seq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Seq a1 a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c = 
     (&#8707;b1 b2 d1 d2. c2=Seq b1 b2 &#8743; (a1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b1) = Some d1 &#8743; 
        (a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b2) = Some d2 &#8743; c=Seq d1 d2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Cond</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Cond cnd t1 e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c =
     (&#8707;t2 e2 t e. c2=Cond cnd t2 e2 &#8743; (t1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> t2) = Some t &#8743; 
        (e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> e2) = Some e &#8743; c=Cond cnd t e)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_While</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(While cnd bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c =
     (&#8707;bdy2 bdy. c2 =While cnd bdy2 &#8743; (bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> bdy2) = Some bdy &#8743;
       c=While cnd bdy)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Await</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Await cnd bdy1 e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c =
     (&#8707;bdy2 bdy. c2 =Await cnd bdy2 e1 &#8743; (bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> bdy2) = Some bdy &#8743;
       c=Await cnd bdy e1)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Call</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Call p &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c =
     (c2=Call p &#8743; c=Call p)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_DynCom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(DynCom f1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c =
     (&#8707;f2. c2=DynCom f2 &#8743; (&#8704;s. ((f1 s) &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> (f2 s)) &#8800; None) &#8743;
      c=DynCom (&#955;s. the ((f1 s) &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> (f2 s))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Guard</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Guard f g1 bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c =
     (&#8707;g2 bdy2 bdy. c2=Guard f g2 bdy2 &#8743; (bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> bdy2) = Some bdy &#8743;
       c=Guard f (g1 &#8745; g2) bdy)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Throw</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Throw &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c = (c2=Throw &#8743; c=Throw)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Catch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch a1 a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2) = Some c = 
     (&#8707;b1 b2 d1 d2. c2=Catch b1 b2 &#8743; (a1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b1) = Some d1 &#8743; 
        (a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b2) = Some d2 &#8743; c=Catch d1 d2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>inter_guards_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>inter_guards_Skip</span><span> </span><span>inter_guards_Basic</span><span> </span><span>inter_guards_Spec</span><span>
</span><span>  </span><span>inter_guards_Seq</span><span> </span><span>inter_guards_Cond</span><span> </span><span>inter_guards_While</span><span> </span><span>inter_guards_Call</span><span>
</span><span>  </span><span>inter_guards_DynCom</span><span> </span><span>inter_guards_Guard</span><span> </span><span>inter_guards_Throw</span><span> 
</span><span>  </span><span>inter_guards_Catch</span><span> </span><span>inter_guards_Await</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Subset on Guards: @{text &quot;c<span class="hidden">&#8681;</span><sub>1</sub> &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c<span class="hidden">&#8681;</span><sub>2</sub>&quot;} *}</span></span></span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>subseteq_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#215; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; bool&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>subseteq_guards_syntax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; (&#39;s, &#39;p, &#39;f, &#39;e) com &#8658; bool&quot;</span></span></span><span>
</span><span>           </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>20</span><span class="delimiter">,</span><span>20</span><span class="delimiter">]</span><span> </span><span>19</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> d == subseteq_guards (c,d)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">recdef</span></span><span> </span><span>subseteq_guards</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_image com_rel snd&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;(Skip &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Skip) = True&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Basic f1 e1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Basic f2 e2) = ((f1=f2) &#8743; (e1 = e2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Spec r1 e1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Spec r2 e2) = ((r1=r2) &#8743; (e1 = e2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq a1 a2 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Seq b1 b2) = ((a1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b1) &#8743; (a2 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Cond cnd1 t1 e1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Cond cnd2 t2 e2) = ((cnd1=cnd2) &#8743; (t1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> t2) &#8743; (e1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> e2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(While cnd1 c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> While cnd2 c2) = ((cnd1=cnd2) &#8743; (c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Call p1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Call p2) = (p1 = p2)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(DynCom P1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> DynCom P2) = (&#8704;s. ((P1 s) &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> (P2 s)))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Guard m1 g1 c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Guard m2 g2 c2) = 
    ((m1=m2 &#8743; g1=g2 &#8743; (c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2)) &#8744; (Guard m1 g1 c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Guard m2 g2 c2) = (c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Await cnd1 ca1 e1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Await cnd2 ca2 e2) = ((cnd1=cnd2) &#8743; (ca1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> ca2) &#8743; (e1=e2))&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Throw &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Throw) = True&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch a1 a2 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Catch b1 b2) = ((a1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b1) &#8743; (a2 &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> b2))&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;(c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> d) = False&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">hints</span></span><span> </span><span>cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span>  
</span><span>       </span><span>recdef_wf</span><span class="delimiter">:</span><span> </span><span>wf_com_rel</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>com_rel.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Skip</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Skip &#10233; c = Skip&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Basic</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Basic f e &#10233; c = Basic f e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Spec</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Spec r e &#10233; c = Spec r e&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Seq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Seq c1 c2 &#10233; &#8707;c1&#39; c2&#39;. c=Seq c1&#39; c2&#39; &#8743; (c1&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c1) &#8743; (c2&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Cond</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Cond b c1 c2 &#10233; &#8707;c1&#39; c2&#39;. c=Cond b c1&#39; c2&#39; &#8743; (c1&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c1) &#8743; (c2&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_While</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> While b c&#39; &#10233; &#8707;c&#39;&#39;. c=While b c&#39;&#39; &#8743; (c&#39;&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Await</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Await b c&#39; e &#10233; &#8707;c&#39;&#39;. c=Await b c&#39;&#39; e &#8743; (c&#39;&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Call</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Call p &#10233; c = Call p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_DynCom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> DynCom C &#10233; &#8707;C&#39;. c=DynCom C&#39; &#8743; (&#8704;s. C&#39; s &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> C s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Guard</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Guard f g c&#39;  &#10233; 
     (c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c&#39;) &#8744; (&#8707;c&#39;&#39;. c=Guard f g c&#39;&#39; &#8743; (c&#39;&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Throw</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Throw &#10233; c = Throw&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Catch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> Catch c1 c2 &#10233; &#8707;c1&#39; c2&#39;. c=Catch c1&#39; c2&#39; &#8743; (c1&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c1) &#8743; (c2&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>subseteq_guardsD</span><span> </span><span class="delimiter">=</span><span> </span><span>subseteq_guards_Skip</span><span> </span><span>subseteq_guards_Basic</span><span>
</span><span> </span><span>subseteq_guards_Spec</span><span> </span><span>subseteq_guards_Seq</span><span> </span><span>subseteq_guards_Cond</span><span> </span><span>subseteq_guards_While</span><span>
</span><span> </span><span>subseteq_guards_Call</span><span> </span><span>subseteq_guards_DynCom</span><span> </span><span>subseteq_guards_Guard</span><span>
</span><span> </span><span>subseteq_guards_Throw</span><span> </span><span>subseteq_guards_Catch</span><span> </span><span>subseteq_guards_Await</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Guard&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Guard f b c &#8838;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> d &#10233; &#8707;f&#39; b&#39; c&#39;. d=Guard f&#39; b&#39; c&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Antisymmetry and transitivity should hold as well&#8230; *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
