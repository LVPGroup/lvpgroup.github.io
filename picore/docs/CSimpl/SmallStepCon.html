<?xml version="1.0" encoding="utf-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory SmallStepCon (Isabelle2018: August 2018)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory SmallStepCon</h1>

<span class="command">theory</span> <span class="name">SmallStepCon</span><br/>
<span class="keyword">imports</span> <a href="SmallStep.html"><span class="name">SmallStep</span></a> <a href="TerminationCon.html"><span class="name">TerminationCon</span></a> <a href="ActionsSemantics.html"><span class="name">ActionsSemantics</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
    Author:      David Sanan
    Maintainer:  David Sanan, sanan at ntu edu sg
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      SmallStepCon.thy
    Author:     David Sanan, NTU

Copyright (C) 2015-2016 David Sanan 
Some rights reserved, NTU
This library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Small-Step Semantics and Infinite Computations*}</span></span></span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>SmallStepCon</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;EmbSimpl/SmallStep&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SemanticCon&quot;</span></span></span><span>  
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">&quot;TerminationCon&quot;</span></span></span><span>
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">&quot;../lib/Sep_Algebra/Sep_Heap_Instance&quot;</span></span></span><span> 
</span><span>                            </span><span class="string"><span class="delete"><span class="delete">&quot;../Actions/ActionsSemantics&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The redex of a statement is the substatement, which is actually altered
by the next step in the small-step semantics.
*}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>redex</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e)com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e)com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Basic f e) = (Basic f e)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Spec r e) = (Spec r e)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = redex c<span class="hidden">&#8681;</span><sub>1</sub>&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (While b c) = (While b c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Call p) = (Call p)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (DynCom d) = (DynCom d)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Guard f b c) = (Guard f b c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Throw) = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = redex c<span class="hidden">&#8681;</span><sub>1</sub>&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;redex (Await b c e) = (Await b c e)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Small-Step Computation: @{text &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(c, s) &#8594; (c&#39;, s&#39;)&quot;}*}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;s</span><span class="delimiter">,</span><span class="tfree">&#39;p</span><span class="delimiter">,</span><span class="tfree">&#39;f</span><span class="delimiter">,</span><span class="tfree">&#39;e</span><span class="delimiter">)</span><span> </span><span>config</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e)com  &#215; (&#39;s,&#39;f) xstate&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;step_e&quot;</span></span></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body,(&#39;s,&#39;p,&#39;f,&#39;e) config,(&#39;s,&#39;p,&#39;f,&#39;e) config] &#8658; bool&quot;</span></span></span><span>
</span><span>                                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (_ &#8594;<span class="hidden">&#8681;</span><sub>e</sub>/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>&#915;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) body&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>Env</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Ps, Normal s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps, t)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span>Env_n</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;t&#39;. t&#8800;Normal t&#39;) &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Ps, t) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps, t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>etranE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> c &#8594;<span class="hidden">&#8681;</span><sub>e</sub> c&#39; &#10233; (&#8896;P s t. c = (P, s) &#10233; c&#39; = (P, t) &#10233; Q) &#10233; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>c&#39;</span><span class="delimiter">,</span><span> </span><span>erule</span><span>  </span><span>step_e.cases</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepe_Normal_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Ps,Normal s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepe_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Ps,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepe_not_norm_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Ps,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,Abrupt t)&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Ps,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,Stuck)&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Ps,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,Fault t)&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Ps,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,Normal t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_c_c&#39;_false</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~(c=c&#39;)  &#10233; P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_m</span><span> </span><span>etranE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>eenv_normal_s&#39;_normal_s</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, Normal s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;s1. s&#8800;Normal s1)  &#10233; P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_m</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_normal_s&#39;_normal_s</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, Normal s&#39;) &quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;s1. s= Normal s1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_m</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_c_c&#39;</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c=c&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>env_c_c&#39;_false</span><span> </span><span>step_m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_normal_s</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;) &#8743; s&#8800;s&#39;&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s = Normal sa&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod.inject</span><span> </span><span>step_e.cases</span><span> </span><span>step_m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_not_normal_s</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;t. s&#8800;Normal t)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=s&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>step_e.cases</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_not_normal_s_not_norma_t</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;t. s&#8800;Normal t)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;t. s&#39;&#8800;Normal t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>env_not_normal_s</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stepe_not_Fault_f_end</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;&#8713; Fault ` f &#10233; s &#8713; Fault ` f&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fault</span><span> </span><span>f&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>s&#39;_f</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s&#39; &#8713; Fault ` f&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>           </span><span class="string"><span class="delete"><span class="delete">&quot;s = Fault f&#39;&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=s&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_e</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>env_normal_s</span><span> </span><span>xstate.distinct</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s&#39;_f</span><span> </span><span>Fault</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>       
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;stepc&quot;</span></span></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body,(&#39;s,&#39;p,&#39;f,&#39;e) config,(&#39;s,&#39;p,&#39;f,&#39;e) config] &#8658; bool&quot;</span></span></span><span>
</span><span>                                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (_ &#8594;/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>&#915;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) body&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>
</span><span>  </span><span>Basicc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Basic f e,Normal s) &#8594; (Skip,Normal (f s))&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Specc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(s,t) &#8712; r &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Spec r e,Normal s) &#8594; (Skip,Normal t)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>SpecStuckc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t. (s,t) &#8713; r &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Spec r e,Normal s) &#8594; (Skip,Stuck)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Guardc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;g &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Guard f g c,Normal s) &#8594; (c,Normal s)&quot;</span></span></span><span>
</span><span>  
</span><span class="delimiter">|</span><span> </span><span>GuardFaultc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8713;g &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Guard f g c,Normal s) &#8594; (Skip,Fault f)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Seqc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;,s&#39;)
        &#10233; 
        &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594; (Seq c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>SeqSkipc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>, s)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>SeqThrowc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq Throw c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8594; (Throw, Normal s)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CondTruec</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;b &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CondFalsec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8713;b &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>WhileTruec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#8712;b&#10215; 
              &#10233; 
              &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(While b c,Normal s) &#8594; (Seq c (While b c),Normal s)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>WhileFalsec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#8713;b&#10215; 
               &#10233; 
               &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(While b c,Normal s) &#8594; (Skip,Normal s)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Awaitc</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#8712;b; &#915;1=&#915;<span class="hidden">&#8681;</span><sub>&#172;</sub><span class="hidden">&#8681;</span><sub>a</sub> ; &#915;1&#8866;&#10216;ca1,Normal s&#10217; &#8658; t; 
             &#172;(&#8707;t&#39;. t = Abrupt t&#39;)&#10215; &#10233; 
            &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Await b ca1 e,Normal s) &#8594; (Skip,t)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>AwaitAbruptc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;s&#8712;b; &#915;1=&#915;<span class="hidden">&#8681;</span><sub>&#172;</sub><span class="hidden">&#8681;</span><sub>a</sub> ; &#915;1&#8866;&#10216;ca1,Normal s&#10217; &#8658; t; 
                  t = Abrupt t&#39;&#10215; &#10233; 
                 &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Await b ca1 e,Normal s) &#8594; (Throw,Normal t&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Callc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915; p = Some bdy ; bdy&#8800;Call p&#10215; &#10233;
         &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,Normal s) &#8594; (bdy,Normal s)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CallUndefinedc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; p=None &#10233;
         &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,Normal s) &#8594; (Skip,Stuck)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>DynComc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(DynCom c,Normal s) &#8594; (c s,Normal s)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>Catchc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;,s&#39;)&#10215;
          &#10233;
          &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594; (Catch c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CatchThrowc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch Throw c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CatchSkipc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594; (Skip,s)&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>FaultPropc</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;c&#8800;Skip; redex c = c&#10215; &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(c,Fault f) &#8594; (Skip,Fault f)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>StuckPropc</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;c&#8800;Skip; redex c = c&#10215; &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(c,Stuck) &#8594; (Skip,Stuck)&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>AbruptPropc</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;c&#8800;Skip; redex c = c&#10215; &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(c,Abrupt f) &#8594; (Skip,Abrupt f)&quot;</span></span></span><span>
</span><span>                                                              
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>stepc_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>stepc.induct</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c,s)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c&#39;,s&#39;)&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>split_format</span><span> </span><span class="delimiter">(</span><span>complete</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>case_names</span><span>
</span><span>Basicc</span><span> </span><span>Specc</span><span> </span><span>SpecStuckc</span><span> </span><span>Guardc</span><span> </span><span>GuardFaultc</span><span> </span><span>Seqc</span><span> </span><span>SeqSkipc</span><span> </span><span>SeqThrowc</span><span> </span><span>CondTruec</span><span> </span><span>CondFalsec</span><span>
</span><span>WhileTruec</span><span> </span><span>WhileFalsec</span><span> </span><span>Awaitc</span><span> </span><span>AwaitAbruptc</span><span> </span><span>Callc</span><span> </span><span>CallUndefinedc</span><span> </span><span>DynComc</span><span> </span><span>Catchc</span><span> </span><span>CatchThrowc</span><span> </span><span>CatchSkipc</span><span>
</span><span>FaultPropc</span><span> </span><span>StuckPropc</span><span> </span><span>AbruptPropc</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>set</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Skip,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Guard f g c,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Basic f e,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Spec r e,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c1 c2,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Cond b c1 c2,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(While b c,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Await b c2 e,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(DynCom c,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Throw,s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c1 c2,s) &#8594; u&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_not_normal_elim_cases</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,Abrupt s) &#8594; (p&#39;,s&#39;)&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p, Fault f) &#8594; (p&#39;,s&#39;)&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p, Stuck) &#8594; (p&#39;,s&#39;)&quot;</span></span></span><span>
</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Guardc_not_c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Guard f g c &#8800; c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Catch_not_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Catch c1 c2 &#8800; c1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c1</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Catch_not_c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Catch c1 c2 &#8800; c2&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_not_eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Seq c1 c2&#8800;c1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c1</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_not_eq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Seq c1 c2&#8800;c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_not_eq1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Cond b c1 c2 &#8800;c1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c1</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>if_not_eq2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Cond b c1 c2&#8800;c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>seq_and_if_not_eq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span> </span><span class="delimiter">=</span><span> </span><span>seq_not_eq1</span><span> </span><span>seq_not_eq2</span><span> 
</span><span>seq_not_eq1</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span> </span><span>seq_not_eq2</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span> 
</span><span>if_not_eq1</span><span> </span><span>if_not_eq2</span><span> </span><span>if_not_eq1</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span> </span><span>if_not_eq2</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span>Catch_not_c1</span><span> </span><span>Catch_not_c</span><span> </span><span>Catch_not_c1</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span> </span><span>Catch_not_c</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span> 
</span><span>Guardc_not_c</span><span> </span><span>Guardc_not_c</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>not_sym</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Seq_Seq</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c1 c2,s) &#8594; (Seq c1&#39; c2,s&#39;)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Seq_Seq1</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c1 c2,Fault f) &#8594; (q,s&#39;)&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>stepc_elim_cases_Seq_Seq1</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Catch_Catch</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c1 c2,s) &#8594; (Catch c1&#39; c2,s&#39;)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Catch_Catch1</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c1 c2,Fault f) &#8594; (q,s&#39;)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Seq_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq Skip c2,s) &#8594; u&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq (Guard f g c1) c2,s) &#8594; u&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Catch_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch Skip c2,s) &#8594; u&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Await_skip</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Await b c e, Normal s) &#8594; (Skip,t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Await_throw</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Await b c e, Normal s) &#8594; (Throw,t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Catch_throw</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c1 c2,s) &#8594; (Throw, Normal s1)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Catch_skip_c2</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c1 c2,s) &#8594; (c2,s)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_Normal_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Skip,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Guard f g c,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Basic f e,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Spec r e,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c1 c2,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Cond b c1 c2,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(While b c,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Await b c e,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(DynCom c,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Throw,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c1 c2,Normal s) &#8594; u&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The final configuration is either of the form @{text &quot;(Skip,_)&quot;} for normal
termination, or @{term &quot;(Throw,Normal s)&quot;} in case the program was started in 
a @{term &quot;Normal&quot;} state and terminated abruptly. The @{const &quot;Abrupt&quot;} state is not used to
model abrupt termination, in contrast to the big-step semantics. Only if the
program starts in an @{const &quot;Abrupt&quot;} states it ends in the same @{term &quot;Abrupt&quot;}
state.*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>final</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) config &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;final cfg &#8801; (fst cfg=Skip &#8744; ((fst cfg=Throw) &#8743; (&#8707;s. snd cfg=Normal s)))
             (* ((fst cfg=Skip &#8744; fst cfg=Throw) &#8743; (&#8707;s. snd cfg=Normal s)) &#8744; *) 
             (*&#8744; (&#8707;b c. (redex (fst cfg) = Await b c) &#8743; (&#8707;s. snd cfg=Normal s &#8743; s&#8713;b)) *)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>final_valid</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) config &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;final_valid cfg = ((fst cfg=Skip &#8744; fst cfg=Throw) &#8743; (&#8707;s. snd cfg=Normal s))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;stepc_rtrancl&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body,(&#39;s,&#39;p,&#39;f,&#39;e) config,(&#39;s,&#39;p,&#39;f,&#39;e) config] &#8658; bool&quot;</span></span></span><span>
</span><span>                                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (_ &#8594;<span class="hidden">&#8679;</span><sup>*</sup>/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>                                
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8679;</span><sup>*</sup> cf1 &#8801; ((CONST stepc &#915;))<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> cf0 cf1&quot;</span></span></span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8679;</span><sup>*</sup> cf1 &#8801; (CONST ((stepc &#915;) &#8746; (step_e &#915;)))<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> cf0 cf1&quot; *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;stepc_trancl&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body,(&#39;s,&#39;p,&#39;f,&#39;e) config,(&#39;s,&#39;p,&#39;f,&#39;e) config] &#8658; bool&quot;</span></span></span><span>
</span><span>                                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (_ &#8594;<span class="hidden">&#8679;</span><sup>+</sup>/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8679;</span><sup>+</sup> cf1 &#8801; (CONST stepc &#915;)<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> cf0 cf1&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>           </span><span>step_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Await b c e, Normal s) &#8594; (t,u)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>step_await_step_c</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;<span class="hidden">&#8681;</span><sub>&#172;</sub><span class="hidden">&#8681;</span><sub>a</sub>)&#8866;(c, Normal s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (sequential t,u)&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_a</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(t, u) = (Skip, t1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712; b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;<span class="hidden">&#8681;</span><sub>&#172;</sub><span class="hidden">&#8681;</span><sub>a</sub>)&#8866; &#10216;c,Normal s&#10217; &#8658; t1&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t&#39;. t1 &#8800; Abrupt t&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>u</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>exec_impl_steps_Fault</span><span> </span><span>exec_impl_steps_Normal</span><span> </span><span>exec_impl_steps_Stuck</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>t1</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(t, u) = (Throw, Normal t1)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8712; b&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;<span class="hidden">&#8681;</span><sub>&#172;</sub><span class="hidden">&#8681;</span><sub>a</sub>)&#8866; &#10216;c,Normal s&#10217; &#8658; Abrupt t1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_impl_steps_Normal_Abrupt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* exec: &quot;&#915;&#8866;&#10216;c,Normal s&#10217; &#8658; t&quot; and
           b: &quot;s &#8712; b&quot; and *)</span></span></span></span></span><span>
</span><span>           </span><span>step_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Await b c e, Normal s) &#8594; u&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span>step_await_final1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;final u&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_a</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>cases</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span>  </span><span class="delimiter">(</span><span>1</span><span> </span><span>t</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;final u&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>final_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>2</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;final u&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>exec_impl_steps_Normal_Abrupt</span><span> </span><span>final_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Abrupt_end</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Abrupt x &#10233; s=Abrupt x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Stuck_end</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Stuck &#10233; 
          s=Stuck &#8744; 
          (&#8707;r x e. redex c<span class="hidden">&#8681;</span><sub>1</sub> = Spec r e &#8743; s=Normal x &#8743; (&#8704;t. (x,t)&#8713;r)) &#8744; 
          (&#8707;p x. redex c<span class="hidden">&#8681;</span><sub>1</sub>=  Call p &#8743; s=Normal x &#8743; &#915; p = None) &#8744;
          (&#8707;b c x e.  redex c<span class="hidden">&#8681;</span><sub>1</sub> = Await b c e &#8743; s=Normal x &#8743; x &#8712; b &#8743; (&#915;<span class="hidden">&#8681;</span><sub>&#172;</sub><span class="hidden">&#8681;</span><sub>a</sub>)&#8866;&#10216;c,s&#10217;&#8658;s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Fault_end</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Fault f &#10233; 
          s=Fault f &#8744; 
          (&#8707;g c x.  redex c<span class="hidden">&#8681;</span><sub>1</sub> = Guard f g c &#8743; s=Normal x &#8743; x &#8713; g) &#8744;
          (&#8707;b c1 x e.  redex c<span class="hidden">&#8681;</span><sub>1</sub> = Await b c1 e &#8743; s=Normal x &#8743; x &#8712; b &#8743; (&#915;<span class="hidden">&#8681;</span><sub>&#172;</sub><span class="hidden">&#8681;</span><sub>a</sub>)&#8866;&#10216;c1,s&#10217;&#8658;s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_not_Fault_f_end</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;&#8713; Fault ` f &#10233; s &#8713; Fault ` f&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span>auto</span><span>
</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;step_ce&quot;</span></span></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body,(&#39;s,&#39;p,&#39;f,&#39;e) config,(&#39;s,&#39;p,&#39;f,&#39;e) config] &#8658; bool&quot;</span></span></span><span>
</span><span>                                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (_ &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub>/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>&#915;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) body&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>c_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594; cf1 &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> cf1 &quot;</span></span></span><span>
</span><span class="delimiter">|</span><span>e_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>e</sub> cf1 &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> cf1 &quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>step_ce_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>step_ce.induct</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c,s)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c&#39;,s&#39;)&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>split_format</span><span> </span><span class="delimiter">(</span><span>complete</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>case_names</span><span>
</span><span>c_step</span><span> </span><span>e_step</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>set</span><span class="delimiter">]</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>step_ce_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> cf1&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_c_normal_normal</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594; cf1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; c<span class="hidden">&#8681;</span><sub>1</sub> s s&#39;. &#10214;cf0 = (c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s);cf1=(c<span class="hidden">&#8681;</span><sub>1</sub>,s&#39;);(&#8704;sa. &#172;(s&#39;=Normal sa))&#10215;
          &#10233; P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>stepc.induct</span><span class="delimiter">,</span><span> </span><span>induct</span><span class="delimiter">,</span><span> </span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normal_not_normal_eq_p</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> cf1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; c<span class="hidden">&#8681;</span><sub>1</sub> s s&#39;. &#10214;cf0 = (c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s);cf1=(c<span class="hidden">&#8681;</span><sub>1</sub>,s&#39;);(&#8704;sa. &#172;(s&#39;=Normal sa))&#10215;
          &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>e</sub> cf1 &#8743; &#172;( &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594; cf1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>step_c_normal_normal</span><span> </span><span>step_e.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>call_not_normal_skip_always</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,s) &#8594; (p1,s1)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;sn. s &#8800; Normal sn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p1&#8800;Skip&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Normal</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Stuck</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,Stuck) &#8594; (p1,s1)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a1</span><span> </span><span>a2</span><span> </span><span>stepc_not_normal_elim_cases</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fault</span><span> </span><span>f</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,Fault f) &#8594; (p1,s1)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a1</span><span> </span><span>a2</span><span> </span><span>stepc_not_normal_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Abrupt</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,Abrupt a) &#8594; (p1,s1)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a1</span><span> </span><span>a2</span><span> </span><span>stepc_not_normal_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>call_f_step_not_s_eq_t_false</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>     </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Q,t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(redex P = Call fn &#8743; &#915; fn = Some bdy &#8743; s=Normal s&#39; &#8743; ~(s=t)) &#8744;
         (redex P = Call fn &#8743; &#915; fn = Some bdy &#8743; s=Normal s&#39; &#8743; s=t &#8743; P=Q &#8743; &#915; fn &#8800; Some (Call fn))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;False&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>stepc_induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>call_f_step_ce_not_s_eq_t_env_step</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>     </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (Q,t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(redex P = Call fn &#8743; &#915; fn = Some bdy &#8743; s=Normal s&#39; &#8743; ~(s=t)) &#8744;
         (redex P = Call fn &#8743; &#915; fn = Some bdy &#8743; s=Normal s&#39; &#8743; s=t &#8743; P=Q &#8743; &#915; fn &#8800; Some (Call fn)) &quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Q,t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Q,t) &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Q,t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>step_ce_elim_cases</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>call_f_step_not_s_eq_t_false</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;stepce_rtrancl&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body,(&#39;s,&#39;p,&#39;f,&#39;e) config,(&#39;s,&#39;p,&#39;f,&#39;e) config] &#8658; bool&quot;</span></span></span><span>
</span><span>                                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (_ &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup>/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>                                
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> cf1 &#8801; ((CONST step_ce &#915;))<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> cf0 cf1&quot;</span></span></span><span> 
</span><span>  </span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8679;</span><sup>*</sup> cf1 &#8801; (CONST ((stepc &#915;) &#8746; (step_e &#915;)))<span class="hidden">&#8679;</span><sup>*</sup><span class="hidden">&#8679;</span><sup>*</sup> cf0 cf1&quot; *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;stepce_trancl&quot;</span></span></span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body,(&#39;s,&#39;p,&#39;f,&#39;e) config,(&#39;s,&#39;p,&#39;f,&#39;e) config] &#8658; bool&quot;</span></span></span><span>
</span><span>                                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (_ &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>+</sup>/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>+</sup> cf1 &#8801; (CONST step_ce &#915;)<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> cf0 cf1&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*Parallel Computation: @{text &quot;&#915;&#8866;(c, s) &#8594;<span class="hidden">&#8681;</span><sub>p</sub>  (c&#39;, s&#39;)&quot;}*}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;s</span><span class="delimiter">,</span><span class="tfree">&#39;p</span><span class="delimiter">,</span><span class="tfree">&#39;f</span><span class="delimiter">,</span><span class="tfree">&#39;e</span><span class="delimiter">)</span><span> </span><span>par_Simpl</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e)com  list&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;s</span><span class="delimiter">,</span><span class="tfree">&#39;p</span><span class="delimiter">,</span><span class="tfree">&#39;f</span><span class="delimiter">,</span><span class="tfree">&#39;e</span><span class="delimiter">)</span><span> </span><span>par_config</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) par_Simpl &#215; (&#39;s,&#39;f) xstate&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>final_c</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) par_config &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;final_c cfg = (&#8704;i. i&lt;length (fst cfg) &#10230; final ((fst cfg)!i, snd cfg))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;step_pe&quot;</span></span></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body,(&#39;s,&#39;p,&#39;f,&#39;e) par_config,(&#39;s,&#39;p,&#39;f,&#39;e) par_config] &#8658; bool&quot;</span></span></span><span>
</span><span>                                </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (_ &#8594;<span class="hidden">&#8681;</span><sub>e</sub>/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>&#915;</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) body&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>ParEnv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (Ps, Normal s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps, Normal t)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ptranE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> c &#8594;<span class="hidden">&#8681;</span><sub>e</sub> c&#39; &#10233; (&#8896;P s t. c = (P, s) &#10233; c&#39; = (P, t) &#10233; Q) &#10233; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>c&#39;</span><span class="delimiter">,</span><span> </span><span>erule</span><span>  </span><span>step_pe.cases</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>step_pe_Normal_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(PS,Normal s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>step_pe_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(PS,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>step_pe_not_norm_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(Ps,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,Abrupt t)&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(Ps,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,Stuck)&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(Ps,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Ps,Fault t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_pe_c_c&#39;_false</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~(c=c&#39;)  &#10233; P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_m</span><span> </span><span>ptranE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_pe_c_c&#39;</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c=c&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>env_pe_c_c&#39;_false</span><span> </span><span>step_m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_pe_normal_s</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;) &#8743; s&#8800;s&#39;&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s = Normal sa&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod.inject</span><span> </span><span>step_pe.cases</span><span> </span><span>step_m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_pe_not_normal_s</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;t. s&#8800;Normal t)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=s&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>step_pe.cases</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>env_pe_not_normal_s_not_norma_t</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;t. s&#8800;Normal t)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;t. s&#39;&#8800;Normal t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>env_pe_not_normal_s</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive</span></span><span>       
</span><span class="string"><span class="delete"><span class="delete">&quot;step_p&quot;</span></span></span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;[(&#39;s,&#39;p,&#39;f,&#39;e) body, (&#39;s,&#39;p,&#39;f,&#39;e) par_config, 
            (&#39;s,&#39;p,&#39;f,&#39;e) par_config] &#8658; bool&quot;</span></span></span><span>
</span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (_ &#8594;/ _)&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">,</span><span>81</span><span class="delimiter">]</span><span> </span><span>100</span><span class="delimiter">)</span><span>  
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span>ParComp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;i&lt;length Ps;  &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Ps!i,s) &#8594; (r,s&#39;)&#10215; &#10233;  
           &#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(Ps, s) &#8594; (Ps[i:=r], s&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>steppe_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>step_p.induct</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c,s)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c&#39;,s&#39;)&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>split_format</span><span> </span><span class="delimiter">(</span><span>complete</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>case_names</span><span>
</span><span>ParComp</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>set</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>step_p_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(Ps, s) &#8594; u&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>step_p_pair_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(Ps, s) &#8594; (Qs, t)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>step_p_Normal_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(Ps, Normal s) &#8594; u&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>par_ctranE</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; &#8866;<span class="hidden">&#8681;</span><sub>p</sub> c &#8594; c&#39; &#10233;
  (&#8896;i Ps s r t. c = (Ps, s) &#10233; c&#39; = (Ps[i := r], t) &#10233; i &lt; length Ps &#10233;
     &#915; &#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Ps!i, s) &#8594; (r, t) &#10233; P) &#10233; P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>c&#39;</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>step_p.cases</span><span class="delimiter">,</span><span> </span><span>blast</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Computations&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Sequential computations&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;s</span><span class="delimiter">,</span><span class="tfree">&#39;p</span><span class="delimiter">,</span><span class="tfree">&#39;f</span><span class="delimiter">,</span><span class="tfree">&#39;e</span><span class="delimiter">)</span><span> </span><span>confs</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) body &#215;((&#39;s,&#39;p,&#39;f,&#39;e) config) list&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>cptn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;s,&#39;p,&#39;f,&#39;e) confs) set&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>CptnOne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; (&#915;, [(P,s)]) &#8712; cptn&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnEnv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P,t); (&#915;,(P, t)#xs) &#8712; cptn &#10215; &#10233;
             (&#915;,(P,s)#(P,t)#xs) &#8712; cptn&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnComp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Q,t); (&#915;,(Q, t)#xs) &#8712; cptn &#10215; &#10233; 
              (&#915;,(P,s)#(Q,t)#xs) &#8712; cptn&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>cptn_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(P,s)]) &#8712; cptn&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,s)#(Q,t)#xs) &#8712; cptn&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,s)#(P,t)#xs) &#8712; cptn&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>cptn_elim_cases_pair</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [x]) &#8712; cptn&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, x#x1#xs) &#8712; cptn&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_dest</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,s)#(Q,t)#xs) &#8712; cptn &#10233; (&#915;,(Q,t)#xs)&#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_dest_pair</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#x1#xs) &#8712; cptn &#10233; (&#915;,x1#xs)&#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#x1#xs) &#8712; cptn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_dest</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_dest1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,s)#(Q,t)#xs) &#8712; cptn &#10233; (&#915;,(P,s)#[(Q,t)])&#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P, s) # (Q, t) # xs) &#8712; cptn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(Q, t)]) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn.CptnOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Normal</span><span> </span><span>s&#39;</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P, Normal s&#39;) # (Q, t) # xs) &#8712; cptn&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Normal</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(P, t)]) &#8712; cptn &#10230; (&#915;, [(P, Normal s&#39;), (P, t)]) &#8712; cptn&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Env</span><span> </span><span>cptn.CptnEnv</span><span class="delimiter">)</span><span>       
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Normal</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(&#915;, [(Q, t)]) &#8712; cptn`</span></span></span><span> </span><span>cptn.CptnComp</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Abrupt</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(&#915;, [(Q, t)]) &#8712; cptn`</span></span></span><span> </span><span>a1</span><span> </span><span>cptn.CptnComp</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>CptnEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Stuck</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(&#915;, [(Q, t)]) &#8712; cptn`</span></span></span><span> </span><span>a1</span><span> </span><span>cptn.CptnComp</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>CptnEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fault</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(&#915;, [(Q, t)]) &#8712; cptn`</span></span></span><span> </span><span>a1</span><span> </span><span>cptn.CptnComp</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>CptnEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_dest1_pair</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#x1#xs) &#8712; cptn &#10233; (&#915;,x#[x1])&#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#x1#xs) &#8712; cptn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_dest1</span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_append_is_cptn</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;b a. (&#915;,b#c1)&#8712;cptn &#10230;  (&#915;,a#c2)&#8712;cptn &#10230; (b#c1)!length c1=a &#10230; (&#915;,b#c1@c2)&#8712;cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>c1</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>cptn.cases</span><span class="delimiter">,</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnEnv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_dest_2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,a#xs@ys) &#8712; cptn  &#10233; (&#915;,a#xs)&#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>a</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,a#[x])&#8712;cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_dest1_pair</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, x # xs&#39;) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span> </span><span>cptn_dest_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_append_is_cptn</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>&#915;</span><span> </span><span>a</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[x]&quot;</span></span></span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>    
</span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_not_F</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>  </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,xs)&#8712;cptn&quot;</span></span></span><span>  
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last xs) &#8713; Fault ` F &#10233; &#8704;i &lt; length xs. snd (xs!i) &#8713; Fault ` F&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">print_cases</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnOne</span><span> </span><span>&#915;</span><span> </span><span>p</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnEnv</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepe_not_Fault_f_end</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nn</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P, t) # xs)) &#8713; Fault ` F&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnEnv.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; nn &lt; length ((P, s) # (P, t) # xs) &#8744; snd (((P, s) # (P, t) # xs) ! nn) &#8713; Fault ` F&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>CptnEnv.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnEnv.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>length_Cons</span><span> </span><span>less_Suc_eq_0_disj</span><span> </span><span>nth_Cons_0</span><span> </span><span>nth_Cons_Suc</span><span> </span><span>snd_conv</span><span> </span><span>stepe_not_Fault_f_end</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n. &#172; n &lt; length ((P, s) # (P, t) # xs) &#8744; snd (((P, s) # (P, t) # xs) ! n) &#8713; Fault ` F&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnComp</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>Q</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Q, t) # xs)) &#8713; Fault ` F&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnComp.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length ((Q, t) # xs). snd (((Q, t) # xs) ! i) &#8713; Fault ` F&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnComp.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t &#8713; Fault ` F&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s &#8713; Fault ` F&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_not_Fault_f_end</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnComp.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zero</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (P,s) &#8713; Fault ` F&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nn</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; nn &lt; length ((P, s) # (Q, t) # xs) &#8744; snd (((P, s) # (Q, t) # xs) ! nn) &#8713; Fault ` F&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8704;i&lt;length ((Q, t) # xs). snd (((Q, t) # xs) ! i) &#8713; Fault ` F&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (P, s) &#8713; Fault ` F&#8250;</span></span></span><span> </span><span>diff_Suc_1</span><span> </span><span>length_Cons</span><span> </span><span>less_Suc_eq_0_disj</span><span> </span><span>nth_Cons&#39;</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) body &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) com &#8658; 
                  (&#39;s,&#39;f) xstate &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) confs) set&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;cp &#915; P s &#8801; {(&#915;1,l). l!0=(P,s) &#8743; (&#915;,l) &#8712; cptn &#8743; &#915;1=&#915;}&quot;</span></span></span><span>  
</span><span>
</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cp_sub</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(x#l0)@l1) &#8712; cp &#915; P s&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(x#l0)) &#8712; cp &#915; P s&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x#l0)!0 = (P,s)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(x#l0))&#8712;cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cp_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_dest_2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Parallel computations&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;s</span><span class="delimiter">,</span><span class="tfree">&#39;p</span><span class="delimiter">,</span><span class="tfree">&#39;f</span><span class="delimiter">,</span><span class="tfree">&#39;e</span><span class="delimiter">)</span><span> </span><span>par_confs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) body &#215;((&#39;s,&#39;p,&#39;f,&#39;e) par_config) list&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>par_cptn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) par_confs set&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>ParCptnOne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(P,s)]) &#8712; par_cptn&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>ParCptnEnv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P,t);(&#915;,(P, t)#xs) &#8712; par_cptn &#10215; &#10233;(&#915;,(P,s)#(P,t)#xs) &#8712; par_cptn&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>ParCptnComp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; &#915; &#8866;<span class="hidden">&#8681;</span><sub>p</sub>(P,s) &#8594; (Q,t); (&#915;,(Q,t)#xs) &#8712; par_cptn &#10215; &#10233; (&#915;,(P,s)#(Q,t)#xs) &#8712; par_cptn&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>par_cptn_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(P,s)]) &#8712; par_cptn&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,s)#(Q,t)#xs) &#8712; par_cptn&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>pe_ce</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>(P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P,t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length P. &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P!i,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P!i,t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt; length P&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P!i,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P!i,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span> </span><span>env_pe_not_normal_s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length P. &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P!i,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P!i,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="delimiter">(</span><span class="tfree">&#39;s</span><span class="delimiter">,</span><span class="tfree">&#39;p</span><span class="delimiter">,</span><span class="tfree">&#39;f</span><span class="delimiter">,</span><span class="tfree">&#39;e</span><span class="delimiter">)</span><span> </span><span>par_com</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com list&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>par_cp</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) body &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) com list &#8658; (&#39;s,&#39;f) xstate &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) par_confs) set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;par_cp &#915; P s &#8801; {(&#915;1,l). l!0=(P,s) &#8743; (&#915;,l) &#8712; par_cptn &#8743; &#915;1=&#915;}&quot;</span></span></span><span>  
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* definition par_cp :: &quot;(&#39;s,&#39;p,&#39;f,&#39;e) body &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) com list &#8658; (&#39;s,&#39;f) xstate &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) par_confs) set&quot; 
where
  &quot;par_cp &#915; P s &#8801; {(&#915;1,l). l!0=(P,s) &#8743; (&#915;,l) &#8712; par_cptn &#8743; &#915;1=&#915;}&quot; *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>par_cptn_dest</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,s)#(Q,t)#xs) &#8712; par_cptn &#10233; (&#915;,(Q,t)#xs)&#8712; par_cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>dest</span><span class="delimiter">:</span><span> </span><span>par_cptn_elim_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
lemmas about single step computation
*}</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ************************************************************************ *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Structural Properties of Small Step Computations *}</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ************************************************************************ *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>redex_not_Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;redex c = Seq c1 c2 &#10233; P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>redex_not_Catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;redex c = Catch c1 c2 &#10233; P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_final</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(c,s) &#8594; (c&#39;,s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;final (c,s) &#10233; P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>induct</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>final_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_step_final&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg &#8594; cfg&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;final cfg &#10233; P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cfg</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>cfg&#39;</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>no_step_final</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Abrupt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. s=Abrupt x &#10233; s&#39;=Abrupt x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Fault</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. s=Fault f &#10233; s&#39;=Fault f&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Stuck</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. s=Stuck &#10233; s&#39;=Stuck&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_not_normal_not_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s1. s&#8800;Normal s1 &#10233; &#8704;s1. s&#39; &#8800; Normal s1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>step_Abrupt</span><span> </span><span>step_Stuck</span><span> </span><span>step_Fault</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_not_normal_s_eq_t</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s1. s&#8800;Normal s1 &#10233; s=t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>step_Abrupt</span><span> </span><span>step_Stuck</span><span> </span><span>step_Fault</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ce_not_normal_s</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cf0 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> cf1&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> s s&#39;. &#10214;cf0 = (c<span class="hidden">&#8681;</span><sub>1</sub>,s);cf1=(c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;);(&#8704;sa. (s&#8800;Normal sa))&#10215;
                     &#10233; s=s&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>step_ce.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>step_not_normal_s_eq_t</span><span> </span><span>env_not_normal_s</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqSteps</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub>&#8594;<span class="hidden">&#8679;</span><sup>*</sup> cfg<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; c<span class="hidden">&#8681;</span><sub>1</sub> s c<span class="hidden">&#8681;</span><sub>1</sub>&#39; s&#39;. &#10214;cfg<span class="hidden">&#8681;</span><sub>1</sub> = (c<span class="hidden">&#8681;</span><sub>1</sub>,s);cfg<span class="hidden">&#8681;</span><sub>2</sub>=(c<span class="hidden">&#8681;</span><sub>1</sub>&#39;,s&#39;)&#10215;
          &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Seq c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>cfg&#39;&#39;</span><span class="delimiter">)</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594; cfg&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg&#39;&#39; &#8594;<span class="hidden">&#8679;</span><sup>*</sup> cfg<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cfg<span class="hidden">&#8681;</span><sub>1</sub> = (c<span class="hidden">&#8681;</span><sub>1</sub>, s)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cfg<span class="hidden">&#8681;</span><sub>2</sub> = (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfg&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cfg&#39;&#39;=(c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39;,s&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cfg&#39;&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>cfg&#39;&#39;</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39;,s&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594; (Seq c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seqc</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Trans.hyps</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>cfg&#39;&#39;</span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Seq c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CatchSteps</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>cfg<span class="hidden">&#8681;</span><sub>1</sub>&#8594;<span class="hidden">&#8679;</span><sup>*</sup> cfg<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; c<span class="hidden">&#8681;</span><sub>1</sub> s c<span class="hidden">&#8681;</span><sub>1</sub>&#39; s&#39;. &#10214;cfg<span class="hidden">&#8681;</span><sub>1</sub> = (c<span class="hidden">&#8681;</span><sub>1</sub>,s); cfg<span class="hidden">&#8681;</span><sub>2</sub>=(c<span class="hidden">&#8681;</span><sub>1</sub>&#39;,s&#39;)&#10215;
          &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Catch c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>cfg&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594; cfg&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg&#39;&#39; &#8594;<span class="hidden">&#8679;</span><sup>*</sup> cfg<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cfg<span class="hidden">&#8681;</span><sub>1</sub> = (c<span class="hidden">&#8681;</span><sub>1</sub>, s)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cfg<span class="hidden">&#8681;</span><sub>2</sub> = (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfg&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cfg&#39;&#39;=(c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39;,s&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cfg&#39;&#39;</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>step</span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>cfg&#39;&#39;</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39;,s&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594; (Catch c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>stepc.Catchc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Trans.hyps</span><span> </span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>cfg&#39;&#39;</span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch c<span class="hidden">&#8681;</span><sub>1</sub>&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Catch c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>      
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_Fault</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, Fault f) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Fault f)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, Fault f) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Fault f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>2</sub>, Fault f) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Fault f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SeqSteps</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>refl</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Fault f) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Fault f)&quot;</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Fault f) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>, Fault f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSkipc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>2</sub></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catch</span><span> </span><span>c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, Fault f) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Fault f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CatchSteps</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>refl</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Fault f) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Fault f)&quot;</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Fault f) &#8594; (Skip, Fault f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CatchSkipc</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>stepc.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_Stuck</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, Stuck) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Stuck)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, Stuck) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Stuck)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Stuck)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SeqSteps</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>refl</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck)&quot;</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSkipc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>2</sub></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catch</span><span> </span><span>c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, Stuck) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Stuck)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CatchSteps</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>refl</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck) &#8594; (Skip, Stuck)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CatchSkipc</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>stepc.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_Abrupt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, Abrupt s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Abrupt s)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, Abrupt s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Abrupt s)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Abrupt s)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>SeqSteps</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>refl</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s)&quot;</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSkipc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>2</sub></span><span>
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catch</span><span> </span><span>c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>c<span class="hidden">&#8681;</span><sub>2</sub></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, Abrupt s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip, Abrupt s)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CatchSteps</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>steps_c<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>refl</span><span> </span><span>refl</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s)&quot;</span></span></span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s) &#8594; (Skip, Abrupt s)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CatchSkipc</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">finally</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>stepc.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Fault_prop</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;f. s=Fault f &#10233; s&#39;=Fault f&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Abrupt_prop</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x. s=Abrupt x &#10233; s&#39;=Abrupt x&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_Stuck_prop</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=Stuck &#10233; s&#39;=Stuck&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_Fault_prop</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=Fault f &#10233; s&#39;=Fault f&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct2</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>c&#39;&#39;</span><span> </span><span>s&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>step_Fault_prop</span><span class="delimiter">)</span><span>    
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_Abrupt_prop</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=Abrupt t &#10233; s&#39;=Abrupt t&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct2</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>c&#39;&#39;</span><span> </span><span>s&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>step_Abrupt_prop</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_Stuck_prop</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=Stuck &#10233; s&#39;=Stuck&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct2</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>c&#39;&#39;</span><span> </span><span>s&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>step_Stuck_prop</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_seq_throw_normal</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>c_val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c=Seq Throw Q &#8743; c&#39;=Throw&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Normal</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Abrupt</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#915;</span><span> </span><span>Throw</span><span> </span><span>Q</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Throw,s&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Stuck</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#915;</span><span> </span><span>Throw</span><span> </span><span>Q</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Throw,s&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Fault</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#915;</span><span> </span><span>Throw</span><span> </span><span>Q</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Throw,s&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_catch_throw_normal</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>c_val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c=Catch Throw Q &#8743; c&#39;=Throw&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Normal</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Abrupt</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#915;</span><span> </span><span>Throw</span><span> </span><span>Q</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Throw,s&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Stuck</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#915;</span><span> </span><span>Throw</span><span> </span><span>Q</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Throw,s&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Fault</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>&#915;</span><span> </span><span>Throw</span><span> </span><span>Q</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Throw,s&#39;)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_normal_to_normal</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = Normal sa&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>finalc&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c&#39;, s&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup>(c1, s1) &#8743;  (&#8707;sb. s1 = Normal sb))&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; (&#8707;sc. s&#39;=Normal sc)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>sn</span><span> </span><span>finalc&#39;</span><span>                                  
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>sa</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct2</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Refl.prems</span><span class="delimiter">)</span><span>              
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>     
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>c&#39;&#39;</span><span> </span><span>s&#39;&#39;</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>converse_rtranclpE2</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s&#39;&#39;</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Abrupt</span><span> </span><span>a1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finalc&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>steps_Abrupt_prop</span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>                
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Stuck</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finalc&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>steps_Stuck_prop</span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>          
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Fault</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>finalc&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>steps_Fault_prop</span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>        
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Normal</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>finalc&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_spec_skip_normal_normal</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c,s)  &#8594; (c&#39;,s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c=Spec r e&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s=Normal s1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c&#39;=Skip&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;t. (s1,t) &#8712; r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;s1&#39;. s&#39;=Normal s1&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>s&#39;</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Normal</span><span> </span><span>u</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Stuck</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f r b p e. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Spec r e, Normal b) &#8594; p &#8744; 
            (&#8707;ba. p = (Skip::(&#39;b, &#39;a, &#39;c,&#39;d) com, Normal ba) &#8743; (b, ba) &#8712; r) &#8744; 
            p = (Skip, Stuck) &#8743; (&#8704;ba. (b, ba) &#8713; r)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>stepc_Normal_elim_cases</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fault</span><span> </span><span>f</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f r b p e. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Spec r e, Normal b) &#8594; p &#8744; 
            (&#8707;ba. p = (Skip::(&#39;b, &#39;a, &#39;c,&#39;d) com, Normal ba) &#8743; (b, ba) &#8712; r) &#8744; 
            p = (Skip, Stuck) &#8743; (&#8704;ba. (b, ba) &#8713; r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>stepc_Normal_elim_cases</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                       
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f r b p e. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Spec r e, Normal b) &#8594; p &#8744; 
        (&#8707;ba. p = (Skip::(&#39;b, &#39;a, &#39;c,&#39;d) com, Normal ba) &#8743; (b, ba) &#8712; r) &#8744; 
        p = (Skip, Stuck) &#8743; (&#8704;ba. (b, ba) &#8713; r)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>stepc_Normal_elim_cases</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* if not Normal not environmental *}</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 

NOTE
Call always change the program now 

lemma no_advance_call_inf:
assumes a0: &quot;redex p1 = Call f&quot; and
        a1: &quot;(&#915; f) = Some (Call f)&quot; 
shows &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (p1,Normal s) &#8594; (p1, Normal s)&quot;
using a0 a1
proof (induct p1)
  case (Catch) thus ?case by (simp add: Catchc)
next
  case (Seq) thus ?case by (simp add: Seqc)
next
  case (Call) thus ?case
    by (simp add: Callc) 
qed(auto) *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_advance_seq</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P = Seq p1 p2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (p1,Normal s) &#8594; (p1, Normal s)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,Normal s) &#8594; (P, Normal s)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seqc</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>no_advance_catch</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P = Catch p1 p2&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (p1,Normal s) &#8594; (p1, Normal s)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,Normal s) &#8594; (P, Normal s)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Catchc</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_step_c_env</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c, s&#39;) &#10233; 
 (&#8896;sa. &#172;(s=Normal sa)) &#10233; 
  (&#8896;sa. &#172;(s&#39;=Normal sa))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>stepe_elim_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_c_env_not_normal_eq_state</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c, s&#39;) &#10233; 
 (&#8896;sa. &#172;(s=Normal sa)) &#10233; 
  s=s&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>stepe_elim_cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_eq_not_env</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~(c=c&#39;) &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;) &#10233; P&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_m</span><span> </span><span>etranE</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_ce_not_step_e_step_c</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)) &#10233;(&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_m</span><span>  </span><span>step_ce_elim_cases</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_ce_notNormal</span><span class="delimiter">:</span><span>   
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;sa. &#172;(s=Normal sa)) &#10233; s&#39;=s&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_m</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>step_ce_induct</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>e_step</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f p pa. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594;<span class="hidden">&#8681;</span><sub>e</sub> pa &#8744; (&#8707;c. (&#8707;x. p = (c::(&#39;b, &#39;a, &#39;c,&#39;d) LanguageCon.com, x)) &#8743; (&#8707;x. pa = (c, x)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span>etranE</span><span> </span><span>stepe_elim_cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepe_elim_cases</span><span> </span><span>e_step.hyps</span><span> </span><span>e_step.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>c_step</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>b</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Normal</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c_step.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Stuck</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallStepCon.step_Stuck_prop</span><span> </span><span>c_step.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Fault</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallStepCon.step_Fault_prop</span><span> </span><span>c_step.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Abrupt</span><span> </span><span>a</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallStepCon.step_Abrupt_prop</span><span> </span><span>c_step.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_ce_not_Normal</span><span class="delimiter">:</span><span>  
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step_m</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;sa. &#172;(s=Normal sa) &#10233; s&#39;=s&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_m</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct2</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_ce_notNormal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_not_normal_ce_c</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;( &#8704;sa. &#172;(s=Normal sa)) &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct2</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;b=b&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_ce_notNormal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a&#39;, b&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`b=b&#39;`</span></span></span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Trans.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a, b) &#8594; (a&#39;, b&#39;) &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a, b) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (a&#39;, b&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>step_ce_elim_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a, b) &#8594; (a&#39;, b&#39;)&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a&#39;, b&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)`</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a, b) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (a&#39;, b&#39;)&quot;</span></span></span><span>   
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a = a&#39;&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a, b) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (a&#39;, b&#39;)`</span></span></span><span> </span><span>not_eq_not_env</span><span class="delimiter">)</span><span>   
</span><span>         </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a&#39;, b&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`b = b&#39;`</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>           
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_c_ce</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct2</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>a&#39;</span><span> </span><span>b&#39;</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (a, b) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (a&#39;, b&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>c_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_not_normal_c_ce</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;( &#8704;sa. &#172;(s=Normal sa)) &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>steps</span><span> </span><span>steps_c_ce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_not_normal_c_eq_ce</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;( &#8704;sa. &#172;(s=Normal sa))&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;) =  &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>normal</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps_c_ce</span><span> </span><span>steps_not_normal_ce_c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_ce_Fault</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, Fault f) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (Skip, Fault f)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SmallStepCon.steps_Fault</span><span> </span><span>steps_c_ce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_ce_Stuck</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, Stuck) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (Skip, Stuck)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SmallStepCon.steps_Stuck</span><span> </span><span>steps_c_ce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>steps_ce_Abrupt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, Abrupt a) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (Skip, Abrupt a)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SmallStepCon.steps_Abrupt</span><span> </span><span>steps_c_ce</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_ce_seq_throw_normal</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>c_val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c=Seq Throw Q &#8743; c&#39;=Throw&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span> </span><span>not_eq_not_env</span><span> 
</span><span>      </span><span>step_ce_not_step_e_step_c</span><span> </span><span>step_seq_throw_normal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_ce_catch_throw_normal</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>c_val</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c=Catch Throw Q &#8743; c&#39;=Throw&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. s=Normal sa&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>c_val</span><span> </span><span>not_eq_not_env</span><span>
</span><span>      </span><span>step_ce_not_step_e_step_c</span><span> </span><span>step_catch_throw_normal</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_ce_normal_to_normal</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>sn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = Normal sa&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>finalc&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c&#39;, s&#39;) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup>(c1, s1) &#8743;  (&#8707;sb. s1 = Normal sb))&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;         
       (&#8707;sc. s&#39;=Normal sc)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> </span><span>sn</span><span> </span><span>finalc&#39;</span><span> </span><span>steps_ce_not_Normal</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqSteps_ce</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub>&#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> cfg<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; c<span class="hidden">&#8681;</span><sub>1</sub> s c<span class="hidden">&#8681;</span><sub>1</sub>&#39; s&#39;. &#10214;cfg<span class="hidden">&#8681;</span><sub>1</sub> = (c<span class="hidden">&#8681;</span><sub>1</sub>,s);cfg<span class="hidden">&#8681;</span><sub>2</sub>=(c<span class="hidden">&#8681;</span><sub>1</sub>&#39;,s&#39;)&#10215;
          &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (Seq c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>cfg&#39;&#39;</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594; cfg&#39;&#39; &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594;<span class="hidden">&#8681;</span><sub>e</sub> cfg&#39;&#39;&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_ce_elim_cases</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594;<span class="hidden">&#8681;</span><sub>e</sub> cfg&#39;&#39;&quot;</span></span></span><span>          
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f p pa. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594;<span class="hidden">&#8681;</span><sub>e</sub> pa &#8744; (&#8707;c. 
                   (&#8707;x. p = (c::(&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com, x)) &#8743; (&#8707;x. pa = (c, x)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>etranE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658; (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com option) &#8658; 
                              (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; 
                              (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; 
                              (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                </span><span>xx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658; (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com option) &#8658; 
                       (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; 
                       (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; (&#39;a, &#39;c) xstate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>                </span><span>xxa</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658; (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com option) &#8658; 
                        (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; 
                       (&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; (&#39;a, &#39;c) xstate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f p pa. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594;<span class="hidden">&#8681;</span><sub>e</sub> pa &#8744; p = (cc f p pa, xx f p pa) &#8743; pa = (cc f p pa, xxa f p pa)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f c x xa. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c::(&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com, x) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c, xa) &#8744; 
                            (&#8707;a. x = Normal a) &#8744; (&#8704;a. xa &#8800; Normal a) &#8743; x = xa&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>stepe_elim_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c<span class="hidden">&#8681;</span><sub>1</sub>, xxa &#915; cfg<span class="hidden">&#8681;</span><sub>1</sub> cfg&#39;&#39;) = cfg&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>a1</span><span> </span><span>fst_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, xxa &#915; cfg<span class="hidden">&#8681;</span><sub>1</sub> cfg&#39;&#39;) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (LanguageCon.com.Seq c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Env</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>a1</span><span> </span><span>e_step</span><span> </span><span>r_into_rtranclp</span><span> 
</span><span>                       </span><span>rtranclp.rtrancl_into_rtrancl</span><span> </span><span>rtranclp_idemp</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594; cfg&#39;&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p. &#8707;c x. p = (c::(&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com, x::(&#39;a, &#39;c) xstate)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Seqc</span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>                   </span><span class="alt_string"><span class="delete"><span class="delete">`&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594; cfg&#39;&#39;`</span></span></span><span> </span><span>c_step</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CatchSteps_ce</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>steps</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>cfg<span class="hidden">&#8681;</span><sub>1</sub>&#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> cfg<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896; c<span class="hidden">&#8681;</span><sub>1</sub> s c<span class="hidden">&#8681;</span><sub>1</sub>&#39; s&#39;. &#10214;cfg<span class="hidden">&#8681;</span><sub>1</sub> = (c<span class="hidden">&#8681;</span><sub>1</sub>,s); cfg<span class="hidden">&#8681;</span><sub>2</sub>=(c<span class="hidden">&#8681;</span><sub>1</sub>&#39;,s&#39;)&#10215;
          &#10233; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (Catch c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>steps</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>cfg<span class="hidden">&#8681;</span><sub>1</sub></span><span> </span><span>cfg&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594; cfg&#39;&#39; &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594;<span class="hidden">&#8681;</span><sub>e</sub> cfg&#39;&#39;&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_ce_elim_cases</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594;<span class="hidden">&#8681;</span><sub>e</sub> cfg&#39;&#39;&quot;</span></span></span><span>        
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f p pa. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594;<span class="hidden">&#8681;</span><sub>e</sub> pa &#8744; (&#8707;c. (&#8707;x. p = (c::(&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com, x)) &#8743; (&#8707;x. pa = (c, x)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>etranE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658;(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com option) &#8658;
                        (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658;
                        (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658;
                        (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                </span><span>xx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658;(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com option) &#8658;
                       (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658;
                       (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; 
                       (&#39;a, &#39;c) xstate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>                </span><span>xxa</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b &#8658;(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com option) &#8658;
                         (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658;
                         (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; (&#39;a, &#39;c) xstate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f p pa. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594;<span class="hidden">&#8681;</span><sub>e</sub> pa &#8744; p = (cc f p pa, xx f p pa) &#8743; pa = (cc f p pa, xxa f p pa)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f c x xa. &#172; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c::(&#39;a, &#39;b, &#39;c,&#39;d) LanguageCon.com, x) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c, xa) &#8744; 
                         (&#8707;a. x = Normal a) &#8744; (&#8704;a. xa &#8800; Normal a) &#8743; x = xa&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>stepe_elim_cases</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c<span class="hidden">&#8681;</span><sub>1</sub>, xxa &#915; cfg<span class="hidden">&#8681;</span><sub>1</sub> cfg&#39;&#39;) = cfg&#39;&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>a1</span><span> </span><span>fst_conv</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, xxa &#915; cfg<span class="hidden">&#8681;</span><sub>1</sub> cfg&#39;&#39;) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (LanguageCon.com.Catch c<span class="hidden">&#8681;</span><sub>1</sub>&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Env</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>a1</span><span> </span><span>e_step</span><span> </span><span>r_into_rtranclp</span><span> </span><span>rtranclp.rtrancl_into_rtrancl</span><span> </span><span>rtranclp_idemp</span><span class="delimiter">)</span><span>              
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594; cfg&#39;&#39;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cc</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; (&#39;a, &#39;c) xstate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p. p = (cc p, xx p)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>old.prod.exhaust</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;c. &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Catch c<span class="hidden">&#8681;</span><sub>1</sub> c, s) &#8594; (LanguageCon.com.Catch (cc cfg&#39;&#39;) c, xx cfg&#39;&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Catchc</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg<span class="hidden">&#8681;</span><sub>1</sub> &#8594; cfg&#39;&#39;`</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Trans.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>c_step</span><span> </span><span>converse_rtranclp_into_rtranclp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_change_p_or_eq_Ns</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,Normal s) &#8594; (Q,s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(P=Q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Q</span><span> </span><span>s</span><span> </span><span>s&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>stepc_Normal_elim_cases</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>step_change_p_or_eq_s</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594; (Q,s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(P=Q)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Q</span><span> </span><span>s</span><span> </span><span>s&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>stepc_elim_cases</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Relation between @{term &quot;stepc_rtrancl&quot;} and @{term &quot;cptn&quot;} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>stepc_rtrancl_cptn</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c,s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (cf,sf)&quot;</span></span></span><span>           
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;xs. (&#915;,(c, s)#xs) &#8712; cptn &#8743;(cf,sf) = (last ((c,s)#xs))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>converse_rtranclp_induct2</span><span> </span><span class="delimiter">[</span><span>case_names</span><span> </span><span>Refl</span><span> </span><span>Trans</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Refl</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn.CptnOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Trans</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>c&#39;</span><span> </span><span>s&#39;</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;) &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Trans.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_ce.simps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>prem</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (c&#39;, s&#39;)&quot;</span></span></span><span>       
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ceqc&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c=c&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prem</span><span> </span><span>env_c_c&#39;</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>           
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c&#39;, s&#39;) # xs) &#8712; cptn &#8743; (cf, sf) = last ((c&#39;, s&#39;) # xs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Trans</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs_f</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c, s)#(c&#39;, s&#39;) # xs) &#8712; cptn&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn.CptnEnv</span><span> </span><span>ceqc&#39;</span><span>  </span><span>prem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((c&#39;, s&#39;) # xs) = last ((c,s)#(c&#39;, s&#39;) # xs)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(cf, sf) = last ((c, s) # (c&#39;, s&#39;) # xs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>   </span><span>xs_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>xs_f</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>prem</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, s) &#8594; (c&#39;, s&#39;)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c&#39;, s&#39;) # xs) &#8712; cptn &#8743; (cf, sf) = last ((c&#39;, s&#39;) # xs) &quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Trans</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c, s) # (c&#39;, s&#39;) # xs) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn.CptnComp</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs_s</span><span> </span><span>prem</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((c&#39;, s&#39;) # xs) = last ((c,s)#(c&#39;, s&#39;) # xs)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_stepc_rtrancl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(c, s)#xs) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>cf_last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(cf,sf) = (last ((c,s)#xs))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c,s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (cf,sf)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_step</span><span> </span><span>cf_last</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>xs</span><span> </span><span>c</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ca</span><span> </span><span>sa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>eq_pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=(ca,sa)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(cf, sf) = last ((ca,sa) # xs) &quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f p pa. &#172; (f::&#39;a &#8658; (&#39;b, _, &#39;c,&#39;d) LanguageCon.com option)&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594; pa &#8744; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> pa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>c_step</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c, s) # (ca, sa) # xs) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(&#915;, (c, s) # a # xs) &#8712; cptn`</span></span></span><span> </span><span>eq_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f p pa. &#172; (f::&#39;a &#8658; (&#39;b, _, &#39;c,&#39;d) LanguageCon.com option)&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594;<span class="hidden">&#8681;</span><sub>e</sub> pa &#8744; f&#8866;<span class="hidden">&#8681;</span><sub>c</sub> p &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> pa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>e_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;c x. (&#915;, (c, x) # xs) &#8713; cptn &#8744; (cf, sf) &#8800; last ((c, x) # xs) &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c, x) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (cf, sf)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(cf, sf) = last ((ca, sa) # xs)`</span></span></span><span> </span><span>converse_rtranclp_into_rtranclp</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>three_elems_list</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length l &gt; 2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;a0 a1 a2 l1. l=a0#a1#a2#l1&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_nth_drop_Suc</span><span> </span><span>One_nat_def</span><span> </span><span>Suc_1</span><span> </span><span>Suc_leI</span><span> </span><span>add_lessD1</span><span> </span><span>drop_0</span><span> </span><span>length_greater_0_conv</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_numeral_le_zero</span><span> </span><span>one_add_one</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_stepc_rtran</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#xs) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>          
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Suc i &lt; length (x#xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((x#xs)!i) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> ((x#xs)!(Suc i))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_step</span><span> </span><span>a1</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>i</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x1</span><span> </span><span>xs1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs=x1#xs1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>length_Cons</span><span> </span><span>less_not_refl</span><span> </span><span>list.exhaust</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(x#x1#xs1)!Suc 0 = x1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x_x1_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#x1#xs1)&#8712;cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>0</span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x1#xs1)&#8712;cptn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_dest_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>x &#8594;<span class="hidden">&#8681;</span><sub>e</sub> x1 &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>x &#8594; x1&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_elim_cases_pair</span><span> </span><span>x_x1_cptn</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> x &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> x1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>c_step</span><span> </span><span>e_step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc i &lt; length xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x1</span><span> </span><span>xs1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs=x1#xs1&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>list.exhaust</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_less0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x1#xs1) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>cptn_dest_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((x1 # xs1) ! i) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> ((x1 # xs1) ! Suc i)&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>     
</span><span>      
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_stepconf_rtrancl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfg1#xs) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>cf_last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg2 = (last (cfg1#xs))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg1 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> cfg2&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_step</span><span> </span><span>cf_last</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cptn_stepc_rtrancl</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_all_steps_rtrancl</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfg1#xs) &#8712; cptn&quot;</span></span></span><span>          
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length (cfg1#xs). &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg1 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> ((cfg1#xs)!i)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_step</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>cfg1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length (x # xs1). &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> x &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> ((x # xs1) ! i)&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span> </span><span>cptn_dest_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length (cfg1 # x # xs1)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc 0 &lt; length (cfg1 # x # xs1)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (cfg1 # x # xs1) ! 0 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> ((cfg1 # x # xs1) ! Suc 0)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span>cptn_stepc_rtran</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg1 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; Suc (Suc (length xs1))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg1 &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (cfg1 # x # xs1) ! i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span> </span><span>Cons</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>converse_rtranclp_into_rtranclp</span><span> </span><span>hyp</span><span> </span><span>less_Suc_eq_0_disj</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_env_same_prog</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, l) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;k &lt; j. (&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(l!k)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (l!(Suc k)))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc j &lt; length l&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (l!j) =  fst (l!0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>j</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>l</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>j</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (l!j) =  fst (l!0)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>env_c_c&#39;</span><span> </span><span>lessI</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>takecptn_is_cptn</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j. (&#915;,c) &#8712; cptn &#10230; (&#915;, take (Suc j) c) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>cptn.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CptnOne</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>cptn.intros</span><span> </span><span>elim</span><span class="delimiter">:</span><span>cptn.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dropcptn_is_cptn</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&lt;length c. (&#915;,c) &#8712; cptn &#10230; (&#915;, drop j c) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>cptn.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>cptn.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>takepar_cptn_is_par_cptn</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>elim</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j. (&#915;,c) &#8712; par_cptn &#10230; (&#915;,take (Suc j) c) &#8712; par_cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>cptn.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>ParCptnOne</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>par_cptn.intros</span><span> </span><span>elim</span><span class="delimiter">:</span><span>par_cptn.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>droppar_cptn_is_par_cptn</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&lt;length c. (&#915;,c) &#8712; par_cptn &#10230; (&#915;,drop j c) &#8712; par_cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>par_cptn.cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>par_cptn.cases</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>force</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Modular Definition of Computation&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lift</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) config &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) config&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lift Q &#8801; &#955;(P, s).  ((Seq P Q), s)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>lift_catch</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) config &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) config&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lift_catch Q &#8801; &#955;(P, s).  (Catch P Q, s)&quot;</span></span></span><span>     
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>cptn_mod</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;s,&#39;p,&#39;f,&#39;e) confs) set&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>CptnModOne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,[(P, s)]) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModEnv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P,t);(&#915;,(P, t)#xs) &#8712; cptn_mod &#10215; &#10233; 
               (&#915;,(P, s)#(P, t)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModSkip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Skip,t); redex P = P;
                (&#915;,(Skip, t)#xs) &#8712; cptn_mod &#10215; &#10233; 
                (&#915;,(P,s)#(Skip, t)#xs) &#8712;cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModThrow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Throw,t); redex P = P;
                (&#915;,(Throw, t)#xs) &#8712; cptn_mod &#10215; &#10233; 
                (&#915;,(P,s)#(Throw, t)#xs) &#8712;cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModCondT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;,(P0, Normal s)#ys) &#8712; cptn_mod; s &#8712; b &#10215; &#10233; 
                (&#915;,((Cond b P0 P1), Normal s)#(P0, Normal s)#ys) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModCondF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;,(P1, Normal s)#ys) &#8712; cptn_mod; s &#8713; b &#10215; &#10233; 
                (&#915;,((Cond b P0 P1), Normal s)#(P1, Normal s)#ys) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModSeq1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;,(P0, s)#xs) &#8712; cptn_mod; zs=map (lift P1) xs &#10215; &#10233; 
   (&#915;,((Seq P0 P1), s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModSeq2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;, (P0, s)#xs) &#8712; cptn_mod; fst(last ((P0, s)#xs)) = Skip;
    (&#915;,(P1, snd(last ((P0, s)#xs)))#ys) &#8712; cptn_mod;
    zs=(map (lift P1) xs)@((P1, snd(last ((P0, s)#xs)))#ys) &#10215; &#10233; 
   (&#915;,((Seq P0 P1), s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*| CptnModSeq3:
  &quot;&#10214; (&#915;,(P1, s)#xs) &#8712; cptn_mod&#10215; &#10233; (&#915;,((Seq Skip P1), s)#(P1, s)#xs) &#8712; cptn_mod&quot;*)</span></span></span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModSeq3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;, (P0, Normal s)#xs) &#8712; cptn_mod; 
    fst(last ((P0, Normal s)#xs)) = Throw;
    snd(last ((P0, Normal s)#xs)) = Normal s&#39;; 
    (&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod; 
    zs=(map (lift P1) xs)@((Throw,Normal s&#39;)#ys) &#10215; &#10233;
   (&#915;,((Seq P0 P1), Normal s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModWhile1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;, (P, Normal s)#xs) &#8712; cptn_mod; s &#8712; b; 
    zs=map (lift (While b P)) xs &#10215; &#10233; 
    (&#915;, ((While b P), Normal s)#
      ((Seq P (While b P)),Normal s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModWhile2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (&#915;, (P, Normal s)#xs) &#8712; cptn_mod; 
     fst(last ((P, Normal s)#xs))=Skip; s &#8712; b; 
     zs=(map (lift (While b P)) xs)@
      (While b P, snd(last ((P, Normal s)#xs)))#ys; 
      (&#915;,(While b P, snd(last ((P, Normal s)#xs)))#ys) &#8712; 
        cptn_mod&#10215; &#10233; 
   (&#915;,(While b P, Normal s)#
     (Seq P (While b P), Normal s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModWhile3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (&#915;, (P, Normal s)#xs) &#8712; cptn_mod; 
     fst(last ((P, Normal s)#xs))=Throw; s &#8712; b;
     snd(last ((P, Normal s)#xs)) = Normal s&#39;; 
    (&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod;  
     zs=(map (lift (While b P)) xs)@((Throw,Normal s&#39;)#ys)&#10215; &#10233; 
   (&#915;,(While b P, Normal s)#
     (Seq P (While b P), Normal s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModCall</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;,(bdy, Normal s)#ys) &#8712; cptn_mod;&#915; p = Some bdy; bdy&#8800;Call p &#10215; &#10233; 
                (&#915;,((Call p), Normal s)#(bdy, Normal s)#ys) &#8712; cptn_mod&quot;</span></span></span><span> 
</span><span class="delimiter">|</span><span> </span><span>CptnModDynCom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;,(c s, Normal s)#ys) &#8712; cptn_mod &#10215; &#10233; 
                  (&#915;,(DynCom c, Normal s)#(c s, Normal s)#ys) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModGuard</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;,(c, Normal s)#ys) &#8712; cptn_mod; s &#8712; g &#10215; &#10233; 
                 (&#915;,(Guard f g c, Normal s)#(c, Normal s)#ys) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModCatch1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;,(P0, s)#xs) &#8712; cptn_mod; zs=map (lift_catch P1) xs &#10215;
                 &#10233; (&#915;,((Catch P0 P1), s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModCatch2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;, (P0, s)#xs) &#8712; cptn_mod; fst(last ((P0, s)#xs)) = Skip; 
    (&#915;,(Skip,snd(last ((P0, s)#xs)))#ys) &#8712; cptn_mod;  
    zs=(map (lift_catch P1) xs)@((Skip,snd(last ((P0, s)#xs)))#ys) &#10215; &#10233; 
   (&#915;,((Catch P0 P1), s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModCatch3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(&#915;, (P0, Normal s)#xs) &#8712; cptn_mod; fst(last ((P0, Normal s)#xs)) = Throw; 
  snd(last ((P0, Normal s)#xs)) = Normal s&#39;;
  (&#915;,(P1, snd(last ((P0, Normal s)#xs)))#ys) &#8712; cptn_mod; 
  zs=(map (lift_catch P1) xs)@((P1, snd(last ((P0, Normal s)#xs)))#ys) &#10215; &#10233; 
   (&#915;,((Catch P0 P1), Normal s)#zs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>CptnMod_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>cptn_mod.induct</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(c,s)]&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>split_format</span><span> </span><span class="delimiter">(</span><span>complete</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>case_names</span><span>
</span><span>CptnModOne</span><span> </span><span>CptnModEnv</span><span> </span><span>CptnModSkip</span><span> </span><span>CptnModThrow</span><span> </span><span>CptnModCondT</span><span> </span><span>CptnModCondF</span><span> 
</span><span>CptnModSeq1</span><span> </span><span>CptnModSeq2</span><span> </span><span>CptnModSeq3</span><span> </span><span>CptnModSeq4</span><span> </span><span>CptnModWhile1</span><span> </span><span>CptnModWhile2</span><span> </span><span>CptnModWhile3</span><span> </span><span>CptnModCall</span><span> </span><span>CptnModDynCom</span><span> </span><span>CptnModGuard</span><span> 
</span><span>CptnModCatch1</span><span> </span><span>CptnModCatch2</span><span> </span><span>CptnModCatch3</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>set</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>CptnMod_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Skip, s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Guard f g c, s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Basic f e, s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Spec r e, s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Seq c1 c2, s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Cond b c1 c2, s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Await b c2 e, s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Call p, s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(DynCom c,s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Throw,s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Catch c1 c2,s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>CptnMod_Normal_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Skip, Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Guard f g c, Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Basic f e, Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Spec r e, Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Seq c1 c2, Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Cond b c1 c2, Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Await b c2 e, Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Call p, Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(DynCom c,Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Throw,Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Catch c1 c2,Normal s)#u#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,Normal s)#(P,s&#39;)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,Abrupt s)#(P,Abrupt s&#39;)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,Stuck)#(P,Stuck)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,Fault f)#(P,Fault f)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>CptnMod_env_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,Normal s)#(P,s&#39;)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,Abrupt s)#(P,Abrupt s&#39;)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,Stuck)#(P,Stuck)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,Fault f)#(P,Fault f)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Equivalence of small semantics and computational&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_length</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((a#xs)!(length xs))=last (a#xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>catch_cond</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond zs Q xs P s s&#39;&#39; s&#39; &#915; &#8801; (zs=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, s)#xs)) = Normal s&#39; &#8743; s=Normal s&#39;&#39;&#8743;
               (&#8707;ys. (&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod &#8743; 
                zs=(map (lift_catch Q) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
                 (&#8707;ys. (&#915;,(Skip,snd(last ((P, s)#xs)))#ys) &#8712; cptn_mod &#8743;                   
                 zs=(map (lift_catch Q) xs)@((Skip,snd(last ((P, s)#xs)))#ys)))))
&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_catch</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,list) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. list=(Catch P Q, s)#zs &#10230;
       (&#8707;xs s&#39; s&#39;&#39;. 
          (&#915;,(P, s)#xs) &#8712; cptn_mod  &#8743; 
             catch_cond zs Q xs P s s&#39;&#39; s&#39; &#915;))  
            &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>catch_cond_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_m</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cptn_mod.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModOne</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod.CptnModOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSkip</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Skip, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noskip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~(P=Skip)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p1 p2. &#172;(P=Catch p1 p2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModSkip.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>redex_not_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_cptn_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Skip, t) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModThrow</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModThrow.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Throw, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModThrow.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_cptn_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Throw, t) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p1 p2. &#172;(P=Catch p1 p2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModThrow.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>redex_not_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCondT</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCondF</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCatch1</span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCatch2</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModCatch2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = Skip&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P0, s) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch P1) xs @((Skip,snd(last ((P0, s)#xs)))#ys)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModCatch2.hyps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch P0 P1, s) # zs = (Catch P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P0 =P &#8743; P1 = Q &#8743; s=sa &#8743; zs=zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P0, s) = (P, sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, s) # xs) = ((P, sa) # xs) ! length xs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = (map (lift_catch Q) xs)@((Skip,snd(last ((P0, s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift_catch P1) xs @ ((Skip,snd(last ((P0, s)#xs)))#ys)`</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39; s&#39;&#39;. ((&#915;,(P, s)#xs) &#8712; cptn_mod  &#8743; 
             ((zs=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, s)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
               (&#8707;ys. (&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod &#8743; 
                zs=(map (lift_catch Q) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                (&#8707;ys. ((fst(((P, s)#xs)!length xs)=Skip &#8743; (&#915;,(Skip,snd(last ((P, s)#xs)))#ys) &#8712; cptn_mod &#8743;                 
                 zs=(map (lift_catch Q) xs)@((Skip,snd(last ((P0, s)#xs)))#ys))))))))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P0cptn</span><span>  </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span>  </span><span>last</span><span>  </span><span>CptnModCatch2.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCatch3</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModCatch3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, Normal s) # xs) ! length xs) = Throw&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModCatch3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastnormal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P0, Normal s) # xs)) = Normal s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P0, Normal s) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModCatch3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P1cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P1, snd (((P0, Normal s) # xs) ! length xs)) # ys) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch P1) xs @ (P1, snd (last ((P0, Normal s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModCatch3.hyps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch P0 P1, Normal s) # zs = (Catch P Q, Normal sa) # zsa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P0 =P &#8743; P1 = Q &#8743; Normal s= Normal sa &#8743; zs=zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, Normal s) # xs) = ((P, Normal sa) # xs) ! length xs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zsa = map (lift_catch Q) xs @ (Q, snd (((P, Normal sa) # xs) ! length xs)) # ys&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift_catch P1) xs @ (P1, snd (last ((P0, Normal s) # xs))) # ys`</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P, Normal s) # xs) &#8712; cptn_mod &#8743; (fst(((P, Normal s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, Normal s)#xs)) = Normal s&#39; &#8743; 
              (&#8707;ys. (&#915;,(Q, snd(((P, Normal s)#xs)!length xs))#ys) &#8712; cptn_mod &#8743; 
              zs=(map (lift_catch Q) xs)@((Q, snd(((P, Normal s)#xs)!length xs))#ys)))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lastnormal</span><span> </span><span>P1cptn</span><span> </span><span>P0cptn</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span>last</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span>zs</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModEnv</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P, t) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catch</span><span> </span><span>P1</span><span> </span><span>P2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_P_Catch</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) # xs = (LanguageCon.com.Catch P1 P2, t) # xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xsa</span><span> </span><span>t&#39;</span><span> </span><span>t&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P1, t) # xsa) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;
     (xs = map (lift_catch P2) xsa &#8744;
      fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Throw &#8743;
      snd (last ((P1, t) # xsa)) = Normal t&#39; &#8743;
      t = Normal t&#39;&#39; &#8743;
      (&#8707;ys. (&#915;, (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8712; cptn_mod &#8743;
            xs =
            map (lift_catch P2) xsa @
            (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8744;
            fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Skip &#8743;
            (&#8707;ys.(&#915;,(Skip,snd(last ((P1, t)#xsa)))#ys) &#8712; cptn_mod &#8743; 
            xs = map (lift_catch P2) xsa @
            ((LanguageCon.com.Skip, snd (last ((P1, t) # xsa)))#ys)))&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModEnv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P1, s)#((P1, t) # xsa)) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>p1</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span> </span><span>cptn_mod.CptnModEnv</span><span> </span><span>env_normal_s</span><span> </span><span>step_e</span><span class="delimiter">)</span><span>       
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>  
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift_catch P2) xsa&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) # xs = map (lift_catch P2) ((P1, t) # xsa)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`xs = map (lift_catch P2) xsa`</span></span></span><span> </span><span>lift_catch_def</span><span> </span><span>local.Catch</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_step</span><span> </span><span>eq_P_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Throw &#8743;
          snd (last ((P1, t) # xsa)) = Normal t&#39; &#8743;
          t = Normal t&#39;&#39; &#8743;
          (&#8707;ys. (&#915;, (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8712; cptn_mod &#8743;
                xs =
                map (lift_catch P2) xsa @
                (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8744;
                fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Skip &#8743;
           (&#8707;ys. (&#915;,(Skip,snd(last ((P1, t)#xsa)))#ys) &#8712; cptn_mod &#8743; 
            xs = map (lift_catch P2) xsa @
            ((LanguageCon.com.Skip, snd (last ((P1, t) # xsa)))#ys))&quot;</span></span></span><span>      
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>            </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Throw &#8743;
             snd (last ((P1, t) # xsa)) = Normal t&#39; &#8743;
             t = Normal t&#39;&#39; &#8743;
             (&#8707;ys. (&#915;, (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8712; cptn_mod &#8743;
                xs = map (lift_catch P2) xsa @
                       (P2, snd (((P1, t) # xsa) ! length xsa)) # ys)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p2_exec</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8712; cptn_mod &#8743;
                xs = map (lift_catch P2) xsa @
                       (P2, snd (((P1, t) # xsa) ! length xsa)) # ys&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal t1&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>env_normal_s&#39;_normal_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, s)#(P1, t) # xsa) ! length ((P1, t)#xsa)) = LanguageCon.com.Throw&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>             </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P1, s)#(P1, t) # xsa)) = Normal t&#39;&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2_long_exec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P2, snd (((P1, s)#(P1, t) # xsa) ! length ((P1, s)#xsa))) # ys) &#8712; cptn_mod &#8743;
                (P, t)#xs = map (lift_catch P2) ((P1, t) # xsa) @
                       (P2, snd (((P1, s)#(P1, t) # xsa) ! length ((P1, s)#xsa))) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2_exec</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span> </span><span>local.Catch</span><span class="delimiter">)</span><span>                  
</span><span>             </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a1</span><span> </span><span>f1</span><span> </span><span>last_normal</span><span> </span><span>all_step</span><span> </span><span>eq_P_Catch</span><span> 
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>not_step_c_env</span><span>  </span><span>step_e</span><span class="delimiter">)</span><span>            
</span><span>           </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>            </span><span>as1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Skip &#8743;
           (&#8707;ys. (&#915;,(Skip,snd(last ((P1, t)#xsa)))#ys) &#8712; cptn_mod &#8743; 
            xs = map (lift_catch P2) xsa @
            ((LanguageCon.com.Skip, snd (last ((P1, t) # xsa)))#ys))&quot;</span></span></span><span>               
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Skip,snd(last ((P1, t)#xsa)))#ys) &#8712; cptn_mod &#8743; 
                         (P, t)#xs = map (lift_catch P2) ((P1, t) # xsa) @
                          ((LanguageCon.com.Skip, snd (last ((P1, t) # xsa)))#ys)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;ys. (&#915;, (LanguageCon.com.Skip, snd (last ((P1, t) # xsa))) # ys) &#8712; cptn_mod &#8743; (P, t) # xs = map (lift_catch P2) ((P1, t) # xsa) @ (LanguageCon.com.Skip, snd (last ((P1, t) # xsa))) # ys &#10233; thesis&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Catch P1 P2, t) # map (lift_catch P2) xsa = map (lift_catch P2) ((P1, t) # xsa)&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>as1</span><span> </span><span>eq_P_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>            
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>as1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, s)#(P1, t) # xsa) ! length ((P1, t) #xsa)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>                 </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>                              
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p1</span><span> </span><span>all_step</span><span> </span><span>eq_P_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>seq_cond</span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond zs Q xs P s s&#39;&#39; s&#39; &#915; &#8801; (zs=(map (lift Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
               (&#8707;ys. (&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod &#8743; 
                zs=(map (lift (Q)) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743; 
                 snd(last ((P, s)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
                 (&#8707;ys.  (&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod &#8743;
                      zs=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys)))))
&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_seq</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,list) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. list=(Seq P Q, s)#zs &#10230;
       (&#8707;xs s&#39; s&#39;&#39;. 
          (&#915;,(P, s)#xs) &#8712; cptn_mod  &#8743; 
             seq_cond zs Q xs P s s&#39;&#39; s&#39; &#915;))  
            &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_m</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cptn_mod.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModOne</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod.CptnModOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSkip</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Skip, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noskip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~(P=Skip)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;c c1 c2. redex c = Seq c1 c2 &#10233; False&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>redex_not_Seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_cptn_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Skip, t) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModSkip.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex_not_Seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModThrow</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModThrow.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Throw, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModThrow.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_cptn_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Throw, t) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p1 p2. &#172;(P=Seq p1 p2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModThrow.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>redex_not_Seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCondT</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCondF</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSeq1</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSeq2</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSeq2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>last_length</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = Skip&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P0, s) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSeq2.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P1cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModSeq2.hyps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq P0 P1, s) # zs = (Seq P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P0 =P &#8743; P1 = Q &#8743; s=sa &#8743; zs=zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, s) # xs) = ((P, sa) # xs) ! length xs&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys`</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39; s&#39;&#39;. (&#915;, (P, sa) # xs) &#8712; cptn_mod &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P, sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (&#915;, (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8712; cptn_mod &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, sa)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
                         (&#8707;ys. (&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod &#8743;
                               zsa=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))))))
               &quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P0cptn</span><span> </span><span>P1cptn</span><span>  </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span>last</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                 
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span>  
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>     
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSeq3</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSeq3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, Normal s) # xs) ! length xs) = Throw&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P0, Normal s) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModSeq3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastnormal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P0, Normal s) # xs)) = Normal s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift P1) xs @ ((Throw, Normal s&#39;)#ys)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModSeq3.hyps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq P0 P1, Normal s) # zs = (Seq P Q, Normal sa) # zsa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P0 =P &#8743; P1 = Q &#8743; Normal s=Normal sa &#8743; zs=zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P0, Normal s) = (P, Normal sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, Normal s) # xs) = ((P, Normal sa) # xs) ! length xs&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zsa</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zsa = (map (lift Q) xs)@((Throw,Normal s&#39;)#ys)&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift P1) xs @ ((Throw, Normal s&#39;)#ys)`</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModSeq3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>               
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, Normal sa::(&#39;b, &#39;c) xstate) = (P0, Normal s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39;. (&#915;, (P, Normal sa) # xs) &#8712; cptn_mod &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P,Normal sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (&#915;, (Q, snd (((P, Normal sa) # xs) ! length xs)) # ys) &#8712; cptn_mod &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, Normal sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, Normal sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, Normal sa)#xs)) = Normal s&#39; &#8743;
                          (&#8707;ys. (&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod &#8743;
                          zsa=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))))))&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P0cptn</span><span> </span><span>zsa</span><span> </span><span>a1</span><span> </span><span>last</span><span> </span><span>lastnormal</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span>  
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModEnv</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P, t) # zs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>P1</span><span> </span><span>P2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) # zs = (LanguageCon.com.Seq P1 P2, t) # zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>t&#39;</span><span> </span><span>t&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P1, t) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;
     (zs = map (lift P2) xs &#8744;
      fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Skip &#8743;      
      (&#8707;ys. (&#915;, (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8712; cptn_mod &#8743;
            zs =
            map (lift P2) xs @
            (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8744;
      fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
      snd (last ((P1, t) # xs)) = Normal t&#39; &#8743;
      t = Normal t&#39;&#39; &#8743; (&#8707;ys. (&#915;,(Throw,Normal t&#39;)#ys) &#8712; cptn_mod &#8743; 
      zs =
      map (lift P2) xs @
      ((LanguageCon.com.Throw, Normal t&#39;)#ys))) &quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModEnv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P1, s)#((P1, t) # xs)) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>p1</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span> </span><span>cptn_mod.CptnModEnv</span><span> </span><span>env_normal_s</span><span> </span><span>step_e</span><span class="delimiter">)</span><span>         
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>  
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift P2) xs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) # zs = map (lift P2) ((P1, t) # xs)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift P2) xs`</span></span></span><span> </span><span>lift_def</span><span> </span><span>local.Seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_step</span><span> </span><span>eq_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Skip &#8743;      
         (&#8707;ys. (&#915;, (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8712; cptn_mod &#8743;
            zs = map (lift P2) xs @ (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8744;
          fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
           snd (last ((P1, t) # xs)) = Normal t&#39; &#8743;
           t = Normal t&#39;&#39; &#8743; (&#8707;ys. (&#915;,(Throw,Normal t&#39;)#ys) &#8712; cptn_mod &#8743; 
           zs = map (lift P2) xs @ ((LanguageCon.com.Throw, Normal t&#39;)#ys))&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>            </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Skip &#8743;      
               (&#8707;ys. (&#915;, (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8712; cptn_mod &#8743;
               zs = map (lift P2) xs @ (P2, snd (((P1, t) # xs) ! length xs)) # ys)&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                   </span><span>p2_exec</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8712; cptn_mod &#8743;
                       zs = map (lift P2) xs @
                       (P2, snd (((P1, t) # xs) ! length xs)) # ys&quot;</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>               </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, s)#(P1, t) # xs) ! length ((P1, t)#xs)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>             
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2_long_exec</span><span class="delimiter">:</span><span> 
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P2, snd (((P1, s)#(P1, t) # xs) ! length ((P1, t)#xs))) # ys) &#8712; cptn_mod &#8743;
                  (P, t)#zs = map (lift P2) ((P1, t) # xs) @
                       (P2, snd (((P1, s)#(P1, t) # xs) ! length ((P1, t)#xs))) # ys&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2_exec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_def</span><span> </span><span>local.Seq</span><span class="delimiter">)</span><span>     
</span><span>             </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>f1</span><span> </span><span>all_step</span><span> </span><span>eq_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>            
</span><span>           </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>            </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
            snd (last ((P1, t) # xs)) = Normal t&#39; &#8743; t = Normal t&#39;&#39; &#8743; 
          (&#8707;ys. (&#915;,(Throw,Normal t&#39;)#ys) &#8712; cptn_mod &#8743; 
           zs = map (lift P2) xs @ ((LanguageCon.com.Throw, Normal t&#39;)#ys))&quot;</span></span></span><span>             
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_throw</span><span class="delimiter">:</span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, s)#(P1, t) # xs) ! length ((P1, t) #xs)) = LanguageCon.com.Throw&quot;</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>             </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P1, s)#(P1, t) # xs)) = Normal t&#39;&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>             </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seq_lift</span><span class="delimiter">:</span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq P1 P2, t) # map (lift P2) xs = map (lift P2) ((P1, t) # xs)&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a1</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>             
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>last_throw</span><span> </span><span>last_normal</span><span> </span><span>all_step</span><span> </span><span>eq_P</span><span>         
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>append_Cons</span><span> </span><span>env_normal_s&#39;_normal_s</span><span>  </span><span>step_e</span><span class="delimiter">)</span><span>                 
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_onlyif_cptn_mod_aux</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>stepseq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Q,t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>stepmod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Q,t)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(P,s)#(Q,t)#xs) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepseq</span><span> </span><span>stepmod</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Basicc</span><span> </span><span>f</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.Basicc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Specc</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.Specc</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SpecStuckc</span><span> </span><span>s</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.SpecStuckc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Guardc</span><span> </span><span>s</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModGuard</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>GuardFaultc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.GuardFaultc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seqc</span><span> </span><span>c1</span><span> </span><span>s</span><span> </span><span>c1&#39;</span><span> </span><span>s&#39;</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c1, s) &#8594; (c1&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nsc1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c1&#8800;Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq c1&#39; c2, s&#39;) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divseq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Seq c1&#39; c2, s&#39;) # xs=(Seq P Q, s)#zs &#10230;
                (&#8707;xs sv&#39; sv&#39;&#39;. ((&#915;,(P, s)#xs) &#8712; cptn_mod  &#8743; 
                           (zs=(map (lift Q) xs) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
                             (&#8707;ys. (&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod &#8743; 
                              zs=(map (lift (Q)) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Throw &#8743; 
                               snd(last ((P, s)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
                             (&#8707;ys.  (&#915;,(Throw,Normal sv&#39;)#ys) &#8712; cptn_mod &#8743;
                              zs=(map (lift Q) xs)@((Throw,Normal sv&#39;)#ys))
                               ))))
                            
                 ))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assum</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;) # xs = (Seq P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c1&#39; = P &#8743; c2 = Q &#8743; s&#39; = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs sv&#39; sv&#39;&#39;. (&#915;, (P, sa) # xs) &#8712; cptn_mod &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P, sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (&#915;, (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8712; cptn_mod &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, sa)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
                          (&#8707;ys.  (&#915;,(Throw,Normal sv&#39;)#ys) &#8712; cptn_mod &#8743;
                              zsa=(map (lift Q) xs)@((Throw,Normal sv&#39;)#ys))))))&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divseq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c1&#39;</span><span> </span><span>c2</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span class="delimiter">]</span><span>    
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>sa&#39;</span><span> </span><span>sa&#39;&#39;</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>split</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod &#8743;
                     (xs = map (lift c2) xs&#39; &#8744;                   
                     fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                        (&#8707;ys. (&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                         xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
                     ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                         snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743; s&#39;=Normal sa&#39;&#39;&#8743;
                         (&#8707;ys.  (&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod &#8743;
                              xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))
                         )))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift c2) xs&#39; &#8744;                   
                     fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                        (&#8707;ys. (&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                         xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
                     ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                         snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743; s&#39;=Normal sa&#39;&#39;&#8743;
                         (&#8707;ys.  (&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod &#8743;
                              xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys)))))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span>           
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c1&#39;nonf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift c2) xs&#39;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;)#xs = map (lift c2) ((c1&#39;, s&#39;)#xs&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModSeq1</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModSeq1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
              (&#8707;ys. (&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                  xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
             ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743;  s&#39;=Normal sa&#39;&#39;&#8743;
                (&#8707;ys.  (&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod &#8743;
                              xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assth</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
              (&#8707;ys. (&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                  xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>             </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                  xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1 c2, s)#(Seq c1&#39; c2, s&#39;)#xs = map (lift c2) ((c1,s)#(c1&#39;, s&#39;)#xs&#39;) @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split&#39;</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModSeq2</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Skip&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>          
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seqmap</span><span> </span><span>split&#39;</span><span> </span><span>last_length</span><span> </span><span>cptn_mod.CptnModSeq2</span><span> 
</span><span>                 </span><span>induct_step</span><span> </span><span>lastc1</span><span> </span><span>lastc1skip</span><span> 
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743;  s&#39;=Normal sa&#39;&#39;&#8743;
                (&#8707;ys.  (&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod &#8743;
                 xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Normal sa&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snormal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ns. s=Normal ns&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_Abrupt_prop</span><span> </span><span>step_Fault_prop</span><span> </span><span>step_Stuck_prop</span><span> </span><span>xstate.exhaust</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;)#xs = (map (lift c2) ((c1&#39;, s&#39;)#xs&#39;))@((Throw,Normal sa&#39;)#ys)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;ys. (LanguageCon.com.Seq c1&#39; c2, s&#39;) # xs = map (lift c2) ((c1&#39;, s&#39;) # xs&#39;) @ (LanguageCon.com.Throw, Normal sa&#39;) # ys &#10233; thesis&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq c1&#39; c2, Normal sa&#39;&#39;) # map (lift c2) xs&#39; = map (lift c2) ((c1&#39;, s&#39;) # xs&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assm</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>                   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Throw&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>        
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span>lastc1skip</span><span> </span><span>snormal</span><span> </span><span>seqmap</span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cptn_mod.CptnModSeq3</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>          
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SeqSkipc</span><span> </span><span>c2</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2incptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c2, s) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(Skip, s)]) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ([(Skip, s)])) = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(c2, snd(last [(Skip, s)]))#xs) &#8712; cptn_mod&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c2incptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2,s)#xs=(map (lift c2) [])@(c2, snd(last [(Skip, s)]))#xs&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModSeq2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SeqThrowc</span><span> </span><span>c2</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(Throw, Normal s)]) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModOne</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ys_nil</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;ys=[]&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Throw, Normal s)#ys)&#8712; cptn_mod&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Throw, Normal s)#ys)) = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Throw, Normal s)#ys)) = Normal s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ys_nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (lift c2) ys) = []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SeqThrowc.prems</span><span> </span><span>cptn_mod.CptnModSeq3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CondTruec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModCondT</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CondFalsec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModCondF</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WhileTruec</span><span> </span><span>s1</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sinb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s1&#8712;b&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SeqcWhile</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq c (While b c), Normal s1) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>  
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divseq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Seq c (While b c), Normal s1) # xs=(Seq P Q, s)#zs &#10230;
                (&#8707;xs s&#39;. ((&#915;,(P, s)#xs) &#8712; cptn_mod  &#8743; 
                           (zs=(map (lift Q) xs) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
                             (&#8707;ys. (&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod &#8743; 
                              zs=(map (lift (Q)) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Throw &#8743; 
                               snd(last ((P, s)#xs)) = Normal s&#39; &#8743;
                              (&#8707;ys.  (&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod &#8743;
                      zs=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))))))                            
                 ))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>SeqcWhile</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_cond_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c (While b c), Normal s1) # xs = (Seq P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c = P &#8743; (While b c) = Q &#8743; Normal s1 = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39;. (&#915;, (P, sa) # xs) &#8712; cptn_mod &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P, sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (&#915;, (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8712; cptn_mod &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, sa)#xs)) = Normal s&#39; &#8743;
                          (&#8707;ys.  (&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod &#8743;
                      zsa=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))
                        ))))&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divseq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;While b c&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Normal s1&quot;</span></span></span><span> </span><span>xs</span><span class="delimiter">]</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>split</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod &#8743;
     (xs = map (lift (While b c)) xs&#39; &#8744;
      fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
      (&#8707;ys. (&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
            &#8712; cptn_mod &#8743;
            xs =
            map (lift (While b c)) xs&#39; @
            (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
      fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
      snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743; 
      (&#8707;ys.  (&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod &#8743;
      xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys)))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift (While b c)) xs&#39; &#8744;
            fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
            (&#8707;ys. (&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
                  &#8712; cptn_mod &#8743;
                  xs =
                  map (lift (While b c)) xs&#39; @
                  (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
            fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
            snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
            (&#8707;ys.  (&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift (While b c)) xs&#39;&quot;</span></span></span><span>  
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1&quot;</span></span></span><span> </span><span>cptn_mod.CptnModWhile1</span><span> </span><span>sinb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
                &#8712; cptn_mod &#8743;
                xs =
                map (lift (While b c)) xs&#39; @
                (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
          (&#8707;ys.  (&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
             (&#8707;ys. (&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
             &#8712; cptn_mod &#8743;
             xs =
             map (lift (While b c)) xs&#39; @
             (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>asm&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (While b c, snd (last ((c, Normal s1) # xs&#39;))) # ys)
                   &#8712; cptn_mod 
                   &#8743; xs = map (lift (While b c)) xs&#39; @
                       (While b c, snd (last ((c, Normal s1) # xs&#39;))) # ys&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c, Normal s1) # xs&#39;))  = Skip&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sinb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModWhile2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
          (&#8707;ys.  (&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys))&quot;</span></span></span><span>   
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c, Normal s1) # xs&#39;))  = Throw&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sinb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModWhile3</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WhileFalsec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.WhileFalsec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Awaitc</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.Awaitc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>AwaitAbruptc</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>t</span><span> </span><span>t&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModThrow</span><span> </span><span>stepc.AwaitAbruptc</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Callc</span><span> </span><span>p</span><span> </span><span>bdy</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModCall</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CallUndefinedc</span><span> </span><span>p</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.CallUndefinedc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>DynComc</span><span> </span><span>c</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModDynCom</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catchc</span><span> </span><span>c1</span><span> </span><span>s</span><span> </span><span>c1&#39;</span><span> </span><span>s&#39;</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c1, s) &#8594; (c1&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nsc1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c1&#8800;Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Catch c1&#39; c2, s&#39;) # xs) &#8712; cptn_mod&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divcatch</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Catch c1&#39; c2, s&#39;) # xs=(Catch P Q, s)#zs &#10230;
  (&#8707;xs s&#39; s&#39;&#39;. ((&#915;,(P, s)#xs) &#8712; cptn_mod  &#8743; 
             (zs=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, s)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
               (&#8707;ys. (&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod &#8743; 
                zs=(map (lift_catch Q) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                ((fst(((P, s)#xs)!length xs)=Skip &#8743;  
                  (&#8707;ys. (&#915;,(Skip,snd(last ((P, s)#xs)))#ys) &#8712; cptn_mod &#8743;                   
                 zs=(map (lift_catch Q) xs)@((Skip,snd(last ((P, s)#xs)))#ys))                
                 ))))
   ))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_catch</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assum</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>catch_cond_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;) # xs = (Catch P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c1&#39; = P &#8743; c2 = Q &#8743; s&#39; = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs sv&#39; sv&#39;&#39;. ((&#915;,(P, sa)#xs) &#8712; cptn_mod  &#8743; 
             (zsa=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, sa)#xs)!length xs)=Throw &#8743;
               snd(last ((P, sa)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
               (&#8707;ys. (&#915;,(Q, snd(((P, sa)#xs)!length xs))#ys) &#8712; cptn_mod &#8743; 
                zsa=(map (lift_catch Q) xs)@((Q, snd(((P, sa)#xs)!length xs))#ys)))) &#8744;
                ((fst(((P, sa)#xs)!length xs)=Skip &#8743;                  
                 (&#8707;ys. (&#915;,(Skip,snd(last ((P, sa)#xs)))#ys) &#8712; cptn_mod &#8743;                   
                 zsa=(map (lift_catch Q) xs)@((Skip,snd(last ((P, sa)#xs)))#ys))))))
   )&quot;</span></span></span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divcatch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c1&#39;</span><span> </span><span>c2</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span class="delimiter">]</span><span>    
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>sa&#39;</span><span> </span><span>sa&#39;&#39;</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod &#8743; 
          (xs = map (lift_catch c2) xs&#39; &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
          (&#8707;ys. (&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                xs = map (lift_catch c2) xs&#39; @
                (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)))&quot;</span></span></span><span>          
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift_catch c2) xs&#39; &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
          (&#8707;ys. (&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                xs = map (lift_catch c2) xs&#39; @
                (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)))&quot;</span></span></span><span>          
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span>           
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c1&#39;nonf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift_catch c2) xs&#39;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;)#xs = map (lift_catch c2) ((c1&#39;, s&#39;)#xs&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModCatch1</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModCatch1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
                snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
                (&#8707;ys. (&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
               fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                (&#8707;ys. (&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assth</span><span class="delimiter">:</span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
                snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
                (&#8707;ys. (&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Normal sa&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snormal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ns. s=Normal ns&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_Abrupt_prop</span><span> </span><span>step_Fault_prop</span><span> </span><span>step_Stuck_prop</span><span> </span><span>xstate.exhaust</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>             </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1 c2, s)#(Catch c1&#39; c2, s&#39;)#xs = map (lift_catch c2) ((c1,s)#(c1&#39;, s&#39;)#xs&#39;) @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModCatch3</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Throw&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snormal</span><span> </span><span>seqmap</span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span> </span><span>split&#39;</span><span> </span><span>last_length</span><span>  </span><span>cptn_mod.CptnModCatch3</span><span> </span><span>induct_step</span><span> </span><span>lastc1</span><span> </span><span>lastc1skip</span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743; 
                       (&#8707;ys. (&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod &#8743;                   
                      xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch c2) ((c1&#39;, s&#39;) # xs&#39;) = (Catch c1&#39; c2, s&#39;) # map (lift_catch c2) xs&#39;&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>             </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;)#xs = (map (lift_catch c2) ((c1&#39;, s&#39;)#xs&#39;))@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>                   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Skip&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = snd (last ((c1&#39;, s&#39;) # xs&#39;))&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span>lastc1skip</span><span> </span><span>seqmap</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cptn_mod.CptnModCatch2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>              
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CatchThrowc</span><span> </span><span>c2</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2incptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (c2, Normal s) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(Throw, Normal s)]) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ([(Throw, Normal s)])) = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(c2, snd(last [(Throw, Normal s)]))#xs) &#8712; cptn_mod&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c2incptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2,Normal s)#xs=(map (lift c2) [])@(c2, snd(last [(Throw, Normal s)]))#xs&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModCatch3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CatchSkipc</span><span> </span><span>c2</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(Skip, s)]) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>ys_nil</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;ys=[]&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Skip,  s)#ys)&#8712; cptn_mod&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Skip,  s)#ys)) = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Skip,  s)#ys)) = s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ys_nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (lift_catch c2) ys) = []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CatchSkipc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModCatch2</span><span> </span><span>ys_nil</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>FaultPropc</span><span> </span><span>c</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.FaultPropc</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>AbruptPropc</span><span> </span><span>c</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.AbruptPropc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>StuckPropc</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModSkip</span><span> </span><span>stepc.StuckPropc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_onlyif_cptn_mod</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,c) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,c) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_asm</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span> 
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnOne</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CptnModOne</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnEnv</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>t</span><span> </span><span>xs</span><span> </span><span>s</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod.CptnModEnv</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnComp</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_onlyif_cptn_mod_aux</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_is_cptn</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,c)&#8712;cptn&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,map (lift P) c) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_asm</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnOne</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnEnv</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>step_e.cases</span><span class="delimiter">,</span><span> 
</span><span>          </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnEnv</span><span> </span><span>step_e.Env</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span class="delimiter">,</span><span> 
</span><span>          </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnEnv</span><span> </span><span>step_e.Env_n</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>                                              
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnComp</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seqc</span><span> </span><span>cptn.CptnComp</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_catch_is_cptn</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,c)&#8712;cptn&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,map (lift_catch P) c) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_asm</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnOne</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnEnv</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>rule</span><span class="delimiter">:</span><span>step_e.cases</span><span class="delimiter">,</span><span> 
</span><span>          </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnEnv</span><span> </span><span>step_e.Env</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span class="delimiter">,</span><span> 
</span><span>          </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnEnv</span><span> </span><span>step_e.Env_n</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnComp</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Catchc</span><span> </span><span>cptn.CptnComp</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_lift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;xs&#8800;[]; fst(xs!(length xs - (Suc 0)))=Q&#10215; 
 &#10233; fst((map (lift P) xs)!(length (map (lift P) xs)- (Suc 0)))=Seq Q P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs ! (length xs - (Suc 0)))&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_lift_catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;xs&#8800;[]; fst(xs!(length xs - (Suc 0)))=Q&#10215; 
 &#10233; fst((map (lift_catch P) xs)!(length (map (lift_catch P) xs)- (Suc 0)))=Catch Q P&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs ! (length xs - (Suc 0)))&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_fst</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P((a#x)!length x) &#10230; &#172;P a &#10230; P (x!(length x - (Suc 0)))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>x</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_fst_esp</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst(((P,s)#xs)!(length xs))=Skip &#10233; P&#8800;Skip &#10233; fst(xs!(length xs - (Suc 0)))=Skip&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>last_fst</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_snd</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[] &#10233; 
  snd(((map (lift P) xs))!(length (map (lift P) xs) - (Suc 0)))=snd(xs!(length xs - (Suc 0)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs ! (length xs - (Suc 0)))&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>last_snd_catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[] &#10233; 
  snd(((map (lift_catch P) xs))!(length (map (lift_catch P) xs) - (Suc 0)))=snd(xs!(length xs - (Suc 0)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs ! (length xs - (Suc 0)))&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp_all</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cons_lift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((Seq P Q), s) # (map (lift Q) xs) = map (lift Q) ((P, s) # xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>last_map</span><span> </span><span>eq_snd_iff</span><span> </span><span>list.inject</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>last_length</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cons_lift_catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((Catch P Q), s) # (map (lift_catch Q) xs) = map (lift_catch Q) ((P, s) # xs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cons_lift_append</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((Seq P Q), s) # (map (lift Q) xs) @ ys = map (lift Q) ((P, s) # xs)@ ys &quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cons_lift_catch_append</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((Catch P Q), s) # (map (lift_catch Q) xs) @ ys = map (lift_catch Q) ((P, s) # xs)@ ys &quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_nth</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length xs &#10233; map (lift Q) xs ! i = lift Q  (xs! i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_catch_nth</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length xs &#10233; map (lift_catch Q) xs ! i = lift_catch Q  (xs! i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>last_length</span><span> </span><span>lift_catch_def</span><span> </span><span>Cons_lift_catch</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_lift</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt; length xs &#10233; snd(lift Q (xs ! i))= snd (xs ! i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs!i&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_lift_catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt; length xs &#10233; snd(lift_catch Q (xs ! i))= snd (xs ! i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs!i&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Normal_Normal</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P, Normal s) # a # as) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>       
</span><span>        </span><span>p2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;sb. snd (last ((P, Normal s) # a # as))  = Normal sb)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;sa. snd a = Normal sa&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>la1</span><span> </span><span>la2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>last_prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((P, Normal s)# a#as) = (la1,la2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a_prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a=(a1,a2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clos_p_a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,Normal s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (a1, a2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_prod</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P, Normal s) # (a1, a2) # as) &#8712; cptn&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_prod</span><span> </span><span>p1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last [(a1, a2)] = (a1, a2)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>cptn_dest1</span><span> </span><span>cptn_stepconf_rtrancl</span><span> </span><span>last_ConsR</span><span> </span><span>not_Cons_self2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (fst a, snd a) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup>  (la1,la2)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>p1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(a # as)) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_prod</span><span> </span><span>cptn_dest</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cptn_stepconf_rtrancl</span><span> </span><span>last_ConsR</span><span> </span><span>last_prod</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bb</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Normal bb = la2&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_prod</span><span> </span><span>p2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (fst a, snd a) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (la1, la2)`</span></span></span><span> </span><span>steps_ce_not_Normal</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_P1</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>map_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift Q) ((P, s) # xs)) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>P_ends</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P, s) # xs)) = Skip&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift Q) ((P, s) # xs) @ [(Q, snd (last ((P, s) # xs)))]) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_cptn</span><span> </span><span>P_ends</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0_skips</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P=Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,[(Seq Skip Q, s), (Q, s)]) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnComp</span><span> </span><span>SeqSkipc</span><span> </span><span>cptn.CptnOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P0_skips</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift Q) ((P, s) # a # xs)) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ( a # xs)) = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seq_PQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Seq P Q,s) # (map (lift Q) (a#xs))) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons_lift</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(map (lift Q) (a#xs))) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq P Q, s) # map (lift Q) (a # xs)) &#8712; cptn&quot;</span></span></span><span>            
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>xs1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift Q) (a#xs) = ((a1,a2)#xs1)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_dest</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_PQ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift Q) (a#xs) @ [(Q, snd (last ((a#xs))))]) &#8712; cptn&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>calculation</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq (fst a) Q, (snd a))#map (lift Q) xs @ [(Q, snd (last ((P, s)#(a#xs))))]) &#8712; cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Seq P Q,s) # (Seq (fst a) Q, (snd a))#map (lift Q) xs)&#8712; cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_PQ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Seq P Q,s) # [(Seq (fst a) Q, (snd a))]) &#8712; cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_dest1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span class="string"><span class="delete"><span class="delete">&quot;((Seq P Q,s) # [(Seq (fst a) Q, (snd a))])!length [(Seq (fst a) Q, (snd a))] = (Seq (fst a) Q, (snd a))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Seq P Q,s) # [(Seq (fst a) Q, (snd a))]@map (lift Q) xs @ [(Q, snd (last ((P, s)#(a#xs))))])&#8712; cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_append_is_cptn</span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift Q) ((P,s)#(fst a, snd a)#xs) @[(Q, snd (last ((P, s)#(a#xs))))])&#8712;cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_lift_append</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>lift_catch_P1</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>map_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch Q) ((P, Normal s) # xs)) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>P_ends</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P, Normal s) # xs)) = Throw&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>P_ends_normal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;p. snd(last ((P, Normal s) # xs)) = Normal p&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch Q) ((P, Normal s) # xs) @ [(Q, snd (last ((P, Normal s) # xs)))]) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_cptn</span><span> </span><span>P_ends</span><span> </span><span>P_ends_normal</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0_skips</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P=Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,[(Catch Throw Q, Normal s), (Q, Normal s)]) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnComp</span><span> </span><span>CatchThrowc</span><span> </span><span>cptn.CptnOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P0_skips</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch Q) ((P, Normal s) # a # xs)) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ( a # xs)) = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>s3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd(last (a #xs)) = Normal p&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seq_PQ</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Catch P Q,Normal s) # (map (lift_catch Q) (a#xs))) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons_lift_catch</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>Cons.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>axs_in_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(map (lift_catch Q) (a#xs))) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Catch P Q, Normal s) # map (lift_catch Q) (a # xs)) &#8712; cptn&quot;</span></span></span><span>            
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>xs1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch Q) (a#xs) = ((a1,a2)#xs1)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_dest</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_PQ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch Q) (a#xs) @ [(Q, snd (last ((a#xs))))]) &#8712; cptn&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=[]&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s2</span><span> </span><span>s3</span><span> </span><span>axs_in_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons.hyps</span><span> </span><span>eq_snd_iff</span><span> </span><span>last_ConsL</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>            
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>seq_PQ</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Catch P Q,Normal s) # (Catch (fst a) Q,snd a)#map (lift_catch Q) xs)&#8712; cptn&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_catch</span><span class="delimiter">)</span><span>                         
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>cf</span><span> </span><span>sf</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>last_map_axs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(cf,sf)=last (map (lift_catch Q) (a#xs))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>prod.collapse</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p ps. (ps=[] &#8743; last [p] = p) &#8744; (ps&#8800;[] &#8743; last (p#ps) = last ps)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>              
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tranclos</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch P Q,Normal s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (Catch (fst a) Q,snd a)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_lift_catch</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>cptn_dest1</span><span> </span><span>cptn_stepc_rtrancl</span><span> </span><span>not_Cons_self2</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tranclos_a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch (fst a) Q,snd a) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub><span class="hidden">&#8679;</span><sup>*</sup> (cf,sf)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_lift_catch</span><span> </span><span>axs_in_cptn</span><span> </span><span>cptn_stepc_rtrancl</span><span> </span><span>last_map_axs</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd_last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last (map (lift_catch Q) (a#xs))) = snd (last (a #xs))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqslist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd(((map (lift_catch Q) (a#xs)))!(length (map (lift_catch Q) xs)))= snd((a#xs)!(length xs))&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_snd_catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(lift_catch Q a)#(map (lift_catch Q) xs) = (map (lift_catch Q) (a#xs))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (lift_catch Q) (a#xs))!(length (map (lift_catch Q) xs)) = last (map (lift_catch Q) (a#xs))&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_length</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(lift_catch Q a)&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (lift_catch Q) xs)&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>eqslist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(snd a) = Normal p1&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>tranclos_a</span><span> </span><span>last_map_axs</span><span> </span><span>s3</span><span> </span><span>snd_conv</span><span> </span><span>step_ce_normal_to_normal</span><span> </span><span>tranclos</span><span class="delimiter">)</span><span>   
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>aeq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a = (a1,a2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((a1,a2) # xs)) = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s2</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch Q) ((a1,a2) # xs)) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aeq</span><span> </span><span>axs_in_cptn</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;p. snd (last ((a1,a2) # xs)) = Normal p&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s3</span><span> </span><span>aeq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a2 = Normal p1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aeq</span><span> </span><span>calculation</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch Q) ((a1,a2) # xs) @
                           [(Q, snd (last ((a1,a2) # xs)))])&#8712; cptn&quot;</span></span></span><span> 
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span>aeq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aeq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Catch (fst a) Q, (snd a))#map (lift_catch Q) xs @ [(Q, snd (last ((P, Normal s)#(a#xs))))]) &#8712; cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_catch_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Catch P Q,Normal s) # (Catch (fst a) Q, (snd a))#map (lift_catch Q) xs)&#8712; cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_PQ</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_catch</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Catch P Q,Normal s) # [(Catch (fst a) Q, (snd a))]) &#8712; cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_dest1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span class="string"><span class="delete"><span class="delete">&quot;((Catch P Q,Normal s) # [(Catch (fst a) Q, (snd a))])!length [(Catch (fst a) Q, (snd a))] = (Catch (fst a) Q, (snd a))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Catch P Q,Normal s) # [(Catch (fst a) Q, (snd a))]@map (lift_catch Q) xs @ [(Q, snd (last ((P, Normal s)#(a#xs))))])&#8712; cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_append_is_cptn</span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch Q) ((P,Normal s)#(fst a, snd a)#xs) @[(Q, snd (last ((P,Normal s)#(a#xs))))])&#8712;cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_lift_catch_append</span><span> </span><span>append_Cons</span><span> </span><span>append_Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq2</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P0, s) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P0, s) # xs) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, s) # xs)) = Skip&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P1, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P1, snd (last ((P0, s) # xs))) # ys) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p6</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq P0 P1, s) # zs) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>p3</span><span> </span><span>p4</span><span> </span><span>p5</span><span> </span><span>p6</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, s) # xs)) = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (map (lift P1) ((P0, s) # xs))@(P1, snd (last ((P0, s) # xs))) # ys) &#8712; cptn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,map (lift P1) ((P0, s) #xs)) &#8712; cptn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2</span><span> </span><span>lift_is_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,map (lift P1) ((P0, s) #xs)@[(P1, snd (last ((P0, s) # xs)))]) &#8712; cptn&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>last_skip</span><span> </span><span>lift_P1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Seq P0 P1, s) # map (lift P1) xs@[(P1, snd (last ((P0, s) # xs)))]) &#8712; cptn&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_append</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((Seq P0 P1, s) # map (lift P1) xs @[(P1, snd (last ((P0, s) # xs)))]) = (P1, snd (last ((P0, s) # xs)))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((Seq P0 P1, s) # map (lift P1) xs @[(P1, snd (last ((P0, s) # xs)))]) =
                   ((Seq P0 P1, s) # map (lift P1) xs @[(P1, snd (last ((P0, s) # xs)))])!length (map (lift P1) xs @[(P1, snd (last ((P0, s) # xs)))])&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>             
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq P0 P1, s) # map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys)&#8712; cptn&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_append_is_cptn</span><span> </span><span>p5</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_append</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_append</span><span> </span><span>p6</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq3</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>    </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P0, Normal s) # xs) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (P0, Normal s) # xs) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, Normal s) # xs)) = Throw&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P0, Normal s) # xs)) = Normal s&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p5</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p6</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>p7</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift P1) xs @((Throw,Normal s&#39;)#ys)&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq P0 P1, Normal s) # zs) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p1</span><span> </span><span>p2</span><span> </span><span>p3</span><span> </span><span>p4</span><span> </span><span>p5</span><span> </span><span>p6</span><span> </span><span>p7</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>zs</span><span> </span><span>P0</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SeqThrowc</span><span> </span><span>cptn.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd a = Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Normal_Normal</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a_prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a=(a1,a2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>la1</span><span> </span><span>la2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>last_prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last (a#as) = (la1,la2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lasst_aas_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last (a#as) = (last ((P0, Normal s) # a # as))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;la1 = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>last_prod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;la2 = Normal s&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>last_prod</span><span> </span><span>lasst_aas_last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (a1, a2) # as) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>a_prod</span><span> </span><span>cptn_dest</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Normal sa = a2&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`snd a = Normal sa`</span></span></span><span> </span><span>a_prod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, a # as) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>a_prod</span><span> </span><span>cptn_onlyif_cptn_mod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq a1 P1, Normal sa) # 
            map (lift P1) as @ ((Throw,Normal s&#39;)#ys)) &#8712; cptn&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>  </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>a_prod</span><span> </span><span>f1</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Seq a1 P1, a2) # map (lift P1) as @((Throw,Normal s&#39;)#ys) = zs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>Cons_lift_append</span><span> </span><span>a_prod</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Seqc</span><span> </span><span>a_prod</span><span> </span><span>cptn.CptnComp</span><span> </span><span>cptn.CptnEnv</span><span> </span><span>Env</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>f2</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_if_cptn_mod</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_mod_asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,c) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,c) &#8712; cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_asm</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModOne</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn.CptnOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnModSkip</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnModThrow</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnModCondT</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CondTruec</span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>CptnModCondF</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CondFalsec</span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSeq1</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift P1) ((P0, s) # xs)) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModSeq1.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lift_is_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift</span><span> </span><span>CptnModSeq1.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSeq2</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>seq2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSeq3</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModWhile1</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_lift</span><span> </span><span>WhileTruec</span><span> </span><span>cptn.CptnComp</span><span> </span><span>lift_is_cptn</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModWhile2</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span> </span><span>ys</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Seq P (While b P), Normal s) # zs) &#8712; cptn&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>seq2</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(While b P,Normal s) &#8594; (Seq P (While b P),Normal s)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModWhile2.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>WhileTruec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(&#915;, (Seq P (While b P), Normal s) # zs) &#8712; cptn`</span></span></span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModWhile3</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(Seq P (While b P), Normal s) # zs) &#8712; cptn&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq3</span><span class="delimiter">)</span><span>     
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(While b P,Normal s) &#8594; (Seq P (While b P),Normal s)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>WhileTruec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(&#915;, (Seq P (While b P), Normal s) # zs) &#8712; cptn`</span></span></span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCall</span><span> </span><span>&#915;</span><span> </span><span>bdy</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>p</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Callc</span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModDynCom</span><span> </span><span>&#915;</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>DynComc</span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModGuard</span><span> </span><span>&#915;</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>g</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Guardc</span><span> </span><span>cptn.CptnComp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCatch1</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch P1) ((P0, s) # xs)) &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModCatch1.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lift_catch_is_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_catch</span><span> </span><span>CptnModCatch1.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCatch2</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>zs</span><span> </span><span>P0</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CatchSkipc</span><span> </span><span>cptn.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd a = sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a_prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a=(a1,a2)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>sa_a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a2 =sa&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>la1</span><span> </span><span>la2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>last_prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last (a#as) = (la1,la2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lasst_aas_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last (a#as) = (last ((P0, s) # a # as))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;la1 = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>last_prod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (a1, a2) # as) &#8712; cptn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>a_prod</span><span> </span><span>cptn_dest</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, a # as) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>a_prod</span><span> </span><span>cptn_onlyif_cptn_mod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Catch a1 P1, a2) # 
              map (lift_catch P1) as @ ((Skip, la2)#ys)) &#8712; cptn&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span> </span><span>a_prod</span><span> </span><span>f1</span><span> </span><span>last_prod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch a1 P1, a2) # map (lift_catch P1) as @ ((Skip, la2)#ys) = zs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons_lift_catch_append</span><span> </span><span>a_prod</span><span> </span><span>last_prod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span class="delimiter">)</span><span>         
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, map (lift_catch P1) ((P0, s) # a # as)) &#8712; cptn&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>lift_catch_is_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (LanguageCon.com.Catch P0 P1, s) # (LanguageCon.com.Catch a1 P1, a2) # map (lift_catch P1) as) &#8712; cptn&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Cons_lift_catch</span><span> </span><span>a_prod</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (LanguageCon.com.Catch P0 P1, s) # zs) &#8712; cptn &#8744; (&#915;, (LanguageCon.com.Catch P0 P1, s) # (LanguageCon.com.Catch a1 P1, a2) # map (lift_catch P1) as) &#8712; cptn &#8743; (&#172; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Catch P0 P1, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (LanguageCon.com.Catch P0 P1, a2) &#8744; (&#915;, (LanguageCon.com.Catch P0 P1, a2) # map (lift_catch P1) as) &#8713; cptn &#8744; LanguageCon.com.Catch a1 P1 &#8800; LanguageCon.com.Catch P0 P1)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>cptn.CptnEnv</span><span> </span><span>hyp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>f1</span><span> </span><span>cptn.CptnComp</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>hyp</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCatch3</span><span>  </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>zs</span><span> </span><span>P0</span><span> </span><span>s</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CatchThrowc</span><span> </span><span>cptn.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>as</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd a = Normal sa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Normal_Normal</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a_prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a=(a1,a2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>la1</span><span> </span><span>la2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>last_prod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last (a#as) = (la1,la2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lasst_aas_last</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last (a#as) = (last ((P0, Normal s) # a # as))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;la1 = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>last_prod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;la2 = Normal s&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>last_prod</span><span> </span><span>lasst_aas_last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (a1, a2) # as) &#8712; cptn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>a_prod</span><span> </span><span>cptn_dest</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Normal sa = a2&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`snd a = Normal sa`</span></span></span><span> </span><span>a_prod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, a # as) &#8712; cptn_mod&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>a_prod</span><span> </span><span>cptn_onlyif_cptn_mod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (Catch a1 P1, Normal sa) # 
              map (lift_catch P1) as @ (P1, snd (last ((a1, Normal sa) # as))) # ys) &#8712; cptn&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span> </span><span>a_prod</span><span> </span><span>f1</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P0, Normal s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P0, a2)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>step_e.intros</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>transit</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P0,Normal s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (a1,Normal sa)&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>a_prod</span><span> </span><span>c_step</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>e_step</span><span> </span><span>f2</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>transit_catch</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch P0 P1,Normal s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (Catch a1 P1,Normal sa)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Catchc</span><span> </span><span>c_step</span><span> </span><span>e_step</span><span> </span><span>env_c_c&#39;</span><span> </span><span>step_ce_elim_cases</span><span> </span><span>step_e.intros</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch a1 P1, a2) # map (lift_catch P1) as @ (P1, la2) # ys = zs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span>Cons_lift_catch_append</span><span> </span><span>a_prod</span><span> </span><span>last_prod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>        
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=(a1, Normal sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_prod</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((a1, Normal sa) # as)) = Normal s&#39;&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`a = (a1, Normal sa)`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`snd (last ((P0, Normal s) # a # as)) = Normal s&#39;`</span></span></span><span> </span><span>lasst_aas_last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((a1, Normal sa) # as)) = la2&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`la2 = Normal s&#39;`</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Catch P0 P1, Normal s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (LanguageCon.com.Catch a1 P1, a2)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>transit_catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`(LanguageCon.com.Catch a1 P1, a2) # map (lift_catch P1) as @ (P1, la2) # ys = zs`</span></span></span><span>  
</span><span>              </span><span>cptn.CptnComp</span><span> </span><span>cptn.CptnEnv</span><span> </span><span>f2</span><span> </span><span>hyp</span><span> </span><span>not_eq_not_env</span><span> </span><span>step_ce_not_step_e_step_c</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModEnv</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnEnv</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_eq_cptn_mod</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(x &#8712;cptn_mod)  = (x&#8712;cptn)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>x</span><span class="delimiter">,</span><span> </span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_if_cptn_mod</span><span> </span><span>cptn_onlyif_cptn_mod</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_eq_cptn_mod_set</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;cptn_mod  = cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_if_cptn_mod</span><span> </span><span>cptn_onlyif_cptn_mod</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Computational modular semantic for nested calls&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>cptn_mod_nest_call</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nat&#215;(&#39;s,&#39;p,&#39;f,&#39;e) confs) set&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span>CptnModNestOne</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,[(P, s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestEnv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P,t);(n,&#915;,(P, t)#xs) &#8712; cptn_mod_nest_call&#10215; &#10233; 
                     (n,&#915;,(P, s)#(P, t)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestSkip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Skip,t); redex P = P; 
                     &#8704;f. ((&#8707;sn. s = Normal sn) &#8743; (&#915; f) = Some Skip &#10230; P  &#8800; Call f  );
                (n,&#915;,(Skip, t)#xs) &#8712; cptn_mod_nest_call &#10215; &#10233; 
                (n,&#915;,(P,s)#(Skip, t)#xs) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestThrow</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Throw,t); redex P = P; 
                     &#8704;f. ((&#8707;sn. s = Normal sn) &#8743; (&#915; f) = Some Throw &#10230; P  &#8800; Call f  );
                      (n,&#915;,(Throw, t)#xs) &#8712; cptn_mod_nest_call &#10215; &#10233; 
                      (n,&#915;,(P,s)#(Throw, t)#xs) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestCondT</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;,(P0, Normal s)#ys) &#8712; cptn_mod_nest_call; s &#8712; b &#10215; &#10233; 
                    (n,&#915;,((Cond b P0 P1), Normal s)#(P0, Normal s)#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestCondF</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;,(P1, Normal s)#ys) &#8712; cptn_mod_nest_call; s &#8713; b &#10215; &#10233; 
                     (n,&#915;,((Cond b P0 P1), Normal s)#(P1, Normal s)#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestSeq1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call; zs=map (lift P1) xs &#10215; &#10233; 
   (n,&#915;,((Seq P0 P1), s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestSeq2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;, (P0, s)#xs) &#8712; cptn_mod_nest_call; fst(last ((P0, s)#xs)) = Skip;
    (n,&#915;,(P1, snd(last ((P0, s)#xs)))#ys) &#8712; cptn_mod_nest_call;
    zs=(map (lift P1) xs)@((P1, snd(last ((P0, s)#xs)))#ys) &#10215; &#10233; 
   (n,&#915;,((Seq P0 P1), s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*| CptnModNestSeq3:
  &quot;&#10214; (&#915;,(P1, s)#xs) &#8712; cptn_mod_nest_call&#10215; &#10233; (&#915;,((Seq Skip P1), s)#(P1, s)#xs) &#8712; cptn_mod_nest_call&quot;*)</span></span></span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestSeq3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;, (P0, Normal s)#xs) &#8712; cptn_mod_nest_call; 
    fst(last ((P0, Normal s)#xs)) = Throw;
    snd(last ((P0, Normal s)#xs)) = Normal s&#39;; 
    (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call; 
    zs=(map (lift P1) xs)@((Throw,Normal s&#39;)#ys) &#10215; &#10233;
   (n,&#915;,((Seq P0 P1), Normal s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestWhile1</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;, (P, Normal s)#xs) &#8712; cptn_mod_nest_call; s &#8712; b; 
    zs=map (lift (While b P)) xs &#10215; &#10233; 
    (n,&#915;, ((While b P), Normal s)#
      ((Seq P (While b P)),Normal s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestWhile2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (n,&#915;, (P, Normal s)#xs) &#8712; cptn_mod_nest_call; 
     fst(last ((P, Normal s)#xs))=Skip; s &#8712; b; 
     zs=(map (lift (While b P)) xs)@
      (While b P, snd(last ((P, Normal s)#xs)))#ys; 
      (n,&#915;,(While b P, snd(last ((P, Normal s)#xs)))#ys) &#8712; 
        cptn_mod_nest_call&#10215; &#10233; 
   (n,&#915;,(While b P, Normal s)#
     (Seq P (While b P), Normal s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestWhile3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (n,&#915;, (P, Normal s)#xs) &#8712; cptn_mod_nest_call; 
     fst(last ((P, Normal s)#xs))=Throw; s &#8712; b;
     snd(last ((P, Normal s)#xs)) = Normal s&#39;; 
    (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call;  
     zs=(map (lift (While b P)) xs)@((Throw,Normal s&#39;)#ys)&#10215; &#10233; 
   (n,&#915;,(While b P, Normal s)#
     (Seq P (While b P), Normal s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestCall</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;,(bdy, Normal s)#ys) &#8712; cptn_mod_nest_call;&#915; p = Some bdy; bdy&#8800;Call p &#10215; &#10233; 
                 (Suc n, &#915;,((Call p), Normal s)#(bdy, Normal s)#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestDynCom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;,(c s, Normal s)#ys) &#8712; cptn_mod_nest_call &#10215; &#10233; 
                 (n,&#915;,(DynCom c, Normal s)#(c s, Normal s)#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestGuard</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;,(c, Normal s)#ys) &#8712; cptn_mod_nest_call; s &#8712; g &#10215; &#10233; 
                  (n,&#915;,(Guard f g c, Normal s)#(c, Normal s)#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestCatch1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call; zs=map (lift_catch P1) xs &#10215;
                 &#10233; (n,&#915;,((Catch P0 P1), s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestCatch2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;, (P0, s)#xs) &#8712; cptn_mod_nest_call; fst(last ((P0, s)#xs)) = Skip; 
    (n,&#915;,(Skip,snd(last ((P0, s)#xs)))#ys) &#8712; cptn_mod_nest_call;  
    zs=(map (lift_catch P1) xs)@((Skip,snd(last ((P0, s)#xs)))#ys) &#10215; &#10233; 
   (n,&#915;,((Catch P0 P1), s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">|</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;(n,&#915;, (P0, Normal s)#xs) &#8712; cptn_mod_nest_call; fst(last ((P0, Normal s)#xs)) = Throw; 
  snd(last ((P0, Normal s)#xs)) = Normal s&#39;;
  (n,&#915;,(P1, snd(last ((P0, Normal s)#xs)))#ys) &#8712; cptn_mod_nest_call; 
  zs=(map (lift_catch P1) xs)@((P1, snd(last ((P0, Normal s)#xs)))#ys) &#10215; &#10233; 
   (n,&#915;,((Catch P0 P1), Normal s)#zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>CptnMod_nest_call_induct</span><span> </span><span class="delimiter">=</span><span> </span><span>cptn_mod_nest_call.induct</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[(c,s)]&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>split_format</span><span> </span><span class="delimiter">(</span><span>complete</span><span class="delimiter">)</span><span class="delimiter">,</span><span> </span><span>case_names</span><span>
</span><span>CptnModOne</span><span> </span><span>CptnModEnv</span><span> </span><span>CptnModSkip</span><span> </span><span>CptnModThrow</span><span> </span><span>CptnModCondT</span><span> </span><span>CptnModCondF</span><span> 
</span><span>CptnModSeq1</span><span> </span><span>CptnModSeq2</span><span> </span><span>CptnModSeq3</span><span> </span><span>CptnModSeq4</span><span> </span><span>CptnModWhile1</span><span> </span><span>CptnModWhile2</span><span> </span><span>CptnModWhile3</span><span> </span><span>CptnModCall</span><span> </span><span>CptnModDynCom</span><span> </span><span>CptnModGuard</span><span> 
</span><span>CptnModCatch1</span><span> </span><span>CptnModCatch2</span><span> </span><span>CptnModCatch3</span><span class="delimiter">,</span><span> </span><span>induct</span><span> </span><span>set</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>CptnModNest_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Skip, s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Guard f g c, s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Basic f e, s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Spec r e, s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Seq c1 c2, s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Cond b c1 c2, s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Await b c2 e, s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Call p, s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(DynCom c,s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Throw,s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Catch c1 c2,s)#u#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Seq_Seq&#39;</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Seq c1 c2,s) &#8594; (Seq c1&#39; c2&#39;,s&#39;)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_elim_cases_Catch_Catch&#39;</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch c1 c2,s) &#8594; (Catch c1&#39; c2&#39;,s&#39;)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>CptnModNest_same_elim_cases</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(u, s)#(u,t)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>CptnModNest_elim_cases_Stuck</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P, Stuck)#(Skip, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>CptnModNest_elim_cases_Fault</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P, Fault f)#(Skip, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>CptnModNest_elim_cases_Abrupt</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P, Abrupt as)#(Skip, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span>  </span><span>CptnModNest_elim_cases_Call_Stuck</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Call p, s)#(Skip, Stuck)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span>  </span><span>CptnModNest_elim_cases_Call</span><span> </span><span class="delimiter">[</span><span>cases</span><span> </span><span>set</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(0, &#915;,((Call p), Normal s)#(bdy, Normal s)#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_nest_mono1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfs) &#8712;  cptn_mod_nest_call  &#10233; (Suc n,&#915;,cfs)&#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod_nest_call.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestOne</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestEnv</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSkip</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestThrow</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.intros</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCondT</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestCondT</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCondF</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestCondF</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq1</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq2</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq3</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile1</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile2</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile3</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile3</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCall</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestCall</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestDynCom</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestDynCom</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestGuard</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestGuard</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch1</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch1</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch2</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch3</span><span> </span><span>n</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Suc n&quot;</span></span></span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_nest_mono2</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfs) &#8712;  cptn_mod_nest_call  &#10233; m&gt;n &#10233;
   (m,&#915;,cfs)&#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m-n&quot;</span></span></span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>m</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>k</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m - Suc n = k&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Suc_diff_Suc</span><span> </span><span>Suc_inject</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Suc.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Suc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_mono1</span><span> </span><span>less_Suc_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfs) &#8712;  cptn_mod_nest_call  &#10233; m&#8805;n &#10233;
   (m,&#915;,cfs)&#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n=m&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, cfs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;n = m&quot;</span></span></span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, cfs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>  
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8804;m&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8800; m&quot;</span></span></span><span>  
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_mono2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Lemmas on normalization&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma step_sequence_flatten:
  assumes exec: &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Q,t)&quot; 
  shows &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(sequence Seq (flatten P),s) &#8594; (sequence Seq (flatten Q),t)&quot;
using exec
proof (induct rule: stepc_induct)
  case (Guardc s g f c) thus ?case using stepc.Guardc
  case (Seqc c1 s c2 s&#39; c2&#39;)
  then have &quot; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq (LanguageCon.sequence LanguageCon.com.Seq (LanguageCon.flatten c1)) c2&#39;, s) &#8594;
                   (Seq (LanguageCon.sequence LanguageCon.com.Seq (LanguageCon.flatten c2)) c2&#39;, s&#39;) &quot; 
    using stepc.Seqc by fastforce    
  thus ?case sorry
qed(auto intro:stepc.intros)+

lemma normalice_step:
  assumes exec:&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s) &#8594; (Q,t)&quot; 
  shows  &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>( normalizec P,s) &#8594; (normalizec Q,t)&quot;
using exec
proof(induct rule:stepc_induct)
  case (Catchc P s Q t c2)
    thus ?case
   *)</span></span></span></span></span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* qed(auto intro: stepc.intros) *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Equivalence of comp mod semantics and comp mod nested&#8250;</span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*lemma 
assumes a0: &quot;(n, &#915;, xsa) &#8712; cptn_mod_nest_call&quot; and      
        a1:&quot;xsa = (P, Normal sn) # xs&quot; and
        a2: &quot;P = Seq p1 p2 &#8743; redex p1 = Call f&quot; and
        a3: &quot;(&#915; f) = Some (Call f)&quot; 
shows &quot;&#8704;i&lt;length xsa. fst (xsa!i) = P&quot;
proof -
  have &quot;(&#915;, xsa) &#8712; cptn&quot; using a0 cptn_mod_nest_cptn_mod
  using cptn_eq_cptn_mod_set by auto
  then show ?thesis using a1 a2 a3
  proof(induct arbitrary: p1 p2 xs) 
    case (CptnOne &#915; P0 s p1 p2) thus ?case
      by simp
  next
    case (CptnEnv)
      thus ?case sorry
  next
    case (CptnComp) thus ?case sorry
  qed
qed
*)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>catch_cond_nest</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest zs Q xs P s s&#39;&#39; s&#39; &#915; n &#8801; (zs=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, s)#xs)) = Normal s&#39; &#8743; s=Normal s&#39;&#39;&#8743;
               (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                zs=(map (lift_catch Q) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
                 (&#8707;ys. (n,&#915;,(Skip,snd(last ((P, s)#xs)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 zs=(map (lift_catch Q) xs)@((Skip,snd(last ((P, s)#xs)))#ys)))))
&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_catch_nest</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,list) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. list=(Catch P Q, s)#zs &#10230;
       (&#8707;xs s&#39; s&#39;&#39;. 
          (n, &#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
             catch_cond_nest zs Q xs P s s&#39;&#39; s&#39; &#915; n))  
            &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>catch_cond_nest_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_m</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestOne</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSkip</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Skip, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noskip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~(P=Skip)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p1 p2. &#172;(P=Catch p1 p2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSkip.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>redex_not_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_cptn_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (Skip, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>no_catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestThrow</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestThrow.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Throw, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestThrow.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_cptn_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (Throw, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p1 p2. &#172;(P=Catch p1 p2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestThrow.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>redex_not_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCondT</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCondF</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch1</span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestCatch2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = Skip&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch P1) xs @((Skip,snd(last ((P0, s)#xs)))#ys)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModNestCatch2.hyps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch P0 P1, s) # zs = (Catch P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P0 =P &#8743; P1 = Q &#8743; s=sa &#8743; zs=zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P0, s) = (P, sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, s) # xs) = ((P, sa) # xs) ! length xs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = (map (lift_catch Q) xs)@((Skip,snd(last ((P0, s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift_catch P1) xs @ ((Skip,snd(last ((P0, s)#xs)))#ys)`</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39; s&#39;&#39;. ((n,&#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
             ((zs=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, s)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
               (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                zs=(map (lift_catch Q) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                (&#8707;ys. ((fst(((P, s)#xs)!length xs)=Skip &#8743; (n,&#915;,(Skip,snd(last ((P, s)#xs)))#ys) &#8712; cptn_mod_nest_call &#8743;                 
                 zs=(map (lift_catch Q) xs)@((Skip,snd(last ((P0, s)#xs)))#ys))))))))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P0cptn</span><span>  </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span>  </span><span>last</span><span>  </span><span>CptnModNestCatch2.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestCatch3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, Normal s) # xs) ! length xs) = Throw&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestCatch3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastnormal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P0, Normal s) # xs)) = Normal s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P0, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestCatch3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P1cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P1, snd (((P0, Normal s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch P1) xs @ (P1, snd (last ((P0, Normal s) # xs))) # ys&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModNestCatch3.hyps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch P0 P1, Normal s) # zs = (Catch P Q, Normal sa) # zsa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P0 =P &#8743; P1 = Q &#8743; Normal s= Normal sa &#8743; zs=zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, Normal s) # xs) = ((P, Normal sa) # xs) ! length xs&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zsa = map (lift_catch Q) xs @ (Q, snd (((P, Normal sa) # xs) ! length xs)) # ys&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift_catch P1) xs @ (P1, snd (last ((P0, Normal s) # xs))) # ys`</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743; (fst(((P, Normal s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, Normal s)#xs)) = Normal s&#39; &#8743; 
              (&#8707;ys. (n,&#915;,(Q, snd(((P, Normal s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
              zs=(map (lift_catch Q) xs)@((Q, snd(((P, Normal s)#xs)!length xs))#ys)))&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lastnormal</span><span> </span><span>P1cptn</span><span> </span><span>P0cptn</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span>last</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span>zs</span><span class="delimiter">]</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestEnv</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span> </span><span>xs</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catch</span><span> </span><span>P1</span><span> </span><span>P2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_P_Catch</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) # xs = (LanguageCon.com.Catch P1 P2, t) # xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xsa</span><span> </span><span>t&#39;</span><span> </span><span>t&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P1, t) # xsa) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>        </span><span>p2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; (xs = map (lift_catch P2) xsa &#8744;
            fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Throw &#8743;
            snd (last ((P1, t) # xsa)) = Normal t&#39; &#8743;
            t = Normal t&#39;&#39; &#8743;
            (&#8707;ys. (n,&#915;, (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8712; cptn_mod_nest_call &#8743;
              xs = map (lift_catch P2) xsa @ (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8744;
                fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Skip &#8743;
                (&#8707;ys.(n,&#915;,(Skip,snd(last ((P1, t)#xsa)))#ys) &#8712; cptn_mod_nest_call &#8743; 
                xs = map (lift_catch P2) xsa @
                ((LanguageCon.com.Skip, snd (last ((P1, t) # xsa)))#ys)))&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestEnv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P1, s)#((P1, t) # xsa)) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p1</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span> </span><span>cptn_mod.CptnModEnv</span><span> </span><span>env_normal_s</span><span> </span><span>step_e</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SmallStepCon.redex P = SmallStepCon.redex P1&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bb</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;b, &#39;c) xstate &#8658; &#39;b&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x2. (&#8707;v5. x2 = Normal v5) = (x2 = Normal (bb x2))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = t &#8744; s = Normal (bb s)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>env_normal_s</span><span> </span><span>step_e</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span> </span><span>cptn_mod_nest_call.CptnModNestEnv</span><span> </span><span>p1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>  
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift_catch P2) xsa&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) # xs = map (lift_catch P2) ((P1, t) # xsa)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`xs = map (lift_catch P2) xsa`</span></span></span><span> </span><span>lift_catch_def</span><span> </span><span>local.Catch</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_step</span><span> </span><span>eq_P_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Throw &#8743;
          snd (last ((P1, t) # xsa)) = Normal t&#39; &#8743;
          t = Normal t&#39;&#39; &#8743;
          (&#8707;ys. (n,&#915;, (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs =
                map (lift_catch P2) xsa @
                (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8744;
                fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Skip &#8743;
           (&#8707;ys. (n,&#915;,(Skip,snd(last ((P1, t)#xsa)))#ys) &#8712; cptn_mod_nest_call &#8743; 
            xs = map (lift_catch P2) xsa @
            ((LanguageCon.com.Skip, snd (last ((P1, t) # xsa)))#ys))&quot;</span></span></span><span>      
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>            </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Throw &#8743;
             snd (last ((P1, t) # xsa)) = Normal t&#39; &#8743;
             t = Normal t&#39;&#39; &#8743;
             (&#8707;ys. (n,&#915;, (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift_catch P2) xsa @
                       (P2, snd (((P1, t) # xsa) ! length xsa)) # ys)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p2_exec</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P2, snd (((P1, t) # xsa) ! length xsa)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift_catch P2) xsa @
                       (P2, snd (((P1, t) # xsa) ! length xsa)) # ys&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal t1&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>env_normal_s&#39;_normal_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, s)#(P1, t) # xsa) ! length ((P1, t)#xsa)) = LanguageCon.com.Throw&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>             </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P1, s)#(P1, t) # xsa)) = Normal t&#39;&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2_long_exec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P2, snd (((P1, s)#(P1, t) # xsa) ! length ((P1, s)#xsa))) # ys) &#8712; cptn_mod_nest_call &#8743;
                (P, t)#xs = map (lift_catch P2) ((P1, t) # xsa) @
                       (P2, snd (((P1, s)#(P1, t) # xsa) ! length ((P1, s)#xsa))) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2_exec</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span> </span><span>local.Catch</span><span class="delimiter">)</span><span>                  
</span><span>             </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a1</span><span> </span><span>f1</span><span> </span><span>last_normal</span><span> </span><span>all_step</span><span> </span><span>eq_P_Catch</span><span> 
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>not_step_c_env</span><span>  </span><span>step_e</span><span class="delimiter">)</span><span>            
</span><span>           </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>            </span><span>as1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xsa) ! length xsa) = LanguageCon.com.Skip &#8743;
           (&#8707;ys. (n,&#915;,(Skip,snd(last ((P1, t)#xsa)))#ys) &#8712; cptn_mod_nest_call &#8743; 
            xs = map (lift_catch P2) xsa @
            ((LanguageCon.com.Skip, snd (last ((P1, t) # xsa)))#ys))&quot;</span></span></span><span>               
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Skip,snd(last ((P1, t)#xsa)))#ys) &#8712; cptn_mod_nest_call &#8743; 
                         (P, t)#xs = map (lift_catch P2) ((P1, t) # xsa) @
                          ((LanguageCon.com.Skip, snd (last ((P1, t) # xsa)))#ys)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;ys. (n,&#915;, (LanguageCon.com.Skip, snd (last ((P1, t) # xsa))) # ys) &#8712; cptn_mod_nest_call &#8743; 
                         (P, t) # xs = map (lift_catch P2) ((P1, t) # xsa) @ 
                         (LanguageCon.com.Skip, snd (last ((P1, t) # xsa))) # ys &#10233; 
                         thesis&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Catch P1 P2, t) # map (lift_catch P2) xsa = map (lift_catch P2) ((P1, t) # xsa)&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>as1</span><span> </span><span>eq_P_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>            
</span><span>            </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>as1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, s)#(P1, t) # xsa) ! length ((P1, t) #xsa)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>                 </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>                              
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p1</span><span> </span><span>all_step</span><span> </span><span>eq_P_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>force</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>seq_cond_nest</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest zs Q xs P s s&#39;&#39; s&#39; &#915; n &#8801; (zs=(map (lift Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
               (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                zs=(map (lift (Q)) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743; 
                 snd(last ((P, s)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
                 (&#8707;ys.  (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                      zs=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys)))))
&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>div_seq_nest</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>cptn_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,list) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. list=(Seq P Q, s)#zs &#10230;
       (&#8707;xs s&#39; s&#39;&#39;. 
          (n,&#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
             seq_cond_nest zs Q xs P s s&#39;&#39; s&#39; &#915; n))  
            &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_m</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.induct</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestOne</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSkip</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Skip, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>noskip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;~(P=Skip)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;c c1 c2. redex c = Seq c1 c2 &#10233; False&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>redex_not_Seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSkip.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>in_cptn_mod</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (Skip, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSkip.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex_not_Seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestThrow</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestThrow.hyps</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (Throw, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestThrow.hyps</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>no_seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p1 p2. &#172;(P=Seq p1 p2)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestThrow.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>redex_not_Seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCondT</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCondF</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>ys</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSeq2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>last_length</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = Skip&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSeq2.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P1cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModNestSeq2.hyps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq P0 P1, s) # zs = (Seq P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P0 =P &#8743; P1 = Q &#8743; s=sa &#8743; zs=zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, s) # xs) = ((P, sa) # xs) ! length xs&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys`</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39; s&#39;&#39;. (n,&#915;, (P, sa) # xs) &#8712; cptn_mod_nest_call &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P, sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (n,&#915;, (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, sa)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
                         (&#8707;ys. (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                               zsa=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))))))
               &quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P0cptn</span><span> </span><span>P1cptn</span><span>  </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; s = sa &#8743; zs = zsa`</span></span></span><span> </span><span>last</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                 
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span>  
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>     
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, Normal s) # xs) ! length xs) = Throw&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P0cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P0, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastnormal</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P0, Normal s) # xs)) = Normal s&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift P1) xs @ ((Throw, Normal s&#39;)#ys)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModNestSeq3.hyps</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq P0 P1, Normal s) # zs = (Seq P Q, Normal sa) # zsa&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P0 =P &#8743; P1 = Q &#8743; Normal s=Normal sa &#8743; zs=zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P0, Normal s) = (P, Normal sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, Normal s) # xs) = ((P, Normal sa) # xs) ! length xs&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zsa</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zsa = (map (lift Q) xs)@((Throw,Normal s&#39;)#ys)&quot;</span></span></span><span>
</span><span>                    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift P1) xs @ ((Throw, Normal s&#39;)#ys)`</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>               
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, Normal sa::(&#39;b, &#39;c) xstate) = (P0, Normal s)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`P0 = P &#8743; P1 = Q &#8743; Normal s = Normal sa &#8743; zs = zsa`</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39;. (n,&#915;, (P, Normal sa) # xs) &#8712; cptn_mod_nest_call &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P,Normal sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (n,&#915;, (Q, snd (((P, Normal sa) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, Normal sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, Normal sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, Normal sa)#xs)) = Normal s&#39; &#8743;
                          (&#8707;ys. (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                          zsa=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))))))&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P0cptn</span><span> </span><span>zsa</span><span> </span><span>a1</span><span> </span><span>last</span><span> </span><span>lastnormal</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span>  
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestEnv</span><span>  </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P, t) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step_e</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>P1</span><span> </span><span>P2</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_P</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) # zs = (LanguageCon.com.Seq P1 P2, t) # zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>t&#39;</span><span> </span><span>t&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P1, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;
     (zs = map (lift P2) xs &#8744;
      fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Skip &#8743;      
      (&#8707;ys. (n,&#915;, (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
            zs =
            map (lift P2) xs @
            (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8744;
      fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
      snd (last ((P1, t) # xs)) = Normal t&#39; &#8743;
      t = Normal t&#39;&#39; &#8743; (&#8707;ys. (n,&#915;,(Throw,Normal t&#39;)#ys) &#8712; cptn_mod_nest_call &#8743; 
      zs =
      map (lift P2) xs @
      ((LanguageCon.com.Throw, Normal t&#39;)#ys))) &quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestEnv</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P1, s)#((P1, t) # xs)) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p1</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span> </span><span>cptn_mod_nest_call.CptnModNestEnv</span><span> </span><span>env_normal_s</span><span> </span><span>step_e</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SmallStepCon.redex P = SmallStepCon.redex P1&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>local.Seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span> </span><span>cptn_mod_nest_call.CptnModNestEnv</span><span> </span><span>env_normal_s</span><span> </span><span>p1</span><span> </span><span>step_e</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>             
</span><span>      </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>  
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift P2) xs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) # zs = map (lift P2) ((P1, t) # xs)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="alt_string"><span class="delete"><span class="delete">`zs = map (lift P2) xs`</span></span></span><span> </span><span>lift_def</span><span> </span><span>local.Seq</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_step</span><span> </span><span>eq_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Skip &#8743;      
         (&#8707;ys. (n,&#915;, (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
            zs = map (lift P2) xs @ (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8744;
          fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
           snd (last ((P1, t) # xs)) = Normal t&#39; &#8743;
           t = Normal t&#39;&#39; &#8743; (&#8707;ys. (n,&#915;,(Throw,Normal t&#39;)#ys) &#8712; cptn_mod_nest_call &#8743; 
           zs = map (lift P2) xs @ ((LanguageCon.com.Throw, Normal t&#39;)#ys))&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>            </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Skip &#8743;      
               (&#8707;ys. (n,&#915;, (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
               zs = map (lift P2) xs @ (P2, snd (((P1, t) # xs) ! length xs)) # ys)&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                   </span><span>p2_exec</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P2, snd (((P1, t) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                       zs = map (lift P2) xs @
                       (P2, snd (((P1, t) # xs) ! length xs)) # ys&quot;</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>               </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, s)#(P1, t) # xs) ! length ((P1, t)#xs)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>             
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2_long_exec</span><span class="delimiter">:</span><span> 
</span><span>                 </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P2, snd (((P1, s)#(P1, t) # xs) ! length ((P1, t)#xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
                  (P, t)#zs = map (lift P2) ((P1, t) # xs) @
                       (P2, snd (((P1, s)#(P1, t) # xs) ! length ((P1, t)#xs))) # ys&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2_exec</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_def</span><span> </span><span>local.Seq</span><span class="delimiter">)</span><span>     
</span><span>             </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>f1</span><span> </span><span>all_step</span><span> </span><span>eq_P</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>            
</span><span>           </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>            </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, t) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
            snd (last ((P1, t) # xs)) = Normal t&#39; &#8743; t = Normal t&#39;&#39; &#8743; 
          (&#8707;ys. (n,&#915;,(Throw,Normal t&#39;)#ys) &#8712; cptn_mod_nest_call &#8743; 
           zs = map (lift P2) xs @ ((LanguageCon.com.Throw, Normal t&#39;)#ys))&quot;</span></span></span><span>             
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_throw</span><span class="delimiter">:</span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P1, s)#(P1, t) # xs) ! length ((P1, t) #xs)) = LanguageCon.com.Throw&quot;</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>             </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P1, s)#(P1, t) # xs)) = Normal t&#39;&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>             </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seq_lift</span><span class="delimiter">:</span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq P1 P2, t) # map (lift P2) xs = map (lift P2) ((P1, t) # xs)&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a1</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>             
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>last_throw</span><span> </span><span>last_normal</span><span> </span><span>all_step</span><span> </span><span>eq_P</span><span>         
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>clarify</span><span class="delimiter">,</span><span> </span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>append_Cons</span><span> </span><span>env_normal_s&#39;_normal_s</span><span>  </span><span>step_e</span><span class="delimiter">)</span><span>                 
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>force</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lift_eq_xs_xs&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (lift a) xs = map (lift a) xs&#39; &#10233; xs=xs&#39;&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(lift a) x # map (lift a) xsa = map (lift a) (x # xsa)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span>xsa&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; = x&#39;#xsa&#39;&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (lift a) (x # xsa) =map (lift a) (x&#39; # xsa&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xsa=xsa&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(lift a) x&#39; = (lift a) x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; = x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.inject</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>               </span><span>case_prod_beta</span><span> </span><span>old.prod.inject</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lift_catch_eq_xs_xs&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch a) xs = map (lift_catch a) xs&#39; &#10233; xs=xs&#39;&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(lift_catch a) x # map (lift_catch a) xsa = map (lift_catch a) (x # xsa)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>x&#39;</span><span> </span><span>xsa&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; = x&#39;#xsa&#39;&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch a) (x # xsa) =map (lift_catch a) (x&#39; # xsa&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xsa=xsa&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(lift_catch a) x&#39; = (lift_catch a) x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#39; = x&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.inject</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> 
</span><span>               </span><span>case_prod_beta</span><span> </span><span>old.prod.inject</span><span> </span><span>prod.collapse</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lift_all_seq</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=map (lift a) xs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length zs&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;b. fst (zs!i) = Seq b a&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>zs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>z1</span><span> </span><span>zsa</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z1 # zsa = map (&#955;b. case b of (P, s) &#8658; (LanguageCon.com.Seq P a, s)) xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p c. &#8707;x. &#8704;pa ca xa. 
            (pa &#8800; (ca::(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com, xa::(&#39;a, &#39;c) xstate) &#8744; ca = fst pa) &#8743; 
            ((c::(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com) &#8800; fst p &#8744; (c, x::(&#39;a, &#39;c) xstate) = p)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#8658; (&#39;a, &#39;c) xstate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;p c x ca pa. (p &#8800; (c::(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com, x::(&#39;a, &#39;c) xstate) &#8744; c = fst p) &#8743; (ca &#8800; fst pa &#8744; (ca, xx pa ca) = pa)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length (z1 # zsa)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>case_prod_beta&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lift_catch_all_catch</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=map (lift_catch a) xs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length zs&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;b. fst (zs!i) = Catch b a&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>zs</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span> </span><span>i</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>z1</span><span> </span><span>zsa</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;z1 # zsa = map (&#955;b. case b of (P, s) &#8658; (LanguageCon.com.Catch P a, s)) xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p c. &#8707;x. &#8704;pa ca xa. 
            (pa &#8800; (ca::(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com, xa::(&#39;a, &#39;c) xstate) &#8744; ca = fst pa) &#8743; 
            ((c::(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com) &#8800; fst p &#8744; (c, x::(&#39;a, &#39;c) xstate) = p)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xx</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate &#8658; (&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#8658; (&#39;a, &#39;c) xstate&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;p c x ca pa. (p &#8800; (c::(&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com, x::(&#39;a, &#39;c) xstate) &#8744; c = fst p) &#8743; (ca &#8800; fst pa &#8744; (ca, xx pa ca) = pa)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>  
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;i &lt; length (z1 # zsa)&#8250;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.hyps</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>case_prod_beta&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lift_some_eq_pos</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (lift P) xs @ (P1, s1)#ys = 
             map (lift P) xs&#39;@ (P2, s2)#ys&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p0. P1&#8800;Seq p0 P&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p0. P2&#8800;Seq p0 P&quot;</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length xs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs &#8800; length xs&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs &lt; length xs&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>  </span><span>map_lift_all_seq</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>length_map</span><span> </span><span>nth_append</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span class="delimiter">=</span><span>this</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs &gt; length xs&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>  </span><span>map_lift_all_seq</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>length_map</span><span> </span><span>nth_append</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lift_some_eq</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (lift P) xs @ (P1, s1)#ys = 
             map (lift P) xs&#39;@ (P2, s2)#ys&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p0. P1&#8800;Seq p0 P&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p0. P2&#8800;Seq p0 P&quot;</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; = xs &#8743; ys = ys&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>map_lift_some_eq_pos</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; = xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>assms</span><span> </span><span>calculation</span><span> </span><span>map_lift_eq_xs_xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lift_catch_some_eq_pos</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch P) xs @ (P1, s1)#ys = 
             map (lift_catch P) xs&#39;@ (P2, s2)#ys&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p0. P1&#8800;Catch p0 P&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p0. P2&#8800;Catch p0 P&quot;</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length xs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs &#8800; length xs&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs &lt; length xs&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>  </span><span>map_lift_catch_all_catch</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>length_map</span><span> </span><span>nth_append</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span class="delimiter">=</span><span>this</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs &gt; length xs&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span>  </span><span>map_lift_catch_all_catch</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>length_map</span><span> </span><span>nth_append</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_lift_catch_some_eq</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch P) xs @ (P1, s1)#ys = 
             map (lift_catch P) xs&#39;@ (P2, s2)#ys&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p0. P1&#8800;Catch p0 P&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p0. P2&#8800;Catch p0 P&quot;</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; = xs &#8743; ys = ys&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>map_lift_catch_some_eq_pos</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#39; = xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>assms</span><span> </span><span>calculation</span><span> </span><span>map_lift_catch_eq_xs_xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_P_Not_finish</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>   </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift Q) xs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(LanguageCon.com.Seq P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs= map (lift Q) xs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift Q) xs&#39; = 
              map (lift Q) xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_lift_eq_xs_xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
         fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, s) # xs&#39;)) = Normal s&#39; &#8743;
         s = Normal s&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @ (LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>     </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
        (&#8707;ys. (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift Q) xs&#39;))) =
                   Q&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length zs = length (map (lift Q) xs&#39; @
         (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length (map (lift Q) xs&#39;)) &lt; 
                  length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>zs_while</span><span> </span><span>map_lift_all_seq</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>     
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, s) # xs&#39;)) = Normal s&#39; &#8743;
         s = Normal s&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @ (LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>            </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift Q) xs&#39; @ 
                 (LanguageCon.com.Throw, Normal s&#39;) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift Q) xs&#39;))) = Throw&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length zs = length (map (lift Q) xs&#39; @(LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length (map (lift Q) xs&#39;)) &lt; 
                  length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>zs_while</span><span> </span><span>map_lift_all_seq</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_P_Ends_Normal</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>   </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift Q) xs @ (Q, snd (last ((P, s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a0&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P, s) # xs)) = Skip&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(LanguageCon.com.Seq P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs&#39; &#8743; (m,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs= map (lift Q) xs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift Q) xs&#39; = 
              map (lift Q) xs @ (Q, snd (last ((P, s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift Q) xs))) = Q&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a0</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length zs = 
             length (map (lift Q) xs @ (Q, snd (last ((P, s) # xs))) # ys)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length (map (lift Q) xs)) &lt; length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>zs_while</span><span> </span><span>map_lift_all_seq</span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
         fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, s) # xs&#39;)) = Normal s&#39; &#8743;
         s = Normal s&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @ (LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>     </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
        (&#8707;ys. (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys&#39; &#8743;
             (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>map_lift_some_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>Q</span><span> </span><span>xs</span><span> </span><span>Q</span><span> </span><span>_</span><span> </span><span>ys</span><span> </span><span>xs&#39;</span><span> </span><span>Q</span><span> </span><span>_</span><span> </span><span>ys&#39;</span><span class="delimiter">]</span><span> 
</span><span>               </span><span>zs</span><span>  </span><span>a0</span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>Q</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>               
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, s) # xs&#39;)) = Normal s&#39; &#8743;
         s = Normal s&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @ (LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift Q) xs&#39; @ (LanguageCon.com.Throw, Normal s&#39;) # ys&#39; &#8743;
             (m, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift Q) xs&#39;))) = Throw&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>       
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>71</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>a0</span><span> </span><span>a0&#39;</span><span> </span><span>ass</span><span> </span><span>last_length</span><span>
</span><span>              </span><span>map_lift_some_eq</span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>zs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq_P_Ends_Abort</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>   </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift Q) xs @ (Throw, Normal s&#39;) # ys&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a0&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P, Normal s) # xs)) = Throw&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a0&#39;&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd(last ((P, Normal s) # xs)) = Normal s&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(LanguageCon.com.Seq P Q, Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest zs Q xs&#39; P (Normal s) ns&#39;&#39; ns&#39; &#915; m&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs&#39; &#8743; (m,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs= map (lift Q) xs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift Q) xs&#39; = 
              map (lift Q) xs @ (Throw, Normal s&#39;) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift Q) xs))) = Throw&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a0</span><span>  </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length zs = 
             length (map (lift Q) xs @ (Throw, Normal s&#39;) # ys)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length (map (lift Q) xs)) &lt; length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>zs_while</span><span> </span><span>map_lift_all_seq</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.simps</span><span class="delimiter">(</span><span>82</span><span class="delimiter">)</span><span class="delimiter">)</span><span>    
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, Normal s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys)
          &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @
              (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
         fst (((P, Normal s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, Normal s) # xs&#39;)) = Normal ns&#39; &#8743;
         Normal s = Normal ns&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Throw, Normal ns&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
            zs = map (lift Q) xs&#39; @ (LanguageCon.com.Throw, Normal ns&#39;) # ys)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>     </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, Normal s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys)
          &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift Q) xs&#39; @
              (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys&#39;)
               &#8712; cptn_mod_nest_call &#8743;
            zs = map (lift Q) xs&#39; @ 
              (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys&#39;&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>Q</span><span class="delimiter">]</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>71</span><span class="delimiter">)</span><span> 
</span><span>             </span><span>a0&#39;</span><span> </span><span>ass</span><span> </span><span>last_length</span><span> </span><span>map_lift_some_eq</span><span class="delimiter">)</span><span>                        
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, Normal s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, Normal s) # xs&#39;)) = Normal ns&#39; &#8743;
         Normal s = Normal ns&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Throw, Normal ns&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
            zs = map (lift Q) xs&#39; @ (LanguageCon.com.Throw, Normal ns&#39;) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (LanguageCon.com.Throw, Normal ns&#39;) # ys&#39;) &#8712; cptn_mod_nest_call &#8743;
            zs = map (lift Q) xs&#39; @ (LanguageCon.com.Throw, Normal ns&#39;) # ys&#39;&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift Q) xs&#39;))) = Throw&quot;</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>             
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>ass</span><span> </span><span>map_lift_some_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Catch_P_Not_finish</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>   </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch Q) xs&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>   
</span><span>   </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>catch_cond_nest_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs= map (lift_catch Q) xs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch Q) xs&#39; = 
              map (lift_catch Q) xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_lift_catch_eq_xs_xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;
         fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, s) # xs&#39;)) = Normal s&#39; &#8743;
         s = Normal s&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
         fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>     </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys) &#8712; cptn_mod_nest_call &#8743;
            zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift_catch Q) xs&#39;))) = Skip &quot;</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length zs = length (map (lift Q) xs&#39; @
         (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length (map (lift Q) xs&#39;)) &lt; 
                  length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>zs_while</span><span> </span><span>map_lift_catch_all_catch</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>     
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, s) # xs&#39;)) = Normal s&#39; &#8743;
         s = Normal s&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>            </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift Q) xs&#39;))) = Q&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>eq_fst_iff</span><span> </span><span>length_map</span><span> </span><span>nth_append_length</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length zs = length (map (lift Q) xs&#39; @(LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length (map (lift Q) xs&#39;)) &lt; 
                  length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>zs_while</span><span> </span><span>map_lift_catch_all_catch</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Catch_P_Ends_Normal</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>   </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch Q) xs @ (Q, snd (last ((P, Normal s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a0&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P, Normal s) # xs)) = Throw&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a0&#39;&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P, Normal s) # xs)) = Normal s&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest zs Q xs&#39; P (Normal s) ns&#39;&#39; ns&#39; &#915; m&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs&#39; &#8743; (m,&#915;,(Q, snd(((P, Normal s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>catch_cond_nest_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs= map (lift_catch Q) xs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch Q) xs&#39; = 
              map (lift_catch Q) xs @ (Q, snd (last ((P, Normal s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift_catch Q) xs))) = Q&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a0</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length zs = 
             length (map (lift_catch Q) xs @ (Q, snd (last ((P, Normal s) # xs))) # ys)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length (map (lift_catch Q) xs)) &lt; length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>zs_while</span><span> </span><span>map_lift_catch_all_catch</span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, Normal s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, Normal s) # xs&#39;)) = Normal ns&#39; &#8743;
         Normal s = Normal ns&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
         fst (((P, Normal s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Skip, snd (last ((P, Normal s) # xs&#39;))) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, Normal s) # xs&#39;))) # ys)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>     </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, Normal s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Skip, snd (last ((P, Normal s) # xs&#39;))) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, Normal s) # xs&#39;))) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (LanguageCon.com.Skip, snd (last ((P, Normal s) # xs&#39;))) # ys&#39;) &#8712; cptn_mod_nest_call &#8743;
             zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, Normal s) # xs&#39;))) # ys&#39;&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>map_lift_catch_some_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>Q</span><span> </span><span>xs</span><span> </span><span>Q</span><span> </span><span>_</span><span> </span><span>ys</span><span> </span><span>xs&#39;</span><span> </span><span>Skip</span><span> </span><span>_</span><span> </span><span>ys&#39;</span><span class="delimiter">]</span><span> 
</span><span>               </span><span>zs</span><span>  </span><span>a0</span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>Q</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>19</span><span class="delimiter">)</span><span> </span><span>a0&#39;</span><span> </span><span>ass</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>                        
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, Normal s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
                snd (last ((P, Normal s) # xs&#39;)) = Normal ns&#39; &#8743;
                Normal s = Normal ns&#39;&#39; &#8743;
                (&#8707;ys. (m, &#915;, (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys&#39;) &#8712; cptn_mod_nest_call &#8743;
                zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, Normal s) # xs&#39;) ! length xs&#39;)) # ys&#39;&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift_catch Q) xs&#39;))) = Q&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>       
</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>71</span><span class="delimiter">)</span><span> 
</span><span>            </span><span>a0</span><span> </span><span>a0&#39;</span><span> </span><span>ass</span><span> </span><span>last_length</span><span> </span><span>map_lift_catch_some_eq</span><span class="delimiter">[</span><span>of</span><span> </span><span>Q</span><span> </span><span>xs</span><span> </span><span>Q</span><span> </span><span>_</span><span> </span><span>ys</span><span> </span><span>xs&#39;</span><span> </span><span>Q</span><span> </span><span>_</span><span> </span><span>ys&#39;</span><span class="delimiter">]</span><span>  
</span><span>            </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span> </span><span>zs</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Catch_P_Ends_Skip</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>   </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch Q) xs @ (Skip, snd (last ((P, s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a0&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P,s) # xs)) = Skip&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest zs Q xs&#39; P s ns&#39;&#39; ns&#39; &#915; m&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs&#39; &#8743; (m,&#915;,(Skip,snd(last ((P,s) # xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>catch_cond_nest_def</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs= map (lift_catch Q) xs&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch Q) xs&#39; = 
              map (lift_catch Q) xs @ (Skip, snd (last ((P, s) # xs))) # ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift_catch Q) xs))) = Skip&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a0</span><span>  </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length zs = 
             length (map (lift_catch Q) xs @ (Skip, snd (last ((P, s) # xs))) # ys)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length (map (lift_catch Q) xs)) &lt; length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>zs_while</span><span> </span><span>map_lift_catch_all_catch</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>19</span><span class="delimiter">)</span><span class="delimiter">)</span><span>    
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>    </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, s) # xs&#39;)) = Normal ns&#39; &#8743;
         s = Normal ns&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
         fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> 
</span><span>     </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Skip &#8743;
         (&#8707;ys. (m, &#915;, (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys&#39;) &#8712; cptn_mod_nest_call &#8743;
             zs = map (lift_catch Q) xs&#39; @ (LanguageCon.com.Skip, snd (last ((P, s) # xs&#39;))) # ys&#39;&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>a0&#39;</span><span> </span><span>ass</span><span> </span><span>last_length</span><span> </span><span>map_lift_catch_some_eq</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>19</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>                
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P, s) # xs&#39;) ! length xs&#39;) = LanguageCon.com.Throw &#8743;
         snd (last ((P, s) # xs&#39;)) = Normal ns&#39; &#8743;
         s = Normal ns&#39;&#39; &#8743;
         (&#8707;ys. (m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys&#39;) &#8712; cptn_mod_nest_call &#8743;
         zs = map (lift_catch Q) xs&#39; @ (Q, snd (((P, s) # xs&#39;) ! length xs&#39;)) # ys&#39;&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs_while</span><span class="delimiter">:</span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;fst (zs!(length (map (lift_catch Q) xs&#39;))) = Q&quot;</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>fstI</span><span> </span><span>nth_append_length</span><span class="delimiter">)</span><span>             
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>12</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>Q</span><span class="delimiter">]</span><span> </span><span>a0&#39;</span><span> </span><span>ass</span><span> </span><span>last_length</span><span> </span><span>map_lift_catch_some_eq</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>19</span><span class="delimiter">)</span><span class="delimiter">)</span><span>               
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>func_redex_cptn_mod_nest_inc</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594; (Q, t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;redex P = Call fn &#8743; &#915; fn = Some bdy &#8743; s =Normal sa&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;,(P,s)#(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Basicc</span><span> </span><span>f</span><span> </span><span>s</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Basicc</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.Basicc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Specc</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Specc</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.Specc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SpecStuckc</span><span> </span><span>s</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SpecStuckc</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.SpecStuckc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Guardc</span><span> </span><span>s</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>c</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestGuard</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>GuardFaultc</span><span> </span><span>s</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>GuardFaultc</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.GuardFaultc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seqc</span><span> </span><span>c1</span><span> </span><span>s</span><span> </span><span>c1&#39;</span><span> </span><span>s&#39;</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c1, s) &#8594; (c1&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nsc1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c1&#8800;Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Seq c1&#39; c2, s&#39;) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divseq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Seq c1&#39; c2, s&#39;) # xs=(Seq P Q, s)#zs &#10230;
                (&#8707;xs sv&#39; sv&#39;&#39;. ((n,&#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
                           (zs=(map (lift Q) xs) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
                             (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                              zs=(map (lift (Q)) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Throw &#8743; 
                               snd(last ((P, s)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
                             (&#8707;ys.  (n,&#915;,(Throw,Normal sv&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                              zs=(map (lift Q) xs)@((Throw,Normal sv&#39;)#ys))
                               ))))
                            
                 ))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assum</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;) # xs = (Seq P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c1&#39; = P &#8743; c2 = Q &#8743; s&#39; = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs sv&#39; sv&#39;&#39;. (n,&#915;, (P, sa) # xs) &#8712; cptn_mod_nest_call &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P, sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (n,&#915;, (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, sa)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
                          (&#8707;ys.  (n,&#915;,(Throw,Normal sv&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                              zsa=(map (lift Q) xs)@((Throw,Normal sv&#39;)#ys))))))&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divseq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c1&#39;</span><span> </span><span>c2</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span class="delimiter">]</span><span>    
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>sa&#39;</span><span> </span><span>sa&#39;&#39;</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>split</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call &#8743;
                     (xs = map (lift c2) xs&#39; &#8744;                   
                     fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                        (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                         xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
                     ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                         snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743; s&#39;=Normal sa&#39;&#39;&#8743;
                         (&#8707;ys.  (n,&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                              xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))
                         )))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift c2) xs&#39; &#8744;                   
                   fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                      (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                       xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
                   ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                       snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743; s&#39;=Normal sa&#39;&#39;&#8743;
                       (&#8707;ys.  (n,&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                            xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys)))))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span>           
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c1&#39;nonf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift c2) xs&#39;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Seqc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;)#xs = map (lift c2) ((c1&#39;, s&#39;)#xs&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestSeq1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
              (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                  xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
             ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743;  s&#39;=Normal sa&#39;&#39;&#8743;
                (&#8707;ys.  (n,&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                              xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assth</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
            (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>           </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>cptn_mod_nest_mono1</span><span class="delimiter">)</span><span>
</span><span>           
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Seqc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>                
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1 c2, s)#(Seq c1&#39; c2, s&#39;)#xs = map (lift c2) ((c1,s)#(c1&#39;, s&#39;)#xs&#39;) @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>lift_def</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Skip&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>          
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seqmap</span><span> </span><span>split&#39;</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span>
</span><span>              </span><span>induct_step</span><span> </span><span>lastc1</span><span> </span><span>lastc1skip</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Cons_lift_append</span><span> </span><span class="delimiter">)</span><span>               
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743;  s&#39;=Normal sa&#39;&#39;&#8743;
                (&#8707;ys.(n,&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                 xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Normal sa&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snormal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ns. s=Normal ns&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_Abrupt_prop</span><span> </span><span>step_Fault_prop</span><span> </span><span>step_Stuck_prop</span><span> </span><span>xstate.exhaust</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Seqc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;)#xs = (map (lift c2) ((c1&#39;, s&#39;)#xs&#39;))@((Throw,Normal sa&#39;)#ys)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;ys. (LanguageCon.com.Seq c1&#39; c2, s&#39;) # xs = map (lift c2) ((c1&#39;, s&#39;) # xs&#39;) @ (LanguageCon.com.Throw, Normal sa&#39;) # ys &#10233; thesis&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq c1&#39; c2, Normal sa&#39;&#39;) # map (lift c2) xs&#39; = map (lift c2) ((c1&#39;, s&#39;) # xs&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assm</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>                   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Throw&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>        
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span>lastc1skip</span><span> </span><span>snormal</span><span> </span><span>seqmap</span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Cons_lift_append</span><span> </span><span>One_nat_def</span><span> </span><span>add.right_neutral</span><span> </span><span>add_Suc_right</span><span> 
</span><span>              </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span>cptn_mod_nest_mono1</span><span class="delimiter">)</span><span>             
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SeqSkipc</span><span> </span><span>c2</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2incptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (c2, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SeqSkipc.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_mono1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, [(Skip, s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ([(Skip, s)])) = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;,(c2, snd(last [(Skip, s)]))#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c2incptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2,s)#xs=(map (lift c2) [])@(c2, snd(last [(Skip, s)]))#xs&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestSeq2</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SeqThrowc</span><span> </span><span>c2</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, [(Throw, Normal s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>ys_nil</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;ys=[]&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1, &#915;, (Throw, Normal s)#ys)&#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Throw, Normal s)#ys)) = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Throw, Normal s)#ys)) = Normal s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ys_nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (lift c2) ys) = []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SeqThrowc.prems</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>      
</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CondTruec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestCondT</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CondFalsec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestCondF</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WhileTruec</span><span> </span><span>s1</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sinb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s1&#8712;b&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SeqcWhile</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (Seq c (While b c), Normal s1) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>  
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divseq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Seq c (While b c), Normal s1) # xs=(Seq P Q, s)#zs &#10230;
                (&#8707;xs s&#39;. ((n,&#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
                           (zs=(map (lift Q) xs) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
                             (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                              zs=(map (lift (Q)) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Throw &#8743; 
                               snd(last ((P, s)#xs)) = Normal s&#39; &#8743;
                              (&#8707;ys.  (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                      zs=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))))))                            
                 ))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>SeqcWhile</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_cond_nest_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c (While b c), Normal s1) # xs = (Seq P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c = P &#8743; (While b c) = Q &#8743; Normal s1 = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39;. (n,&#915;, (P, sa) # xs) &#8712; cptn_mod_nest_call &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P, sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (n,&#915;, (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, sa)#xs)) = Normal s&#39; &#8743;
                          (&#8707;ys.  (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                      zsa=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))
                        ))))&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divseq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;While b c&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Normal s1&quot;</span></span></span><span> </span><span>xs</span><span class="delimiter">]</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>split</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod_nest_call &#8743;
     (xs = map (lift (While b c)) xs&#39; &#8744;
      fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
      (&#8707;ys. (n,&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
            &#8712; cptn_mod_nest_call &#8743;
            xs =
            map (lift (While b c)) xs&#39; @
            (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
      fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
      snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743; 
      (&#8707;ys.  (n,&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod_nest_call &#8743;
      xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys)))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift (While b c)) xs&#39; &#8744;
            fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
            (&#8707;ys. (n,&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
                  &#8712; cptn_mod_nest_call &#8743;
                  xs =
                  map (lift (While b c)) xs&#39; @
                  (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
            fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
            snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
            (&#8707;ys.  (n,&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod_nest_call &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift (While b c)) xs&#39;&quot;</span></span></span><span>  
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1&quot;</span></span></span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile1</span><span> </span><span>sinb</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>WhileTruec.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (n,&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
                &#8712; cptn_mod_nest_call &#8743;
                xs =
                map (lift (While b c)) xs&#39; @
                (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
          (&#8707;ys.  (n,&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod_nest_call &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
             (&#8707;ys. (n,&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
             &#8712; cptn_mod_nest_call &#8743;
             xs =
             map (lift (While b c)) xs&#39; @
             (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>asm&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (While b c, snd (last ((c, Normal s1) # xs&#39;))) # ys)
                   &#8712; cptn_mod_nest_call 
                   &#8743; xs = map (lift (While b c)) xs&#39; @
                       (While b c, snd (last ((c, Normal s1) # xs&#39;))) # ys&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c, Normal s1) # xs&#39;))  = Skip&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sinb</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>WhileTruec.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
          (&#8707;ys.  (n,&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod_nest_call &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys))&quot;</span></span></span><span>   
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c, Normal s1) # xs&#39;))  = Throw&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sinb</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>WhileTruec.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WhileFalsec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.WhileFalsec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Awaitc</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.Awaitc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>AwaitAbruptc</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>t</span><span> </span><span>t&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestThrow</span><span> </span><span>stepc.AwaitAbruptc</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Callc</span><span> </span><span>p</span><span> </span><span>bdy</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cptn_mod_nest_call.CptnModNestCall</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CallUndefinedc</span><span> </span><span>p</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.CallUndefinedc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>DynComc</span><span> </span><span>c</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestDynCom</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catchc</span><span> </span><span>c1</span><span> </span><span>s</span><span> </span><span>c1&#39;</span><span> </span><span>s&#39;</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c1, s) &#8594; (c1&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nsc1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c1&#8800;Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (Catch c1&#39; c2, s&#39;) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divcatch</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Catch c1&#39; c2, s&#39;) # xs=(Catch P Q, s)#zs &#10230;
  (&#8707;xs s&#39; s&#39;&#39;. ((n,&#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
             (zs=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, s)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
               (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                zs=(map (lift_catch Q) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                ((fst(((P, s)#xs)!length xs)=Skip &#8743;  
                  (&#8707;ys. (n,&#915;,(Skip,snd(last ((P, s)#xs)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 zs=(map (lift_catch Q) xs)@((Skip,snd(last ((P, s)#xs)))#ys))                
                 ))))
   ))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_catch_nest</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assum</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>catch_cond_nest_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;) # xs = (Catch P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c1&#39; = P &#8743; c2 = Q &#8743; s&#39; = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs sv&#39; sv&#39;&#39;. ((n, &#915;,(P, sa)#xs) &#8712; cptn_mod_nest_call  &#8743; 
             (zsa=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, sa)#xs)!length xs)=Throw &#8743;
               snd(last ((P, sa)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
               (&#8707;ys. (n,&#915;,(Q, snd(((P, sa)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                zsa=(map (lift_catch Q) xs)@((Q, snd(((P, sa)#xs)!length xs))#ys)))) &#8744;
                ((fst(((P, sa)#xs)!length xs)=Skip &#8743;                  
                 (&#8707;ys. (n,&#915;,(Skip,snd(last ((P, sa)#xs)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 zsa=(map (lift_catch Q) xs)@((Skip,snd(last ((P, sa)#xs)))#ys))))))
   )&quot;</span></span></span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divcatch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c1&#39;</span><span> </span><span>c2</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span class="delimiter">]</span><span>    
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>sa&#39;</span><span> </span><span>sa&#39;&#39;</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call &#8743; 
          (xs = map (lift_catch c2) xs&#39; &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
          (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift_catch c2) xs&#39; @
                (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (n,&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)))&quot;</span></span></span><span>          
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift_catch c2) xs&#39; &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
          (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift_catch c2) xs&#39; @
                (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (n,&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)))&quot;</span></span></span><span>          
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span>           
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c1&#39;nonf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift_catch c2) xs&#39;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1, &#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Catchc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;)#xs = map (lift_catch c2) ((c1&#39;, s&#39;)#xs&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModCatch1</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestCatch1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
                snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
                (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
               fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                (&#8707;ys. (n,&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assth</span><span class="delimiter">:</span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
                snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
                (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Normal sa&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snormal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ns. s=Normal ns&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_Abrupt_prop</span><span> </span><span>step_Fault_prop</span><span> </span><span>step_Stuck_prop</span><span> </span><span>xstate.exhaust</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>             </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Suc_eq_plus1</span><span> </span><span>cptn_mod_nest_mono1</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Catchc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>                
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1 c2, s)#(Catch c1&#39; c2, s&#39;)#xs = map (lift_catch c2) ((c1,s)#(c1&#39;, s&#39;)#xs&#39;) @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModCatch3</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Throw&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snormal</span><span> </span><span>seqmap</span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span> </span><span>split&#39;</span><span> 
</span><span>              </span><span>last_length</span><span>  </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span> 
</span><span>              </span><span>induct_step</span><span> </span><span>lastc1</span><span> </span><span>lastc1skip</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_lift_catch_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>           
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743; 
                       (&#8707;ys. (n,&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                      xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Catchc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch c2) ((c1&#39;, s&#39;) # xs&#39;) = (Catch c1&#39; c2, s&#39;) # map (lift_catch c2) xs&#39;&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>             </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;)#xs = (map (lift_catch c2) ((c1&#39;, s&#39;)#xs&#39;))@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>                   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Skip&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = snd (last ((c1&#39;, s&#39;) # xs&#39;))&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span>lastc1skip</span><span> </span><span>seqmap</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Cons_lift_catch_append</span><span> </span><span>One_nat_def</span><span> </span><span>add.right_neutral</span><span> </span><span>add_Suc_right</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span> </span><span>cptn_mod_nest_mono1</span><span class="delimiter">)</span><span> 
</span><span>            
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>              
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CatchThrowc</span><span> </span><span>c2</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2incptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c2, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, [(Throw, Normal s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ([(Throw, Normal s)])) = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;,(c2, snd(last [(Throw, Normal s)]))#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c2incptn</span><span> </span><span>cptn_mod_nest_mono1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2,Normal s)#xs=(map (lift c2) [])@(c2, snd(last [(Throw, Normal s)]))#xs&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CatchSkipc</span><span> </span><span>c2</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, [(Skip, s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>ys_nil</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;ys=[]&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n+1,&#915;, (Skip,  s)#ys)&#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Skip,  s)#ys)) = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Skip,  s)#ys)) = s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ys_nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (lift_catch c2) ys) = []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CatchSkipc.prems</span><span> </span><span>cptn_mod_nest_mono1</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CatchSkipc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>FaultPropc</span><span> </span><span>c</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestCall</span><span> </span><span>stepc.FaultPropc</span><span class="delimiter">)</span><span>    
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>AbruptPropc</span><span> </span><span>c</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestSkip</span><span> </span><span>stepc.AbruptPropc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>StuckPropc</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestSkip</span><span> </span><span>stepc.StuckPropc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_func_redex_cptn_mod_nest_n&#39;</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594; (Q, t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;fn. redex P &#8800; Call fn) &#8744; 
            (redex P = Call fn &#8743; &#915; fn = None) &#8744; 
            (redex P = Call fn &#8743; (&#8704;sa. s&#8800;Normal sa))&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P,s)#(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Basicc</span><span> </span><span>f</span><span> </span><span>s</span><span class="delimiter">)</span><span>   
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Basicc</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.Basicc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Specc</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Specc</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.Specc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SpecStuckc</span><span> </span><span>s</span><span> </span><span>r</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SpecStuckc</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.SpecStuckc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Guardc</span><span> </span><span>s</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>c</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestGuard</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>GuardFaultc</span><span> </span><span>s</span><span> </span><span>g</span><span> </span><span>f</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>GuardFaultc</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.GuardFaultc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seqc</span><span> </span><span>c1</span><span> </span><span>s</span><span> </span><span>c1&#39;</span><span> </span><span>s&#39;</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c1, s) &#8594; (c1&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nsc1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c1&#8800;Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Seq c1&#39; c2, s&#39;) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divseq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Seq c1&#39; c2, s&#39;) # xs=(Seq P Q, s)#zs &#10230;
                (&#8707;xs sv&#39; sv&#39;&#39;. ((n,&#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
                           (zs=(map (lift Q) xs) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
                             (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                              zs=(map (lift (Q)) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Throw &#8743; 
                               snd(last ((P, s)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
                             (&#8707;ys.  (n,&#915;,(Throw,Normal sv&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                              zs=(map (lift Q) xs)@((Throw,Normal sv&#39;)#ys))
                               ))))
                            
                 ))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assum</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;) # xs = (Seq P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c1&#39; = P &#8743; c2 = Q &#8743; s&#39; = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs sv&#39; sv&#39;&#39;. (n,&#915;, (P, sa) # xs) &#8712; cptn_mod_nest_call &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P, sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (n,&#915;, (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, sa)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
                          (&#8707;ys.  (n,&#915;,(Throw,Normal sv&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                              zsa=(map (lift Q) xs)@((Throw,Normal sv&#39;)#ys))))))&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divseq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c1&#39;</span><span> </span><span>c2</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span class="delimiter">]</span><span>    
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>sa&#39;</span><span> </span><span>sa&#39;&#39;</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>split</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call &#8743;
                     (xs = map (lift c2) xs&#39; &#8744;                   
                     fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                        (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                         xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
                     ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                         snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743; s&#39;=Normal sa&#39;&#39;&#8743;
                         (&#8707;ys.  (n,&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                              xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))
                         )))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift c2) xs&#39; &#8744;                   
                   fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                      (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                       xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
                   ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                       snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743; s&#39;=Normal sa&#39;&#39;&#8743;
                       (&#8707;ys.  (n,&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                            xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys)))))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span>           
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c1&#39;nonf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift c2) xs&#39;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Seqc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;)#xs = map (lift c2) ((c1&#39;, s&#39;)#xs&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestSeq1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
              (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                  xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
             ((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743;  s&#39;=Normal sa&#39;&#39;&#8743;
                (&#8707;ys.  (n,&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                              xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assth</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
            (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>           </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Seqc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>                
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1 c2, s)#(Seq c1&#39; c2, s&#39;)#xs = map (lift c2) ((c1,s)#(c1&#39;, s&#39;)#xs&#39;) @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>lift_def</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Skip&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>          
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seqmap</span><span> </span><span>split&#39;</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span>
</span><span>              </span><span>induct_step</span><span> </span><span>lastc1</span><span> </span><span>lastc1skip</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Cons_lift_append</span><span> </span><span class="delimiter">)</span><span>               
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;((fst(((c1&#39;, s&#39;)#xs&#39;)!length xs&#39;)=Throw &#8743; 
                snd(last ((c1&#39;, s&#39;)#xs&#39;)) = Normal sa&#39; &#8743;  s&#39;=Normal sa&#39;&#39;&#8743;
                (&#8707;ys.(n,&#915;,(Throw,Normal sa&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                 xs=(map (lift c2) xs&#39;)@((Throw,Normal sa&#39;)#ys))))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Normal sa&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snormal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ns. s=Normal ns&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_Abrupt_prop</span><span> </span><span>step_Fault_prop</span><span> </span><span>step_Stuck_prop</span><span> </span><span>xstate.exhaust</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seqc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Seqc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c1&#39; c2, s&#39;)#xs = (map (lift c2) ((c1&#39;, s&#39;)#xs&#39;))@((Throw,Normal sa&#39;)#ys)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;ys. (LanguageCon.com.Seq c1&#39; c2, s&#39;) # xs = map (lift c2) ((c1&#39;, s&#39;) # xs&#39;) @ (LanguageCon.com.Throw, Normal sa&#39;) # ys &#10233; thesis&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq c1&#39; c2, Normal sa&#39;&#39;) # map (lift c2) xs&#39; = map (lift c2) ((c1&#39;, s&#39;) # xs&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assm</span><span> </span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>                   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Throw&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>        
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span>lastc1skip</span><span> </span><span>snormal</span><span> </span><span>seqmap</span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SeqSkipc</span><span> </span><span>c2</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2incptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c2, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, [(Skip, s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ([(Skip, s)])) = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(c2, snd(last [(Skip, s)]))#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c2incptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2,s)#xs=(map (lift c2) [])@(c2, snd(last [(Skip, s)]))#xs&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestSeq2</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>SeqThrowc</span><span> </span><span>c2</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, [(Throw, Normal s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>ys_nil</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;ys=[]&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Throw, Normal s)#ys)&#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Throw, Normal s)#ys)) = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Throw, Normal s)#ys)) = Normal s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ys_nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (lift c2) ys) = []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SeqThrowc.prems</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>      
</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CondTruec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestCondT</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CondFalsec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestCondF</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WhileTruec</span><span> </span><span>s1</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>sinb</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s1&#8712;b&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>SeqcWhile</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (Seq c (While b c), Normal s1) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>  
</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divseq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Seq c (While b c), Normal s1) # xs=(Seq P Q, s)#zs &#10230;
                (&#8707;xs s&#39;. ((n,&#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
                           (zs=(map (lift Q) xs) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Skip &#8743; 
                             (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                              zs=(map (lift (Q)) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                           ((fst(((P, s)#xs)!length xs)=Throw &#8743; 
                               snd(last ((P, s)#xs)) = Normal s&#39; &#8743;
                              (&#8707;ys.  (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                      zs=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))))))                            
                 ))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>SeqcWhile</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>seq_cond_nest_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq c (While b c), Normal s1) # xs = (Seq P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c = P &#8743; (While b c) = Q &#8743; Normal s1 = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs s&#39;. (n,&#915;, (P, sa) # xs) &#8712; cptn_mod_nest_call &#8743;
                        (zsa = map (lift Q) xs &#8744;              
                         fst (((P, sa) # xs) ! length xs) = Skip &#8743;
                             (&#8707;ys. (n,&#915;, (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                             zsa = map (lift Q) xs @ (Q, snd (((P, sa) # xs) ! length xs)) # ys) &#8744;
                        ((fst(((P, sa)#xs)!length xs)=Throw &#8743; 
                          snd(last ((P, sa)#xs)) = Normal s&#39; &#8743;
                          (&#8707;ys.  (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743;
                      zsa=(map (lift Q) xs)@((Throw,Normal s&#39;)#ys))
                        ))))&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divseq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;While b c&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Normal s1&quot;</span></span></span><span> </span><span>xs</span><span class="delimiter">]</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> 
</span><span>        </span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>split</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod_nest_call &#8743;
     (xs = map (lift (While b c)) xs&#39; &#8744;
      fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
      (&#8707;ys. (n,&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
            &#8712; cptn_mod_nest_call &#8743;
            xs =
            map (lift (While b c)) xs&#39; @
            (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
      fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
      snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743; 
      (&#8707;ys.  (n,&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod_nest_call &#8743;
      xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys)))&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift (While b c)) xs&#39; &#8744;
            fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
            (&#8707;ys. (n,&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
                  &#8712; cptn_mod_nest_call &#8743;
                  xs =
                  map (lift (While b c)) xs&#39; @
                  (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
            fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
            snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
            (&#8707;ys.  (n,&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod_nest_call &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">..</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span> </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift (While b c)) xs&#39;&quot;</span></span></span><span>  
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;1&quot;</span></span></span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile1</span><span> </span><span>sinb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span> </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (n,&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
                &#8712; cptn_mod_nest_call &#8743;
                xs =
                map (lift (While b c)) xs&#39; @
                (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
          (&#8707;ys.  (n,&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod_nest_call &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Skip &#8743;
             (&#8707;ys. (n,&#915;, (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)
             &#8712; cptn_mod_nest_call &#8743;
             xs =
             map (lift (While b c)) xs&#39; @
             (While b c, snd (((c, Normal s1) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>asm&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (While b c, snd (last ((c, Normal s1) # xs&#39;))) # ys)
                   &#8712; cptn_mod_nest_call 
                   &#8743; xs = map (lift (While b c)) xs&#39; @
                       (While b c, snd (last ((c, Normal s1) # xs&#39;))) # ys&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c, Normal s1) # xs&#39;))  = Skip&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sinb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModNestWhile2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; fst (((c, Normal s1) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c, Normal s1) # xs&#39;)) = Normal s&#39; &#8743;
          (&#8707;ys.  (n,&#915;, ((Throw, Normal s&#39;)#ys)) &#8712; cptn_mod_nest_call &#8743;
          xs = map (lift (While b c)) xs&#39; @ ((Throw, Normal s&#39;)#ys))&quot;</span></span></span><span>   
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c, Normal s1) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>asm</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c, Normal s1) # xs&#39;))  = Throw&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>sinb</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>CptnModNestWhile3</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>WhileFalsec</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.WhileFalsec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Awaitc</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>t</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.Awaitc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>AwaitAbruptc</span><span> </span><span>s</span><span> </span><span>b</span><span> </span><span>c</span><span> </span><span>t</span><span> </span><span>t&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestThrow</span><span> </span><span>stepc.AwaitAbruptc</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Callc</span><span> </span><span>p</span><span> </span><span>bdy</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CallUndefinedc</span><span> </span><span>p</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p = fn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CallUndefinedc</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Call fn &#8745;<span class="hidden">&#8681;</span><sub>g</sub><span class="hidden">&#8681;</span><sub>s</sub> (LanguageCon.com.Skip::(&#39;b, &#39;a, &#39;c,&#39;d) LanguageCon.com)) &#8800; Some LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>CallUndefinedc.hyps</span><span> </span><span>LanguageCon.com.inject</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>LanguageCon.inter_guards.simps</span><span class="delimiter">(</span><span>79</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(n, &#915;, (LanguageCon.com.Skip, Stuck) # xs) &#8712; cptn_mod_nest_call&#8250;</span></span></span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.CallUndefinedc</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>DynComc</span><span> </span><span>c</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestDynCom</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catchc</span><span> </span><span>c1</span><span> </span><span>s</span><span> </span><span>c1&#39;</span><span> </span><span>s&#39;</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c1, s) &#8594; (c1&#39;, s&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>nsc1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c1&#8800;Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>assum</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (Catch c1&#39; c2, s&#39;) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>divcatch</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;s P Q zs. (Catch c1&#39; c2, s&#39;) # xs=(Catch P Q, s)#zs &#10230;
  (&#8707;xs s&#39; s&#39;&#39;. ((n,&#915;,(P, s)#xs) &#8712; cptn_mod_nest_call  &#8743; 
             (zs=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, s)#xs)!length xs)=Throw &#8743;
               snd(last ((P, s)#xs)) = Normal s&#39; &#8743;  s=Normal s&#39;&#39;&#8743;
               (&#8707;ys. (n,&#915;,(Q, snd(((P, s)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                zs=(map (lift_catch Q) xs)@((Q, snd(((P, s)#xs)!length xs))#ys)))) &#8744;
                ((fst(((P, s)#xs)!length xs)=Skip &#8743;  
                  (&#8707;ys. (n,&#915;,(Skip,snd(last ((P, s)#xs)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 zs=(map (lift_catch Q) xs)@((Skip,snd(last ((P, s)#xs)))#ys))                
                 ))))
   ))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_catch_nest</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>assum</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>catch_cond_nest_def</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>sa</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>zsa</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;) # xs = (Catch P Q, sa) # zsa&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eqs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c1&#39; = P &#8743; c2 = Q &#8743; s&#39; = sa &#8743; xs = zsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs sv&#39; sv&#39;&#39;. ((n, &#915;,(P, sa)#xs) &#8712; cptn_mod_nest_call  &#8743; 
             (zsa=(map (lift_catch Q) xs) &#8744;
             ((fst(((P, sa)#xs)!length xs)=Throw &#8743;
               snd(last ((P, sa)#xs)) = Normal sv&#39; &#8743;  s&#39;=Normal sv&#39;&#39;&#8743;
               (&#8707;ys. (n,&#915;,(Q, snd(((P, sa)#xs)!length xs))#ys) &#8712; cptn_mod_nest_call &#8743; 
                zsa=(map (lift_catch Q) xs)@((Q, snd(((P, sa)#xs)!length xs))#ys)))) &#8744;
                ((fst(((P, sa)#xs)!length xs)=Skip &#8743;                  
                 (&#8707;ys. (n,&#915;,(Skip,snd(last ((P, sa)#xs)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 zsa=(map (lift_catch Q) xs)@((Skip,snd(last ((P, sa)#xs)))#ys))))))
   )&quot;</span></span></span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>divcatch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>conc</span><span class="delimiter">=</span><span>this</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>c1&#39;</span><span> </span><span>c2</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span class="delimiter">]</span><span>    
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>sa&#39;</span><span> </span><span>sa&#39;&#39;</span><span>
</span><span>       </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split</span><span class="delimiter">:</span><span>
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call &#8743; 
          (xs = map (lift_catch c2) xs&#39; &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
          (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift_catch c2) xs&#39; @
                (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (n,&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)))&quot;</span></span></span><span>          
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs = map (lift_catch c2) xs&#39; &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
          snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
          (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs = map (lift_catch c2) xs&#39; @
                (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
          fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
          (&#8707;ys. (n,&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)))&quot;</span></span></span><span>          
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="keyword1"><span class="command">{</span></span><span>           
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>c1&#39;nonf</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs = map (lift_catch c2) xs&#39;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Catchc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;)#xs = map (lift_catch c2) ((c1&#39;, s&#39;)#xs&#39;)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModCatch1</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c1&#39;nonf</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestCatch1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
                snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
                (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8744;
               fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743;
                (&#8707;ys. (n,&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                 xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys))&quot;</span></span></span><span>  
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assth</span><span class="delimiter">:</span><span>
</span><span>               </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Throw &#8743;
                snd (last ((c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39; &#8743; s&#39; = Normal sa&#39;&#39; &#8743;
                (&#8707;ys. (n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#39;=Normal sa&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snormal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ns. s=Normal ns&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>step_Abrupt_prop</span><span> </span><span>step_Fault_prop</span><span> </span><span>step_Stuck_prop</span><span> </span><span>xstate.exhaust</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>             </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>split&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys) &#8712; cptn_mod_nest_call &#8743;
                xs =map (lift_catch c2) xs&#39; @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Catchc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>                
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1 c2, s)#(Catch c1&#39; c2, s&#39;)#xs = map (lift_catch c2) ((c1,s)#(c1&#39;, s&#39;)#xs&#39;) @ (c2, snd (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;)) # ys&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModCatch3</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Throw&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Normal sa&#39;&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>snormal</span><span> </span><span>seqmap</span><span> </span><span>s&#39;eqsa&#39;&#39;</span><span> </span><span>split&#39;</span><span> 
</span><span>              </span><span>last_length</span><span>  </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span> 
</span><span>              </span><span>induct_step</span><span> </span><span>lastc1</span><span> </span><span>lastc1skip</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_lift_catch_append</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>           
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>assm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; fst (((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;) = Skip &#8743; 
                       (&#8707;ys. (n,&#915;,(Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys) &#8712; cptn_mod_nest_call &#8743;                   
                      xs=(map (lift_catch c2) xs&#39;)@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c1&#39;cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1&#39;, s&#39;) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>split</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>induct_step</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s) # (c1&#39;, s&#39;)#xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catchc.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Catchc.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (lift_catch c2) ((c1&#39;, s&#39;) # xs&#39;) = (Catch c1&#39; c2, s&#39;) # map (lift_catch c2) xs&#39;&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> 
</span><span>             </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>seqmap</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch c1&#39; c2, s&#39;)#xs = (map (lift_catch c2) ((c1&#39;, s&#39;)#xs&#39;))@((Skip,snd(last ((c1&#39;, s&#39;)#xs&#39;)))#ys)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;) = ((c1&#39;, s&#39;) # xs&#39;) ! length xs&#39;&quot;</span></span></span><span>
</span><span>                   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lastc1skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = Skip&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((c1, s) # (c1&#39;, s&#39;) # xs&#39;)) = snd (last ((c1&#39;, s&#39;) # xs&#39;))&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm</span><span> </span><span>c1&#39;cptn</span><span> </span><span>induct_step</span><span> </span><span>lastc1skip</span><span> </span><span>seqmap</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">qed</span></span><span>              
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CatchThrowc</span><span> </span><span>c2</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>c2incptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c2, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, [(Throw, Normal s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ([(Throw, Normal s)])) = Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(c2, snd(last [(Throw, Normal s)]))#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>c2incptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2,Normal s)#xs=(map (lift c2) [])@(c2, snd(last [(Throw, Normal s)]))#xs&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>lift_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>1</span><span> </span><span>2</span><span> </span><span>3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CatchSkipc</span><span> </span><span>c2</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, [(Skip, s)]) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>    </span><span>ys_nil</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;ys=[]&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>    </span><span>last</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (Skip,  s)#ys)&#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Skip,  s)#ys)) = Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Skip,  s)#ys)) = s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ys_nil</span><span> </span><span>last</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ys_nil</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (lift_catch c2) ys) = []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CatchSkipc.prems</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span> </span><span>ys_nil</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>FaultPropc</span><span> </span><span>c</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.FaultPropc</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>AbruptPropc</span><span> </span><span>c</span><span> </span><span>f</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.AbruptPropc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>StuckPropc</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>stepc.StuckPropc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_func_redex_cptn_mod_nest_seq_n</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594; (Q, t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(redex P = Call fn &#8743; s = Normal sa &#8743; &#915; fn = Some bdy &#8743; P=Seq P0 P1 &#8743; Q=Seq Q0 Q1 &#8743;
            (m,&#915;, (Q0, t)#qxs) &#8712; cptn_mod_nest_call &#8743; fst(last ((Q0, t)#qxs)) = Skip &#8743;
            (n,&#915;,(Q1, snd(last ((Q0, t)#qxs)))#ys) &#8712; cptn_mod_nest_call &#8743;
            xs=(map (lift Q1) qxs)@((Q1, snd(last ((Q0, t)#qxs)))#ys))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P,s)#(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step_seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Seq P0 P1,s) &#8594; (Seq Q0 Q1, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P1_eq_Q1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;P1 = Q1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>stepc_elim_cases_Seq_Seq&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_seq</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>11</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step_p0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P0,s) &#8594; (Q0, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>stepc_elim_cases_Seq_Seq&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_seq</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P1_eq_Q1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m+1,&#915;, (P0,s)#(Q0, t)#qxs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_redex_cptn_mod_nest_inc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_p0</span><span class="delimiter">]</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m+1&#8804;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cptn_mod_nest</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P0,s)#(Q0, t)#qxs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, s) # (Q0, t) # qxs)) = LanguageCon.com.Skip&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cptn_mod_nest_q1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Q1, snd (last ((P0, s) # (Q0, t) # qxs))) # ys) &#8712; cptn_mod_nest_call &quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # xs =  map (lift Q1) ((Q0,t)#qxs) @ (Q1, snd (last ((Q0, t) # qxs))) # ys&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_t_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # xs = map (lift Q1) ((Q0, t) # qxs) @ (Q1, snd (last ((P0, s) # (Q0, t) # qxs))) # ys&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P=Seq P0 P1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cptn_mod_nest</span><span> </span><span>last_skip</span><span> </span><span>cptn_mod_nest_q1</span><span> </span><span>q_t_xs</span><span class="delimiter">]</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P1_eq_Q1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_func_redex_cptn_mod_nest_catch_n</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594; (Q, t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(redex P = Call fn &#8743; s = Normal sa &#8743; &#915; fn = Some bdy &#8743; P=Catch P0 P1 &#8743; Q=Catch Q0 Q1 &#8743;
            (m,&#915;, (Q0, t)#qxs) &#8712; cptn_mod_nest_call &#8743; fst(last ((Q0, t)#qxs)) = Throw &#8743;
            snd(last ((Q0, t)#qxs)) = Normal sa&#39; &#8743;
            (n,&#915;,(Q1, snd(last ((Q0, t)#qxs)))#ys) &#8712; cptn_mod_nest_call &#8743;
            xs=(map (lift_catch Q1) qxs)@((Q1, snd(last ((Q0, t)#qxs)))#ys))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P,s)#(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step_catch</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (Catch P0 P1,s) &#8594; (Catch Q0 Q1, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P1_eq_Q1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;P1 = Q1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>stepc_elim_cases_Catch_Catch&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_catch</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Throw &#8800; P0&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>stepc_elim_cases_Catch_Catch&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_catch</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step_p0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P0,s) &#8594; (Q0, t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>stepc_elim_cases_Catch_Catch&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_catch</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>P1_eq_Q1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m+1,&#915;, (P0,s)#(Q0, t)#qxs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>func_redex_cptn_mod_nest_inc</span><span class="delimiter">[</span><span>OF</span><span> </span><span>step_p0</span><span class="delimiter">]</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;m+1&#8804;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cptn_mod_nest</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (P0,Normal sa)#(Q0, t)#qxs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_throw</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, Normal sa) # (Q0, t) # qxs)) = LanguageCon.com.Throw&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>last_normal</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((P0, Normal sa) # (Q0, t) # qxs)) = Normal sa&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cptn_mod_nest_q1</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Q1, snd (last ((P0, Normal sa) # (Q0, t) # qxs))) # ys) &#8712; cptn_mod_nest_call &quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # xs =  map (lift_catch Q1) ((Q0,t)#qxs) @ (Q1, snd (last ((Q0, t) # qxs))) # ys&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_t_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # xs = map (lift_catch Q1) ((Q0, t) # qxs) @ (Q1, snd (last ((P0, Normal sa) # (Q0, t) # qxs))) # ys&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P=Catch P0 P1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cptn_mod_nest</span><span> </span><span>last_throw</span><span> </span><span>last_normal</span><span> </span><span>cptn_mod_nest_q1</span><span> </span><span>q_t_xs</span><span class="delimiter">]</span><span> 
</span><span>    </span><span>a2</span><span> </span><span>P1_eq_Q1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_func_redex_cptn_mod_nest_n</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594; (Q, t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;fn. redex P &#8800; Call fn) &#8744; 
            (redex P = Call fn &#8743; &#915; fn = None) &#8744; 
            (redex P = Call fn &#8743; (&#8704;sa. s&#8800;Normal sa)) &#8744; 
            ((redex P = Call fn &#8743; s = Normal sa &#8743; &#915; fn = Some bdy &#8743; P=Seq P0 P1 &#8743; Q=Seq Q0 Q1 &#8743;
            (m,&#915;, (Q0, t)#qxs) &#8712; cptn_mod_nest_call &#8743; fst(last ((Q0, t)#qxs)) = Skip &#8743;
            (n,&#915;,(Q1, snd(last ((Q0, t)#qxs)))#ys) &#8712; cptn_mod_nest_call &#8743;
            xs=(map (lift Q1) qxs)@((Q1, snd(last ((Q0, t)#qxs)))#ys)) &#8743; m&lt;n)&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P,s)#(Q,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_func_redex_cptn_mod_nest_n&#39;</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span> 
</span><span>      </span><span>not_func_redex_cptn_mod_nest_seq_n</span><span class="delimiter">[</span><span>OF</span><span> </span><span>a0</span><span> </span><span>a1</span><span class="delimiter">]</span><span> </span><span>a2</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>not_func_redex_cptn_mod_nest_n_env</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (P, t)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>         
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P,s)#(P,t)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>cptn_mod_nest_call.CptnModNestEnv</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 
Call change the code now

lemma func_redex_cptn_mod_nest: 
assumes  a0:&quot;(n,&#915;,(P,s)#zs) &#8712;  cptn_mod_nest_call&quot; and
         a1:&quot;redex P = Call f &#8743;  (&#8707;sn. s = Normal sn)&quot;
shows &quot;(Suc n,&#915;,(P,s)#(P,s)#zs) &#8712;  cptn_mod_nest_call&quot;
using a0 a1 func_redex_cptn_mod_nest_inc  by fastforce *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_nest_cptn_mod</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfs) &#8712;  cptn_mod_nest_call  &#10233; (&#915;,cfs)&#8712; cptn_mod&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod_nest_call.induct</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span class="delimiter">:</span><span>cptn_mod.intros</span><span> </span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_cptn_mod_nest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfs)&#8712; cptn_mod &#10233; &#8707;n. (n,&#915;,cfs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod.induct</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSkip</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cptn_nest</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Skip, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f. ((&#8707;sn. s = Normal sn) &#8743; (&#915; f) = Some Skip &#10230; P  &#8800; Call f  )&quot;</span></span></span><span>     
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSkip</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CptnModSkip</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnModSkip</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>asm</span><span> </span><span>cptn_nest</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t1</span><span class="delimiter">=</span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (&#8704;f. ((&#8707;sn. s = Normal sn) &#8743; (&#915; f) = Some Skip &#10230; P  &#8800; Call f))&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;((&#8707;sn. s = Normal sn) &#8743; (&#915; f) = Some Skip &#8743; P  = Call f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>normal_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s=Normal sn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_eq_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span>cptn_nest</span><span> </span><span>normal_s</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModSkip.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.simps</span><span class="delimiter">(</span><span>22</span><span class="delimiter">)</span><span> 
</span><span>           </span><span>LanguageCon.inter_guards.simps</span><span class="delimiter">(</span><span>79</span><span class="delimiter">)</span><span> </span><span>LanguageCon.inter_guards_Call</span><span> 
</span><span>           </span><span>Pair_inject</span><span> </span><span>stepc_Normal_elim_cases</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Suc n, &#915;,((Call f), Normal sn)#(Skip, Normal sn)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span>cptn_nest</span><span> </span><span>normal_s</span><span> </span><span>CptnModNestCall</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>        
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span>normal_s</span><span> </span><span>t_eq_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModThrow</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>xs</span><span class="delimiter">)</span><span>  
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cptn_nest</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Throw, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f. ((&#8707;sn. s = Normal sn) &#8743; (&#915; f) = Some Throw &#10230; P  &#8800; Call f  )&quot;</span></span></span><span>     
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestThrow</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CptnModThrow</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnModThrow</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>asm</span><span> </span><span>cptn_nest</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t1</span><span class="delimiter">=</span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (&#8704;f. ((&#8707;sn. s = Normal sn) &#8743; (&#915; f) = Some Throw &#10230; P  &#8800; Call f))&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>f</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>asm</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;((&#8707;sn. s = Normal sn) &#8743; (&#915; f) = Some Throw &#8743; P  = Call f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>sn</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>normal_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s=Normal sn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_eq_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span>cptn_nest</span><span> </span><span>normal_s</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModThrow.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>LanguageCon.com.simps</span><span class="delimiter">(</span><span>22</span><span class="delimiter">)</span><span> 
</span><span>           </span><span>LanguageCon.inter_guards.simps</span><span class="delimiter">(</span><span>79</span><span class="delimiter">)</span><span> </span><span>LanguageCon.inter_guards_Call</span><span> 
</span><span>           </span><span>Pair_inject</span><span> </span><span>stepc_Normal_elim_cases</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Suc n, &#915;,((Call f), Normal sn)#(Throw, Normal sn)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span>cptn_nest</span><span> </span><span>normal_s</span><span> </span><span>CptnModNestCall</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>        
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>asm</span><span> </span><span>normal_s</span><span> </span><span>t_eq_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>t2</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t1</span><span> </span><span>t2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSeq2</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModSeq2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P1, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModSeq2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8805;m&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>CptnModSeq2</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>  
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>CptnModSeq2</span><span> 
</span><span>             </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span> </span><span>le_cases3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModSeq3</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModSeq3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModSeq3</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8805;m&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>CptnModSeq3</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>  
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>CptnModSeq3</span><span>
</span><span>             </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span>le_cases3</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; n &#8804; m &#8744; (m, &#915;, (P0, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8804; m&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P0, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>CptnModSeq3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModSeq3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>CptnModSeq3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> 
</span><span>                   </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModWhile2</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span> </span><span>ys</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModWhile2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; (m, &#915;, (LanguageCon.com.While b P, snd (last ((P, Normal s) # xs))) # ys) &#8712; 
          cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModWhile2</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8805;m&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> 
</span><span>             </span><span>CptnModWhile2</span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>  
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>       
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; n &#8804; m &#8744; (m, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8804; m&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>linarith</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>CptnModWhile2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModWhile2</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>CptnModWhile2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> 
</span><span>                  </span><span>cptn_mod_nest_call.CptnModNestWhile2</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModWhile3</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModWhile3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; (m, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModWhile3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8805;m&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>            </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile3</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>  
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile3</span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>m</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>           </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>CptnModWhile3.hyps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>le_cases</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCatch2</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModCatch2</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModCatch2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8805;m&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> 
</span><span>             </span><span>CptnModCatch2</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>  
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>CptnModCatch2</span><span> 
</span><span>             </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span> </span><span>le_cases3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModCatch3</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModCatch3</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (ys, snd (last ((P0, Normal s) # xs))) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModCatch3</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&#8805;m&quot;</span></span></span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>n</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>CptnModCatch3</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>  
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>_</span><span> </span><span>m</span><span class="delimiter">]</span><span> </span><span>m</span><span> </span><span>n</span><span> </span><span>CptnModCatch3</span><span> 
</span><span>             </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span> </span><span>le_cases3</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; n &#8804; m &#8744; (m, &#915;, (P0, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;&#8896;cfs. &#10214;(n, &#915;, cfs) &#8712; cptn_mod_nest_call; n &#8804; m&#10215; &#10233; (m, &#915;, cfs) &#8712; cptn_mod_nest_call&#8250;</span></span></span><span> </span><span>n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n &#8804; m&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P0, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;P1 = map (lift_catch ys) xs @ (ys, snd (last ((P0, Normal s) # xs))) # zs&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;fst (last ((P0, Normal s) # xs)) = LanguageCon.com.Throw&#8250;</span></span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;snd (last ((P0, Normal s) # xs)) = Normal s&#39;&#8250;</span></span></span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span> </span><span>m</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>cptn_mod_nest_call.intros</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_eq_cptn_mod_nest</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfs)&#8712; cptn_mod &#10231; (&#8707;n. (n,&#915;,cfs) &#8712;  cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_cptn_mod_nest</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_eq_cptn_mod_nest&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n. ((&#915;,cfs)&#8712; cptn_mod &#10231; (n,&#915;,cfs) &#8712;  cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_eq_cptn_mod_nest</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;computation on nested calls limit&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Elimination theorems&#8250;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mod_env_not_component</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (P, t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (P, t)&quot;</span></span></span><span>           
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_change_p_or_eq_s</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_cptn_mod_nest_step_c</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,s)#(Q,t)#cfg1&quot;</span></span></span><span>         
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594; (Q,t) &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Q,t)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfg) &#8712;  cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_eq_cptn_mod_set</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P,s) &#8594;<span class="hidden">&#8681;</span><sub>c</sub><span class="hidden">&#8681;</span><sub>e</sub> (Q,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>c_step</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>e_step</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_ce_not_step_e_step_c</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_cptn_mod_nest_call_env</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,s)#(P,t)#cfg1&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;f. &#915; f = Some (LanguageCon.com.Call f) &#8743; 
                 (&#8707;sn. s = Normal sn) &#8743; s = t &#10230; SmallStepCon.redex P &#8800; LanguageCon.com.Call f&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(P,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span> </span><span>cfg1</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod_nest_call.induct</span><span> </span><span class="delimiter">)</span><span> 
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs =  (P0, t)#xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>        
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) = lift P1 (P0, t) &#8743; cfg1 = map (lift P1) xs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xs = (P0, t) # xs&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (LanguageCon.com.Seq P0 P1, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq1</span><span> </span><span>local.step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Seq P0 P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (&#955;a. case a of (P, s) &#8658; (LanguageCon.com.Seq P P1, s)) (x # xs&#39;) @ 
                     (P1, snd (last ((P0, sa) # x # xs&#39;))) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Seq (fst x) P1 = LanguageCon.com.Seq P0 P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;zs = (LanguageCon.com.Seq P0 P1, t) # cfg1&#8250;</span></span></span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>         
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, t) # xs&#39;)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;x = (P0, t)&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq2.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span> 
</span><span>            </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span> </span><span>local.step</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Seq P0 P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq (fst x) P1, snd x) = lift P1 x&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_def</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Seq (fst x) P1 = LanguageCon.com.Seq P0 P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>                
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>         
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal t&#39;&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Normal_Normal</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span>step</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, Normal t&#39;) # xs&#39;) = last ((P0, Normal sa) # x # xs&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, Normal t&#39;) # xs&#39;)) = LanguageCon.com.Throw&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>CptnModNestSeq3.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> 
</span><span>              </span><span>local.step</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>       
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>       
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs =  (P0, t)#xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>        
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, t) = lift_catch P1 (P0, t) &#8743; cfg1 = map (lift_catch P1) xs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xs = (P0, t) # xs&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Catch P0 P1, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch1</span><span> </span><span>local.step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Catch P0 P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Catch (fst x) P1, snd x) = lift_catch P1 x&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Catch (fst x) P1 = LanguageCon.com.Catch P0 P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>           
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>                
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>             
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, t) # xs&#39;)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch2.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> 
</span><span>            </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span> </span><span>local.step</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Catch P0 P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch P1) (x # xs&#39;) @ (P1, snd (last ((P0, Normal sa) # x # xs&#39;))) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Catch (fst x) P1 = LanguageCon.com.Catch P0 P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_unfold</span><span> </span><span>lift_catch_def</span><span> </span><span>zs</span><span class="delimiter">)</span><span>          
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal t&#39;&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Normal_Normal</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0, Normal t&#39;) # xs&#39;) = last ((P0, Normal sa) # x # xs&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0, Normal t&#39;) # xs&#39;)) = LanguageCon.com.Throw&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>CptnModNestCatch3.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span> 
</span><span>              </span><span>local.step</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_cptn_mod_nest_not_env_call</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,s)#(Q,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;f. redex P &#8800; Call f) &#8744;  
             SmallStepCon.redex P = LanguageCon.com.Call fn &#8743; &#915; fn = None &#8744;
            (redex P = Call fn &#8743; (&#8704;sa. s&#8800;Normal sa))&quot;</span></span></span><span>  
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>cfg1</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod_nest_call.induct</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs =  (P0&#39;, t)#xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>        
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) = lift P1 (P0&#39;, t) &#8743; cfg1 = map (lift P1) xs&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xs = (P0&#39;, t) # xs&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (LanguageCon.com.Seq P0&#39; P1, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq1</span><span> </span><span>local.step</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift</span><span> </span><span>Q</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Seq P0&#39;&#39; P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>case_prod_beta&#39;</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (&#955;a. case a of (P, s) &#8658; (LanguageCon.com.Seq P P1, s)) (x # xs&#39;) @ 
                     (P1, snd (last ((P0, sa) # x # xs&#39;))) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Seq (fst x) P1 = LanguageCon.com.Seq P0&#39;&#39; P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zs</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sa=s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_snd_iff</span><span class="delimiter">)</span><span>           
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0&#39;,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0&#39;, t) # xs&#39;)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq2.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span> 
</span><span>           </span><span>local.step</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0&#39;</span><span> </span><span>t</span><span> </span><span>xs&#39;</span><span> </span><span>P1</span><span> </span><span>ys</span><span class="delimiter">]</span><span> </span><span>Cons_lift_append</span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>last_ConsR</span><span> </span><span>list.inject</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Seq P0&#39; P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>case_prod_beta&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq (fst x) P1, snd x) = lift P1 x&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_def</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Seq (fst x) P1 = LanguageCon.com.Seq P0&#39; P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_snd_iff</span><span class="delimiter">)</span><span>                        
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0&#39;,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Seq P0 P1 = P &#8743; Normal sa = s&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq3.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;SmallStepCon.redex P = SmallStepCon.redex P0&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq3.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal t&#39;&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Normal_Normal</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span>step</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0&#39;, Normal t&#39;) # xs&#39;) = last ((P0, Normal sa) # x # xs&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0&#39;, Normal t&#39;) # xs&#39;)) = LanguageCon.com.Throw&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>CptnModNestSeq3.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0&#39;</span><span> </span><span>t&#39;</span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span class="delimiter">]</span><span> 
</span><span>              </span><span>local.step</span><span> </span><span>t</span><span> </span><span>x</span><span>  </span><span>Cons_lift_append</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>               
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>       
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>       
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs =  (P0&#39;, t)#xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>        
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) = lift_catch P1 (P0&#39;, t) &#8743; cfg1 = map (lift_catch P1) xs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Catch P0&#39; P1, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch1</span><span> </span><span>local.step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Cons_lift_catch</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Catch P0&#39; P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_unfold</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Catch (fst x) P1, snd x) = lift_catch P1 x&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Catch (fst x) P1 = LanguageCon.com.Catch P0&#39; P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>           
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_snd_iff</span><span class="delimiter">)</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0&#39;,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>     
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch2.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch2.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0&#39;, t) # xs&#39;)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, s) # (Q, t) # cfg1 = (LanguageCon.com.Catch P0 P1, sa) # map (lift_catch P1) (x # xs&#39;) @ 
              (LanguageCon.com.Skip, snd (last ((P0, sa) # x # xs&#39;))) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch2.prems</span><span>  </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_lift_catch_append</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local.step</span><span> </span><span>skip</span><span class="delimiter">]</span><span> </span><span>last.simps</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>              </span><span>x</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span>  </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Catch P0&#39; P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_unfold</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch P1) (x # xs&#39;) @ (P1, snd (last ((P0, Normal sa) # x # xs&#39;))) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Catch (fst x) P1 = LanguageCon.com.Catch P0&#39; P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_unfold</span><span> </span><span>lift_catch_def</span><span> </span><span>zs</span><span class="delimiter">)</span><span>          
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_snd_iff</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0&#39;,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch3.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch3.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal t&#39;&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Normal_Normal</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0&#39;, Normal t&#39;) # xs&#39;) = last ((P0, Normal sa) # x # xs&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0&#39;, Normal t&#39;) # xs&#39;)) = LanguageCon.com.Throw&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>CptnModNestCatch3.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0&#39;</span><span> </span><span>t&#39;</span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>P1</span><span class="delimiter">]</span><span> 
</span><span>              </span><span>local.step</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_lift_catch_append</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq1</span><span> </span><span>list.inject</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span> </span><span>ys</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.While b P0, Normal s&#39;) = (P, s) &#8743; 
        (LanguageCon.com.Seq P0 (LanguageCon.com.While b P0), Normal s&#39;) # zs = (Q, t) # cfg1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestWhile2.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>          </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> 
</span><span>          </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> 
</span><span>                         </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.prems</span><span> 
</span><span>                         </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span>list.inject</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>stepc_call_skip_normal</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Call p,Normal s) &#8594; (Skip,s&#39;)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_cptn_mod_nest_call_n_greater_zero</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,Normal s)#(Q,t)#cfg1 &#8743; P = Call f &#8743; &#915; f = Some Q &#8743; P&#8800;Q&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;n&gt;0&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod_nest_call.induct</span><span class="delimiter">,</span><span> </span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_cptn_mod_nest_call_0_False</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(0,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,Normal s)#(Q,t)#cfg1 &#8743; P = Call f &#8743; &#915; f = Some Q &#8743; P&#8800;Q&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;PP&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>elim_cptn_mod_nest_call_n_greater_zero</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma elim_cptn_mod_nest_redex_call:
 assumes a0:&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot; and
         a1:&quot;cfg = (P,s)#(Q,t)#cfg1&quot; and
         a2:&quot;redex P = Call f &#8743; &#915; fn = Some bdy&quot;  
 shows &quot;(n-1,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;
 using a0 a1 a2
proof (induct arbitrary: P Q cfg1 s t rule:cptn_mod_nest_call.induct )
case (CptnModNestSeq1 n &#915; P0 s xs zs P1)
   then obtain P0&#39; xs&#39; where &quot;xs =  (P0&#39;, t)#xs&#39;&quot; unfolding lift_def by fastforce
   then have step:&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot; using CptnModNestSeq1 by fastforce        
   have Q:&quot;(Q, t) = lift P1 (P0&#39;, t) &#8743; cfg1 = map (lift P1) xs&#39;&quot;
     using CptnModNestSeq1.hyps(3) CptnModNestSeq1.prems(1) &#8249;xs = (P0&#39;, t) # xs&#39;&#8250; by auto
   also then have &quot;(n, &#915;, (LanguageCon.com.Seq P0&#39; P1, t) # cfg1) &#8712; cptn_mod_nest_call&quot;
     by (meson cptn_mod_nest_call.CptnModNestSeq1 local.step)
   ultimately show ?case
     using CptnModNestSeq1.prems(1)
     by (simp add: Cons_lift Q)   
next
  case (CptnModNestSeq2 n &#915; P0 sa xs P1 ys zs) 
  thus ?case 
  proof (induct xs)
    case Nil thus ?case using Nil.prems(6) Nil.prems(7) by force
  next
    case (Cons x xs&#39;)
    then have x:&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot; 
    proof-
      obtain P0&#39;&#39; where zs: &quot;zs=(Seq P0&#39;&#39; P1,t)#cfg1&quot; using Cons(7) Cons(8) 
        unfolding lift_def by (simp add: Cons_eq_append_conv case_prod_beta&#39;) 
      thus ?thesis using Cons(7) unfolding lift_def
      proof -
        assume &quot;zs = map (&#955;a. case a of (P, s) &#8658; (LanguageCon.com.Seq P P1, s)) (x # xs&#39;) @ 
                     (P1, snd (last ((P0, sa) # x # xs&#39;))) # ys&quot;
        then have &quot;LanguageCon.com.Seq (fst x) P1 = LanguageCon.com.Seq P0&#39;&#39; P1 &#8743; snd x = t&quot;
          by (simp add: zs case_prod_beta)
        also have &quot;sa=s&quot; using Cons by fastforce
        ultimately show ?thesis by (meson eq_snd_iff)           
      qed 
    qed
    then obtain P0&#39; where x:&quot;x=(P0&#39;,t)&quot; by auto
    then have step:&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot; using Cons by force
    have &quot;fst (last ((P0&#39;, t) # xs&#39;)) = LanguageCon.com.Skip&quot;
      using Cons.prems(3) x by force
    then show ?case
      using Cons.prems(4) Cons.prems(6) CptnModNestSeq2.prems(1) x 
           local.step cptn_mod_nest_call.CptnModNestSeq2[of n &#915; P0&#39; t xs&#39; P1 ys] Cons_lift_append
           by (metis (no_types, lifting) last_ConsR list.inject list.simps(3))        
  qed          
next 
  case (CptnModNestSeq3 n &#915; P0 sa xs s&#39; ys zs P1) 
  thus ?case 
  proof (induct xs)
    case Nil thus ?case using Nil.prems(6) Nil.prems(7) by force
  next
    case (Cons x xs&#39;) 
    then have x:&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;
    proof-
      obtain P0&#39; where zs:&quot;zs=(Seq P0&#39; P1,t)#cfg1&quot; using Cons(8) Cons(9) 
        unfolding lift_def
        unfolding lift_def by (simp add: Cons_eq_append_conv case_prod_beta&#39;)
      have &quot;(LanguageCon.com.Seq (fst x) P1, snd x) = lift P1 x&quot;
         by (simp add: lift_def prod.case_eq_if)
      then have &quot;LanguageCon.com.Seq (fst x) P1 = LanguageCon.com.Seq P0&#39; P1 &#8743; snd x = t&quot;
         using zs by (simp add: Cons.prems(7)) 
      then show ?thesis by (meson eq_snd_iff)                        
    qed
    then obtain P0&#39; where x:&quot;x=(P0&#39;,t)&quot; by auto
    then have step:&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot; using Cons by fastforce         
    then obtain t&#39; where t:&quot;t=Normal t&#39;&quot; 
      using Normal_Normal Cons(2) Cons(5) cptn_mod_nest_cptn_mod cptn_eq_cptn_mod_set x
      by (metis snd_eqD)
    then show ?case using x Cons(5) Cons(6) cptn_mod_nest_call.CptnModNestSeq3 step
    proof -
      have &quot;last ((P0&#39;, Normal t&#39;) # xs&#39;) = last ((P0, Normal sa) # x # xs&#39;)&quot;
        using t x by force
      also then have &quot;fst (last ((P0&#39;, Normal t&#39;) # xs&#39;)) = LanguageCon.com.Throw&quot;
        using Cons.prems(3) by presburger
      ultimately show ?thesis
        using Cons.prems(4) Cons.prems(5) Cons.prems(7) 
              CptnModNestSeq3.prems(1) cptn_mod_nest_call.CptnModNestSeq3[of n &#915; P0&#39; t&#39; xs&#39; s&#39; ys] 
              local.step t x  Cons_lift_append
      by (metis (no_types, lifting) list.sel(3))               
    qed       
  qed       
next
  case (CptnModNestCatch1 n &#915; P0 s xs zs P1) 
   then obtain P0&#39; xs&#39; where xs:&quot;xs =  (P0&#39;, t)#xs&#39;&quot; unfolding lift_catch_def by fastforce
   then have step:&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot; using CptnModNestCatch1 by fastforce        
   have Q:&quot;(Q, t) = lift_catch P1 (P0&#39;, t) &#8743; cfg1 = map (lift_catch P1) xs&#39;&quot;
      using CptnModNestCatch1.hyps(3) CptnModNestCatch1.prems(1) xs by auto
    then have &quot;(n, &#915;, (Catch P0&#39; P1, t) # cfg1) &#8712; cptn_mod_nest_call&quot;
      by (meson cptn_mod_nest_call.CptnModNestCatch1 local.step)
    then show ?case
      using CptnModNestCatch1.prems(1) by (simp add:Cons_lift_catch Q)
next
  case (CptnModNestCatch2 n &#915; P0 sa xs ys zs P1) 
  thus ?case 
  proof (induct xs)
    case Nil thus ?case using Nil.prems(6) Nil.prems(7) by force
  next
    case (Cons x xs&#39;) 
    then have x:&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot; 
    proof-
      obtain P0&#39; where zs:&quot;zs=(Catch P0&#39; P1,t)#cfg1&quot; using Cons unfolding lift_catch_def
        by (simp add: case_prod_unfold)
      have &quot;(LanguageCon.com.Catch (fst x) P1, snd x) = lift_catch P1 x&quot;
         by (simp add: lift_catch_def prod.case_eq_if)
      then have &quot;LanguageCon.com.Catch (fst x) P1 = LanguageCon.com.Catch P0&#39; P1 &#8743; snd x = t&quot;
         using Cons.prems(6) zs by fastforce           
      then show ?thesis by (meson eq_snd_iff)          
    qed
    then obtain P0&#39; where x:&quot;x=(P0&#39;,t)&quot; by auto
    then have step:&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot; using Cons by fastforce             
    have skip:&quot;fst (last ((P0&#39;, t) # xs&#39;)) = LanguageCon.com.Skip&quot;
      using Cons.prems(3) x by auto
    show ?case
    proof -
      have &quot;(P, s) # (Q, t) # cfg1 = (LanguageCon.com.Catch P0 P1, sa) # map (lift_catch P1) (x # xs&#39;) @ 
              (LanguageCon.com.Skip, snd (last ((P0, sa) # x # xs&#39;))) # ys&quot;
        using CptnModNestCatch2.prems  Cons.prems(6) by auto
      then show ?thesis 
        using Cons_lift_catch_append Cons.prems(4) 
              cptn_mod_nest_call.CptnModNestCatch2[OF local.step skip] last.simps list.distinct(1)
              x 
        by (metis (no_types)  list.sel(3) x)
    qed
  qed          
next
  case (CptnModNestCatch3 n &#915; P0 sa xs s&#39; P1 ys zs) 
  thus ?case 
  proof (induct xs)
    case Nil thus ?case using Nil.prems(6) Nil.prems(7) by force
  next
    case (Cons x xs&#39;)
    then have x:&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot; 
    proof-
      obtain P0&#39; where zs:&quot;zs=(Catch P0&#39; P1,t)#cfg1&quot; using Cons unfolding lift_catch_def
        by (simp add: case_prod_unfold)
      thus ?thesis using Cons(8) lift_catch_def unfolding lift_def
      proof -
        assume &quot;zs = map (lift_catch P1) (x # xs&#39;) @ (P1, snd (last ((P0, Normal sa) # x # xs&#39;))) # ys&quot;
        then have &quot;LanguageCon.com.Catch (fst x) P1 = LanguageCon.com.Catch P0&#39; P1 &#8743; snd x = t&quot;
          by (simp add: case_prod_unfold lift_catch_def zs)          
        then show ?thesis by (meson eq_snd_iff)  
      qed 
    qed
    then obtain P0&#39; where x:&quot;x=(P0&#39;,t)&quot; by auto
    then have step:&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot; using Cons by fastforce
    then obtain t&#39; where t:&quot;t=Normal t&#39;&quot; 
      using Normal_Normal Cons(2) Cons(5) cptn_mod_nest_cptn_mod cptn_eq_cptn_mod_set x
      by (metis snd_eqD)
    then show ?case 
    proof -
      have &quot;last ((P0&#39;, Normal t&#39;) # xs&#39;) = last ((P0, Normal sa) # x # xs&#39;)&quot;
        using t x by force
      also then have &quot;fst (last ((P0&#39;, Normal t&#39;) # xs&#39;)) = LanguageCon.com.Throw&quot;
        using Cons.prems(3) by presburger
      ultimately show ?thesis
        using Cons.prems(4) Cons.prems(5) Cons.prems(7) 
              CptnModNestCatch3.prems(1) cptn_mod_nest_call.CptnModNestCatch3[of n &#915; P0&#39; t&#39; xs&#39; s&#39; P1] 
              local.step t x by (metis Cons_lift_catch_append list.sel(3)) 
    qed
  qed
next
case (CptnModNestWhile1 n &#915; P0 s&#39; xs b zs) 
  thus ?case
   using cptn_mod_nest_call.CptnModNestSeq1 list.inject by blast   
next
  case (CptnModNestWhile2 n &#915; P0 s&#39; xs b zs ys)  
  have &quot;(LanguageCon.com.While b P0, Normal s&#39;) = (P, s) &#8743; 
        (LanguageCon.com.Seq P0 (LanguageCon.com.While b P0), Normal s&#39;) # zs = (Q, t) # cfg1&quot;
    using CptnModNestWhile2.prems by fastforce
  then show ?case
    using CptnModNestWhile2.hyps(1) CptnModNestWhile2.hyps(3) 
          CptnModNestWhile2.hyps(5) CptnModNestWhile2.hyps(6) 
          cptn_mod_nest_call.CptnModNestSeq2 by blast
next
  case (CptnModNestWhile3 n &#915; P0 s&#39; xs b zs) thus ?case
    by (metis (no_types) CptnModNestWhile3.hyps(1) CptnModNestWhile3.hyps(3) CptnModNestWhile3.hyps(5) 
                         CptnModNestWhile3.hyps(6) CptnModNestWhile3.hyps(8) CptnModNestWhile3.prems 
                         cptn_mod_nest_call.CptnModNestSeq3 list.inject)  
qed(fastforce+)
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_cptn_mod_nest_call_n_dec</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,Normal s)#(Q,t)#cfg1 &#8743; P = Call f &#8743; &#915; f = Some Q &#8743; t= Normal s &#8743; P&#8800;Q&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n-1,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> 
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod_nest_call.induct</span><span class="delimiter">,</span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_cptn_mod_nest_call_n</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P, s)#(Q,t)#cfg1&quot;</span></span></span><span>          
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span>cfg1</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod_nest_call.induct</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCall</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>bdy</span><span> </span><span>sa</span><span> </span><span>ys</span><span> </span><span>p</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono1</span><span> </span><span>list.inject</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs =  (P0&#39;, t)#xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>        
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) = lift P1 (P0&#39;, t) &#8743; cfg1 = map (lift P1) xs&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;xs = (P0&#39;, t) # xs&#39;&#8250;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (LanguageCon.com.Seq P0&#39; P1, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq1</span><span> </span><span>local.step</span><span class="delimiter">)</span><span>
</span><span>   </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestSeq1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift</span><span> </span><span>Q</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Seq P0&#39;&#39; P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>case_prod_beta&#39;</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (&#955;a. case a of (P, s) &#8658; (LanguageCon.com.Seq P P1, s)) (x # xs&#39;) @ 
                     (P1, snd (last ((P0, sa) # x # xs&#39;))) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Seq (fst x) P1 = LanguageCon.com.Seq P0&#39;&#39; P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>zs</span><span> </span><span>case_prod_beta</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sa=s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_snd_iff</span><span class="delimiter">)</span><span>           
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0&#39;,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0&#39;, t) # xs&#39;)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq2.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>x</span><span> 
</span><span>           </span><span>local.step</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0&#39;</span><span> </span><span>t</span><span> </span><span>xs&#39;</span><span> </span><span>P1</span><span> </span><span>ys</span><span class="delimiter">]</span><span> </span><span>Cons_lift_append</span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>last_ConsR</span><span> </span><span>list.inject</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Seq P0&#39; P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_eq_append_conv</span><span> </span><span>case_prod_beta&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq (fst x) P1, snd x) = lift P1 x&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_def</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Seq (fst x) P1 = LanguageCon.com.Seq P0&#39; P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_snd_iff</span><span class="delimiter">)</span><span>                        
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0&#39;,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>         
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal t&#39;&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Normal_Normal</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span>step</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0&#39;, Normal t&#39;) # xs&#39;) = last ((P0, Normal sa) # x # xs&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0&#39;, Normal t&#39;) # xs&#39;)) = LanguageCon.com.Throw&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>CptnModNestSeq3.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0&#39;</span><span> </span><span>t&#39;</span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span class="delimiter">]</span><span> 
</span><span>              </span><span>local.step</span><span> </span><span>t</span><span> </span><span>x</span><span>  </span><span>Cons_lift_append</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>               
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>       
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>       
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs =  (P0&#39;, t)#xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>        
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) = lift_catch P1 (P0&#39;, t) &#8743; cfg1 = map (lift_catch P1) xs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>xs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Catch P0&#39; P1, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch1</span><span> </span><span>local.step</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch1.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>Cons_lift_catch</span><span> </span><span>Q</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Catch P0&#39; P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_unfold</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Catch (fst x) P1, snd x) = lift_catch P1 x&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>lift_catch_def</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Catch (fst x) P1 = LanguageCon.com.Catch P0&#39; P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>           
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_snd_iff</span><span class="delimiter">)</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0&#39;,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>             
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>skip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0&#39;, t) # xs&#39;)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P, s) # (Q, t) # cfg1 = (LanguageCon.com.Catch P0 P1, sa) # map (lift_catch P1) (x # xs&#39;) @ 
              (LanguageCon.com.Skip, snd (last ((P0, sa) # x # xs&#39;))) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestCatch2.prems</span><span>  </span><span>Cons.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons_lift_catch_append</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>local.step</span><span> </span><span>skip</span><span class="delimiter">]</span><span> </span><span>last.simps</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span>
</span><span>              </span><span>x</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span>  </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>sa</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>P1</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Nil.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;P0&#39;. x=(P0&#39;,t)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>zs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(Catch P0&#39; P1,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_unfold</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (lift_catch P1) (x # xs&#39;) @ (P1, snd (last ((P0, Normal sa) # x # xs&#39;))) # ys&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Catch (fst x) P1 = LanguageCon.com.Catch P0&#39; P1 &#8743; snd x = t&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>case_prod_unfold</span><span> </span><span>lift_catch_def</span><span> </span><span>zs</span><span class="delimiter">)</span><span>          
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>eq_snd_iff</span><span class="delimiter">)</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>P0&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(P0&#39;,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>step</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0&#39;, t) # xs&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>t&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>t</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal t&#39;&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Normal_Normal</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>x</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>snd_eqD</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last ((P0&#39;, Normal t&#39;) # xs&#39;) = last ((P0, Normal sa) # x # xs&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((P0&#39;, Normal t&#39;) # xs&#39;)) = LanguageCon.com.Throw&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>      </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>CptnModNestCatch3.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0&#39;</span><span> </span><span>t&#39;</span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>P1</span><span class="delimiter">]</span><span> 
</span><span>              </span><span>local.step</span><span> </span><span>t</span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_lift_catch_append</span><span> </span><span>list.sel</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq1</span><span> </span><span>list.inject</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span> </span><span>ys</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.While b P0, Normal s&#39;) = (P, s) &#8743; 
        (LanguageCon.com.Seq P0 (LanguageCon.com.While b P0), Normal s&#39;) # zs = (Q, t) # cfg1&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestWhile2.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>          </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> 
</span><span>          </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s&#39;</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> 
</span><span>                         </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.prems</span><span> 
</span><span>                         </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span> </span><span>list.inject</span><span class="delimiter">)</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">)</span><span> 
</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>min_call</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfs &#8801; (n,&#915;,cfs) &#8712;  cptn_mod_nest_call &#8743; (&#8704;m&lt;n. &#172;((m,&#915;,cfs) &#8712;  cptn_mod_nest_call))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>minimum_nest_call</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(m,&#915;,cfs) &#8712; cptn_mod_nest_call &#10233;
   &#8707;n. min_call n &#915; cfs&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>m</span><span> </span><span>rule</span><span class="delimiter">:</span><span>cptn_mod_nest_call.induct</span><span class="delimiter">)</span><span> 
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestOne</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestEnv</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (P, s) &#8594; (P, t)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mod_env_not_component</span><span> </span><span>step_change_p_or_eq_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>min</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_n, &#915;, (P, t) # xs) &#8712; cptn_mod_nest_call &#8743; 
                             (&#8704;m&lt;min_n.  (m, &#915;, (P, t) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnModNestEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n, &#915;, (P,s)#(P, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>     
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestEnv</span><span> </span><span>CptnModNestEnv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;min_n. (m, &#915;, (P, s)#(P, t) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSkip</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span> </span><span>xs</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>min</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_n, &#915;, (LanguageCon.com.Skip, t) # xs) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_n. (m, &#915;, (LanguageCon.com.Skip, t) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n, &#915;, (P,s)#(LanguageCon.com.Skip, t) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestSkip</span><span> </span><span>CptnModNestSkip</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;min_n. (m, &#915;, (P, s)#(LanguageCon.com.Skip, t) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>   </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestThrow</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestThrow</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span class="delimiter">)</span><span>    
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCondT</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>P1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestCondT</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCondF</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>P0</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestCondF</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>zs</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Seq_P_Not_finish</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq1</span><span> </span><span>div_seq_nest</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>Q</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>min_p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (P,  s) # xs) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_p. (m, &#915;, (P, s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSeq2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>min_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (Q, snd (last ((P, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_q. (m, &#915;, (Q, snd (last ((P, s) # xs))) # ys) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_p&#8805;min_q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (Q, snd (last ((P,s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_q</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (Seq P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_p</span><span class="delimiter">]</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_p</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>Q</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestSeq2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>  </span><span>CptnModNestSeq2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_p. (m, &#915;,(Seq P Q,s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModNestSeq2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq2.hyps</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>Seq_P_Ends_Normal</span><span> </span><span>div_seq_nest</span><span> </span><span>min_p</span><span class="delimiter">)</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (P,  s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (Seq P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_q</span><span class="delimiter">]</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_q</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>Q</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestSeq2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>  </span><span>CptnModNestSeq2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_q. (m, &#915;,(Seq P Q,s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>min_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;min_q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Seq P Q, s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Seq P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>m_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P, s) # xs&#39;) &#8712; cptn_mod_nest_call &#8743; 
                   seq_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  
</span><span>          </span><span>div_seq_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq P Q, s) # zs&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq_P_Ends_Normal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CptnModNestSeq2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>ass</span><span class="delimiter">]</span><span>
</span><span>               </span><span>min_m</span><span> </span><span>min_q</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>          
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestSeq3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>Q</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>min_p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_p. (m, &#915;, (P, Normal s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestSeq3</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>min_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_q. (m, &#915;, (Throw, Normal s&#39;) # ys) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_p&#8805;min_q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_q</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (Seq P Q, Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_p</span><span class="delimiter">]</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_p</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>Q</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestSeq3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>  </span><span>CptnModNestSeq3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_p. (m, &#915;,(Seq P Q,Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>Seq_P_Ends_Abort</span><span> </span><span>div_seq_nest</span><span> </span><span>min_p</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (P,  Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (Seq P Q, Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_q</span><span class="delimiter">]</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq3</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_q</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>Q</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestSeq3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>  </span><span>CptnModNestSeq3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_q. (m, &#915;,(Seq P Q,Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>CptnModNestSeq3.hyps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>Seq_P_Ends_Abort</span><span> </span><span>div_seq_nest</span><span> </span><span>min_q</span><span class="delimiter">)</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_n</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>min</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_n, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_n. (m, &#915;, (P, Normal s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n, &#915;, (While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile1</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">]</span><span> </span><span>CptnModNestWhile1</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_n. (m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModNestWhile1.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Seq_P_Not_finish</span><span> </span><span>div_seq_nest</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span> </span><span>ys</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_n_p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>min_p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_p, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_n_p. (m, &#915;, (P, Normal s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestWhile2</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_n_w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span>min_w</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_w, &#915;, (LanguageCon.com.While b P, snd (last ((P, Normal s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_n_w. (m, &#915;, (LanguageCon.com.While b P, snd (last ((P, Normal s) # xs))) # ys)
               &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_n_p&#8805;min_n_w&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_p, &#915;, 
      (LanguageCon.com.While b P, snd (last ((P, Normal s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_w</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_p, &#915;, (While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile2</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_n_p</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">]</span><span> </span><span>CptnModNestWhile2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_n_p. (m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> 
</span><span>                </span><span>Seq_P_Ends_Normal</span><span> </span><span>div_seq_nest</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_p</span><span class="delimiter">)</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_n_p&lt;min_n_w&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_w, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span>  </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_w, &#915;, (While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_w</span><span> </span><span>min_p</span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile2</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_n_w</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>zs</span><span class="delimiter">]</span><span> </span><span>CptnModNestWhile2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_n_w. (m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>min_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;min_n_w&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>      
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_nest_not_env_call</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>m_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P, Normal s) # xs&#39;) &#8712; cptn_mod_nest_call  &#8743; 
                   seq_cond_nest zs (While b P) xs&#39; P (Normal s) s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  
</span><span>          </span><span>div_seq_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq P (LanguageCon.com.While b P), Normal s) # zs&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest zs (While b P) xs&#39; P (Normal s) s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile2.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Seq_P_Ends_Normal</span><span> </span><span>a1</span><span> </span><span>last_length</span><span> </span><span>m_cptn</span><span> </span><span>min_m</span><span> </span><span>min_w</span><span class="delimiter">)</span><span>           
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestWhile3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_n_p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>min_p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_p, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_n_p. (m, &#915;, (P, Normal s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestWhile3</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_n_w</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>     </span><span>min_w</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_w, &#915;, (Throw, snd (last ((P, Normal s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_n_w. (m, &#915;, (Throw, snd (last ((P, Normal s) # xs))) # ys)
               &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_n_p&#8805;min_n_w&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_p, &#915;, 
      (Throw, snd (last ((P, Normal s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_w</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_p, &#915;, (While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile3</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_n_p</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestWhile3</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_n_p. (m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> 
</span><span>            </span><span>Seq_P_Ends_Abort</span><span> </span><span>div_seq_nest</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_p</span><span class="delimiter">)</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_n_p&lt;min_n_w&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_w, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span>  </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_n_w, &#915;, (While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_w</span><span> </span><span>min_p</span><span> </span><span>cptn_mod_nest_call.CptnModNestWhile3</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_n_w</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>b</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestWhile3</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>      
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_n_w. (m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>min_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;min_n_w&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(While b P, Normal s) # (Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Seq P (While b P), Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>      
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_nest_not_env_call</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>m_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P, Normal s) # xs&#39;) &#8712; cptn_mod_nest_call  &#8743; 
                   seq_cond_nest zs (While b P) xs&#39; P (Normal s) s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  
</span><span>          </span><span>div_seq_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq P (LanguageCon.com.While b P), Normal s) # zs&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest zs (While b P) xs&#39; P (Normal s) s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>CptnModNestWhile3.hyps</span><span class="delimiter">(</span><span>8</span><span class="delimiter">)</span><span> </span><span>Seq_P_Ends_Abort</span><span> </span><span>s1</span><span> </span><span>m_cptn</span><span> </span><span>min_m</span><span> </span><span>min_w</span><span class="delimiter">)</span><span>       
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCall</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>bdy</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>nn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; nat&quot;</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nna</span><span> </span><span class="delimiter">::</span><span> </span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>ff1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nna, &#915;, (bdy, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743; (&#8704;n. &#172; n &lt; nna &#8744; (n, &#915;, (bdy, Normal s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>CptnModNestCall.hyps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nn (nn (Suc nna)), &#915;, (bdy, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; Suc (nn (nn (Suc nna))) &lt; Suc nna&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ff1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nn (Suc nna), &#915;, (LanguageCon.com.Call f, Normal s) # (bdy, Normal s) # xs) &#8712; cptn_mod_nest_call &#10230; (&#8707;n. (n, &#915;, (LanguageCon.com.Call f, Normal s) # (bdy, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743; 
                (&#172; nn n &lt; n &#8744; (nn n, &#915;, (LanguageCon.com.Call f, Normal s) # (bdy, Normal s) # xs) &#8713; cptn_mod_nest_call))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ff1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>CptnModNestCall.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestCall.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestCall</span><span> </span><span>less_trans_Suc</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n. (n, &#915;, (LanguageCon.com.Call f, Normal s) # (bdy, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743; (&#172; nn n &lt; n &#8744; (nn n, &#915;, (LanguageCon.com.Call f, Normal s) # (bdy, Normal s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>CptnModNestCall.hyps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestCall.hyps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_call.CptnModNestCall</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>meson</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>     
</span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestDynCom</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestDynCom</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestGuard</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>c</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>g</span><span> </span><span>f</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>cptn_mod_nest_call.CptnModNestGuard</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span class="delimiter">)</span><span>   
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch1</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span>  </span><span>zs</span><span> </span><span>Q</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Catch_P_Not_finish</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch1</span><span> </span><span>div_catch_nest</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch2</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span>Q</span><span class="delimiter">)</span><span> 
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>min_p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (P,  s) # xs) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_p. (m, &#915;, (P, s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>min_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (Skip, snd (last ((P, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_q. (m, &#915;, (Skip, snd (last ((P, s) # xs))) # ys) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_p&#8805;min_q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (Skip, snd (last ((P,s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_q</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (Catch P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_p</span><span class="delimiter">]</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_p</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>  </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_p. (m, &#915;,(Catch P Q,s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>min_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;min_p&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Catch P Q, s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Catch P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>m_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P, s) # xs&#39;) &#8712; cptn_mod_nest_call &#8743; 
                   catch_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  
</span><span>          </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch P Q, s) # zs&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs&#39;&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch_P_Ends_Skip</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P,s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span> </span><span>min_m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (P,  s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (Catch P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_q</span><span class="delimiter">]</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch2</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_q</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>  </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_q. (m, &#915;,(Catch P Q,s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>min_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;min_q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Catch P Q, s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Catch P Q, s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>m_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P, s) # xs&#39;) &#8712; cptn_mod_nest_call &#8743; 
                   catch_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  
</span><span>          </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch P Q, s) # zs&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest zs Q xs&#39; P s s&#39;&#39; s&#39; &#915; m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch_P_Ends_Skip</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch2</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>               </span><span>min_m</span><span> </span><span>min_q</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>         
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>CptnModNestCatch3</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>Q</span><span> </span><span>ys</span><span> </span><span>zs</span><span> </span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>     </span><span>min_p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (P, Normal s) # xs) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_p. (m, &#915;, (P, Normal s) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span>  </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>min_q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>    </span><span>min_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (Q,  snd (last ((P, Normal s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
        (&#8704;m&lt;min_q. (m, &#915;, (Q,  snd (last ((P, Normal s) # xs))) # ys) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_p&#8805;min_q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (Q,  snd (last ((P, Normal s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_q</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_p, &#915;, (Catch P Q, Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_p</span><span class="delimiter">]</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_p</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>Q</span><span> </span><span>ys</span><span> </span><span>zs</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>  </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_p. (m, &#915;,(Catch P Q,Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>min_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;min_p&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Catch P Q, Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Catch P Q,Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>ns&#39;</span><span> </span><span>ns&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>m_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P, Normal s) # xs&#39;) &#8712; cptn_mod_nest_call &#8743; 
                   catch_cond_nest zs Q xs&#39; P (Normal s) ns&#39;&#39; ns&#39; &#915; m&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  
</span><span>          </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch P Q, Normal s) # zs&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest zs Q xs&#39; P (Normal s) ns&#39;&#39; ns&#39; &#915; m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs&#39;&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>Catch_P_Ends_Normal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>  </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P,Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>m_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span> </span><span>min_m</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (P,  Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p</span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(min_q, &#915;, (Catch P Q, Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjunct1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_q</span><span class="delimiter">]</span><span> </span><span>cptn_mod_nest_call.CptnModNestCatch3</span><span class="delimiter">[</span><span>of</span><span> </span><span>min_q</span><span> </span><span>&#915;</span><span> </span><span>P</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span class="delimiter">]</span><span> 
</span><span>            </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span>  </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;min_q. (m, &#915;,(Catch P Q,Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>min_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;min_q&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Catch P Q, Normal s) # zs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Catch P Q, Normal s) # zs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs&#39;</span><span> </span><span>ns&#39;</span><span> </span><span>ns&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>m_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P, Normal s) # xs&#39;) &#8712; cptn_mod_nest_call &#8743; 
                   catch_cond_nest zs Q xs&#39; P (Normal s) ns&#39;&#39; ns&#39; &#915; m&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  
</span><span>          </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch P Q, Normal s) # zs&quot;</span></span></span><span class="delimiter">]</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest zs Q xs&#39; P (Normal s) ns&#39;&#39; ns&#39; &#915; m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch_P_Ends_Normal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>  </span><span>CptnModNestCatch3</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span>
</span><span>               </span><span>min_m</span><span> </span><span>min_q</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>                                
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">}</span></span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_cptn_mod_min_nest_call</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,s)#(Q,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;f. redex P &#8800; Call f) &#8744;  
             SmallStepCon.redex P = LanguageCon.com.Call fn &#8743; &#915; fn = None &#8744;
            (redex P = Call fn &#8743; (&#8704;sa. s&#8800;Normal sa)) &#8744;
            (redex P = Call fn &#8743; P=Q)&quot;</span></span></span><span>     
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q,t)#cfg1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>a0&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, cfg) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>  
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, (Q,t)#cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8704;m&lt;n. (m, &#915;, (Q,t)#cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>asm0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>      </span><span>asm1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q,t)#cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, cfg) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span>  </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>cptn_if_cptn_mod</span><span> </span><span>cptn_mod_nest_call.CptnModNestEnv</span><span>
</span><span>          </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>  </span><span>not_func_redex_cptn_mod_nest_n&#39;</span><span>          
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>mod_env_not_component</span><span class="delimiter">)</span><span>
</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0&#39;</span><span> </span><span>asm0</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_call_cptn_mod_min_nest_call</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,s)#(Q,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;P = Call f &#8743;  
             &#915; f = Some Q &#8743; (&#8707;sa. s=Normal sa) &#8743; P&#8800;Q&quot;</span></span></span><span>          
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call (n-1) &#915; ((Q,t)#cfg1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>a0&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, cfg) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>       </span><span>a2&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s= Normal s&#39;&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n-1,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a2&#39;</span><span> </span><span>elim_cptn_mod_nest_call_n_dec</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>cfg</span><span> </span><span>P</span><span> </span><span>s&#39;</span><span> </span><span>Q</span><span> </span><span>t</span><span> </span><span>cfg1</span><span> </span><span>f</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>call_f_step_not_s_eq_t_false</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>              </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>elim_cptn_mod_nest_call_n_dec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;b, &#39;a, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;b, &#39;c) xstate) list &#8658; 
                  (&#39;a &#8658; (&#39;b, &#39;a, &#39;c, &#39;d) LanguageCon.com option) &#8658; nat &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x0 x1 x2. (&#8707;v3&lt;x2. (v3, x1, x0) &#8712; cptn_mod_nest_call) = 
                  (nn x0 x1 x2 &lt; x2 &#8743; (nn x0 x1 x2, x1, x0) &#8712; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n f ps. (&#172; min_call n f ps &#8744; (n, f, ps) &#8712; cptn_mod_nest_call &#8743; 
                            (&#8704;na. &#172; na &lt; n &#8744; (na, f, ps) &#8713; cptn_mod_nest_call)) &#8743; 
                            (min_call n f ps &#8744; (n, f, ps) &#8713; cptn_mod_nest_call &#8744; 
                    nn ps f n &lt; n &#8743; (nn ps f n, f, ps) &#8712; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>min_call_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P, s) # (Q, t) # cfg1) &#8712; cptn_mod_nest_call &#8743; 
                   (&#8704;na. &#172; na &lt; n &#8744; (na, &#915;, (P, s) # (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>assms</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>bb</span><span> </span><span class="delimiter">::</span><span> </span><span class="tfree">&#39;b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = Normal bb&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Call f, Normal bb) = (P, s)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n - 1 &lt; n&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Suc_diff_Suc</span><span> </span><span>a2</span><span> </span><span>diff_Suc_eq_diff_pred</span><span> </span><span>elim_cptn_mod_nest_call_n_greater_zero</span><span> </span><span>lessI</span><span> </span><span>minus_nat.diff_0</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Call f, Normal bb) = (P, s)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f7</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Normal bb = t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f4</span><span> </span><span>f2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>a2</span><span> 
</span><span>                            </span><span>call_f_step_not_s_eq_t_false</span><span> </span><span>cptn_elim_cases</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>                            </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(nn ((Q, t) # cfg1) &#915; (n - 1), &#915;, (Q, Normal bb) # cfg1) &#8712; cptn_mod_nest_call &#10230; 
              (Suc (nn ((Q, t) # cfg1) &#915; (n - 1)), &#915;, 
            (LanguageCon.com.Call f, Normal bb) # (Q, Normal bb) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>cptn_mod_nest_call.CptnModNestCall</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f7</span><span> </span><span>f6</span><span> </span><span>f5</span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(n - 1, &#915;, (Q, t) # cfg1) &#8712; cptn_mod_nest_call&#8250;</span></span></span><span> </span><span>less_trans_Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>redex_not_call_seq_catch</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;redex P = Call f &#8743; P&#8800;Call f&quot;</span></span></span><span>          
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;p1 p2. P = Seq p1 p2 &#8744; P = Catch p1 p2&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">+</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip_all_skip</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfg)&#8712;cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (Skip,s)#cfg1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length cfg. fst(cfg!i) = Skip&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>cfg1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>cfg</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x = (Skip,s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnMod_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>cptn_eq_cptn_mod_set</span><span>  </span><span>stepc_elim_cases</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#xs)&#8712;cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cptn_dest_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span>xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x # xs = (LanguageCon.com.Skip, s&#39;) # xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cptn</span><span> </span><span>xs</span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>diff_Suc_1</span><span> </span><span>fstI</span><span> </span><span>length_Cons</span><span> </span><span>less_Suc_eq_0_disj</span><span> </span><span>nth_Cons&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip_all_skip_throw</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfg)&#8712;cptn&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (Throw,s)#cfg1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length cfg. fst(cfg!i) = Skip &#8744; fst(cfg!i) = Throw&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induct</span><span> </span><span>cfg1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span>cfg</span><span> </span><span>s</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x = (Skip,s&#39;) &#8744; x = (Throw, s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>CptnMod_elim_cases</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span>cptn_eq_cptn_mod_set</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#xs)&#8712;cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cptn_dest_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=(Skip,s&#39;)&quot;</span></span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>skip_all_skip</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn</span><span> </span><span>fstI</span><span> </span><span>length_Cons</span><span> </span><span>less_Suc_eq_0_disj</span><span> </span><span>nth_Cons&#39;</span><span> </span><span>nth_Cons_Suc</span><span> </span><span>skip_all_skip</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x=(Throw,s&#39;)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#xs)&#8712;cptn&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cptn_dest_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span>xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x # xs = (LanguageCon.com.Throw, s&#39;) # xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>x</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cptn</span><span> </span><span>xs</span><span class="delimiter">]</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>diff_Suc_1</span><span> </span><span>fstI</span><span> </span><span>length_Cons</span><span> </span><span>less_Suc_eq_0_disj</span><span> </span><span>nth_Cons&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>skip_min_nested_call_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (Skip,s)#cfg1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n=0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>asm0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, cfg) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>       </span><span>asm1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, cfg) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>  
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>asm0</span><span> </span><span>asm1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cfg1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>cfg</span><span> </span><span>s</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span> </span><span>neq0_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q</span><span> </span><span>s&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (LanguageCon.com.Skip, s) # (Q,s&#39;) # xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;f. SmallStepCon.redex Skip &#8800; LanguageCon.com.Call f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q, s&#39;)#xs)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_min_nest_call</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_call</span><span> </span><span>cfg</span><span class="delimiter">]</span><span> </span><span>cfg</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>cfg</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (Q, s&#39;) # xs) &#8712; cptn_mod_nest_call &#8743; (&#8704;m&lt;n. (m, &#915;, (Q, s&#39;) # xs) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;LanguageCon.com.Skip = Q&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;(n, &#915;, cfg) &#8712; cptn_mod_nest_call&#8250;</span></span></span><span> </span><span>cfg</span><span> </span><span>cptn_dest1_pair</span><span> </span><span>cptn_if_cptn_mod</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>fst_conv</span><span> </span><span>last.simps</span><span> </span><span>last_length</span><span> </span><span>length_Cons</span><span> </span><span>lessI</span><span> </span><span>not_Cons_self2</span><span> </span><span>skip_all_skip</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Cons.hyps</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>throw_min_nested_call_0</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (Throw,s)#cfg1&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n=0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>asm0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, cfg) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>       </span><span>asm1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, cfg) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>  
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>asm0</span><span> </span><span>asm1</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cfg1</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>cfg</span><span> </span><span>s</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_call.CptnModNestOne</span><span> </span><span>neq0_conv</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>s&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x = (Skip,s&#39;) &#8744; x = (Throw, s&#39;)&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>CptnMod_elim_cases</span><span class="delimiter">(</span><span>10</span><span class="delimiter">)</span><span> </span><span>cptn_eq_cptn_mod_set</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span class="delimiter">)</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>cfg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (LanguageCon.com.Throw, s) # (Q,s&#39;) # xs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;f. SmallStepCon.redex Skip &#8800; LanguageCon.com.Call f)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q, s&#39;)#xs)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_min_nest_call</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_call</span><span> </span><span>cfg</span><span class="delimiter">]</span><span> </span><span>cfg</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>x</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>      </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=(Skip,s&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>skip_min_nested_call_0</span><span> </span><span>min_call&#39;</span><span> </span><span>Cons</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>cfg</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>       
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=(Throw,s&#39;)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>2</span><span class="delimiter">)</span><span> </span><span>min_call&#39;</span><span> </span><span>cfg</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* function to calculate that there is not any subsequent where the nested call is n *}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cond_seq_1</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;cond_seq_1 n &#915; c1 s xs c2 zs ys &#8801; ((n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#8743; 
                       fst(last((c1,s)#xs)) = Skip &#8743;
                        (n,&#915;,((c2, snd(last ((c1, s)#xs)))#ys)) &#8712; cptn_mod_nest_call &#8743;
                       zs=(map (lift c2) xs)@((c2, snd(last ((c1, s)#xs)))#ys))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cond_seq_2</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;cond_seq_2 n &#915; c1 s xs c2 zs ys s&#39; s&#39;&#39; &#8801;  s= Normal s&#39;&#39; &#8743; 
                    (n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#8743; 
                    fst(last ((c1, s)#xs)) = Throw &#8743;
                    snd(last ((c1, s)#xs)) = Normal s&#39; &#8743; 
                    (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743; 
                     zs=(map (lift c2) xs)@((Throw,Normal s&#39;)#ys)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cond_catch_1</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;cond_catch_1 n &#915; c1 s xs c2 zs ys &#8801; ((n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#8743; 
                       fst(last((c1,s)#xs)) = Skip &#8743;
                        (n,&#915;,((Skip, snd(last ((c1, s)#xs)))#ys)) &#8712; cptn_mod_nest_call &#8743;
                       zs=(map (lift_catch c2) xs)@((Skip, snd(last ((c1, s)#xs)))#ys))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cond_catch_2</span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;cond_catch_2 n &#915; c1 s xs c2 zs ys s&#39; s&#39;&#39; &#8801; s= Normal s&#39;&#39; &#8743; 
                    (n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#8743; 
                    fst(last ((c1, s)#xs)) = Throw &#8743;
                    snd(last ((c1, s)#xs)) = Normal s&#39; &#8743; 
                    (n,&#915;,(c2,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743; 
                     zs=(map (lift_catch c2) xs)@((c2,Normal s&#39;)#ys)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">fun</span></span><span> </span><span>biggest_nest_call</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e)com &#8658; 
                         (&#39;s,&#39;f) xstate &#8658; 
                         ((&#39;s,&#39;p,&#39;f,&#39;e) config) list &#8658; 
                         (&#39;s,&#39;p,&#39;f,&#39;e) body &#8658; 
                         nat &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call (Seq c1 c2) s zs &#915; n  = 
   (if (&#8707;xs. ((min_call n &#915; ((c1,s)#xs)) &#8743; (zs=map (lift c2) xs))) then
       let xsa = (SOME xs. (min_call n &#915; ((c1,s)#xs)) &#8743; (zs=map (lift c2) xs)) in
       (biggest_nest_call c1 s xsa &#915; n)
    else if (&#8707;xs ys. cond_seq_1 n &#915; c1 s xs c2 zs ys) then
         let xsa = (SOME xs. &#8707;ys. cond_seq_1 n &#915; c1 s xs c2 zs ys);
             ysa = (SOME ys. cond_seq_1 n &#915; c1 s xsa c2 zs ys) in
         if (min_call n &#915; ((c2, snd(last ((c1, s)#xsa)))#ysa)) then True
         else (biggest_nest_call c1 s xsa &#915; n)            
   else let xsa = (SOME xs. &#8707;ys s&#39; s&#39;&#39;. cond_seq_2 n &#915; c1 s xs c2 zs ys s&#39; s&#39;&#39;) in
           (biggest_nest_call c1 s xsa &#915; n))&quot;</span></span></span><span>      
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call (Catch c1 c2) s zs &#915; n  = 
  (if (&#8707;xs. ((min_call n &#915; ((c1,s)#xs)) &#8743; (zs=map (lift_catch c2) xs))) then
    let xsa = (SOME xs. (min_call n &#915; ((c1,s)#xs)) &#8743; (zs=map (lift_catch c2) xs)) in
       (biggest_nest_call c1 s xsa &#915; n)
    else if (&#8707;xs ys. cond_catch_1 n &#915; c1 s xs c2 zs ys) then
         let xsa = (SOME xs. &#8707;ys. cond_catch_1 n &#915; c1 s xs c2 zs ys) in            
                 (biggest_nest_call c1 s xsa &#915; n)
   else let xsa = (SOME xs. &#8707;ys s&#39; s&#39;&#39;. cond_catch_2 n &#915; c1 s xs c2 zs ys s&#39; s&#39;&#39;);
            ysa = (SOME ys. &#8707;s&#39; s&#39;&#39;. cond_catch_2 n &#915; c1 s xsa c2 zs ys s&#39; s&#39;&#39;) in
         if (min_call n &#915; ((c2, snd(last ((c1, s)#xsa)))#ysa)) then True
         else (biggest_nest_call c1 s xsa &#915; n))&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call _ _ _ _ _ = False&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_less_eq_n</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#10233;     
   (n,&#915;,(c2, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call &#10233;
   min_call p &#915; ((c1, s)#xs) &#8743; min_call q &#915; ((c2, snd(last ((c1, s)#xs)))#ys) &#10233;
   p&#8804;n &#8743; q&#8804;n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_less_linear</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_seq_less_eq_n&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#10233;     
   min_call p &#915; ((c1, s)#xs)  &#10233;
   p&#8804;n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_less_linear</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_seq2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Seq c1 c2,s)#zs) &#10233;
   (n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#10233; 
    fst(last ((c1, s)#xs)) = Skip &#10233;
   (n,&#915;,(c2, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call &#10233;
    zs=(map (lift c2) xs)@((c2, snd(last ((c1, s)#xs)))#ys) &#10233;
   min_call n &#915; ((c1, s)#xs) &#8744; min_call n &#915; ((c2, snd(last ((c1, s)#xs)))#ys)
   &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Seq c1 c2,s)#zs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ((c1, s)#xs)) = Skip&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(c2, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(map (lift c2) xs)@((c2, snd(last ((c1, s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>min_calls</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;min_call p &#915; ((c1, s)#xs) &#8743; min_call q &#915; ((c2, snd(last ((c1, s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span>minimum_nest_call</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&#8804;n &#8743; q&#8804;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>  </span><span>a3</span><span> </span><span>a4</span><span> </span><span>min_call_less_eq_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&lt;n &#8743; q &lt;n&quot;</span></span></span><span>     
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;(q,&#915;,(c2, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p&#8804;q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(q, &#915;, (c1, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(q, &#915;, (c2, snd (last ((c1, s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(q,&#915;,((Seq c1 c2,s)#zs)) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>min_calls</span><span> </span><span>a2</span><span> </span><span>a4</span><span>  </span><span>CptnModNestSeq2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q_cptn_c1</span><span> </span><span>a2</span><span> </span><span>q_cptn_c2</span><span> </span><span>a4</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass0</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(p, &#915;, (c1, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(p, &#915;, (c2, snd (last ((c1, s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_mono2</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p,&#915;,((Seq c1 c2,s)#zs)) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>min_calls</span><span> </span><span>a2</span><span> </span><span>a4</span><span>  </span><span>CptnModNestSeq2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q_cptn_c1</span><span> </span><span>a2</span><span> </span><span>q_cptn_c2</span><span> </span><span>a4</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass0</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span class="delimiter">=</span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&#8805;n &#8744; q &#8805;n&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_q</span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_seq3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Seq c1 c2,s)#zs) &#10233;
   s= Normal s&#39;&#39; &#10233;
   (n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#10233; 
    fst(last ((c1, s)#xs)) = Throw &#10233;
    snd(last ((c1, s)#xs)) = Normal s&#39; &#10233;
   (n,&#915;,(Throw, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call &#10233;
    zs=(map (lift c2) xs)@((Throw, snd(last ((c1, s)#xs)))#ys) &#10233;
   min_call n &#915; ((c1, s)#xs)
   &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Seq c1 c2,s)#zs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a0&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s= Normal s&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ((c1, s)#xs)) = Throw&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd(last ((c1, s)#xs)) = Normal s&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Throw, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(map (lift c2) xs)@((Throw, snd(last ((c1, s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>min_calls</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;min_call p &#915; ((c1, s)#xs) &#8743; min_call 0 &#915; ((Throw, snd(last ((c1, s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span>minimum_nest_call</span><span> </span><span>throw_min_nested_call_0</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&#8804;n &#8743; 0&#8804;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>  </span><span>a3</span><span> </span><span>a4</span><span> </span><span>min_call_less_eq_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&lt;n &#8743; 0 &lt;n&quot;</span></span></span><span>     
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;(0,&#915;,(Throw, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p&#8804;0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(0, &#915;, (c1, Normal s&#39;&#39;) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span>min_calls</span><span> </span><span>a0&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(0, &#915;, (Throw, snd (last ((c1, s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(0,&#915;,((Seq c1 c2,s)#zs)) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>min_calls</span><span> </span><span>a2</span><span> </span><span>a4</span><span> </span><span>a2&#39;</span><span> </span><span>a0&#39;</span><span>  </span><span>CptnModNestSeq3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q_cptn_c1</span><span> </span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass0</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(p, &#915;, (c1, Normal s&#39;&#39;) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>min_calls</span><span> </span><span>a0&#39;</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(p, &#915;, (Throw, snd (last ((c1, s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_mono2</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p,&#915;,((Seq c1 c2,s)#zs)) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>min_calls</span><span> </span><span>a2</span><span> </span><span>a4</span><span> </span><span>a0&#39;</span><span> </span><span>a2&#39;</span><span>  </span><span>CptnModNestSeq3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q_cptn_c1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass0</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span class="delimiter">=</span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&#8805;n &#8744; 0 &#8805;n&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_q</span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_catch2</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Catch c1 c2,s)#zs) &#10233;   
   (n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call &#10233; 
    fst(last ((c1, s)#xs)) = Skip &#10233;    
   (n,&#915;,(Skip, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call &#10233;
    zs=(map (lift_catch c2) xs)@((Skip, snd(last ((c1, s)#xs)))#ys) &#10233;
   min_call n &#915; ((c1, s)#xs)
   &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Catch c1 c2,s)#zs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>        
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ((c1, s)#xs)) = Skip&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>        
</span><span>         </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Skip, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(map (lift_catch c2) xs)@((Skip, snd(last ((c1, s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>min_calls</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;min_call p &#915; ((c1, s)#xs) &#8743; min_call 0 &#915; ((Skip, snd(last ((c1, s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span>minimum_nest_call</span><span> </span><span>skip_min_nested_call_0</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&#8804;n &#8743; 0&#8804;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span>  </span><span>a3</span><span> </span><span>a4</span><span> </span><span>min_call_less_eq_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&lt;n &#8743; 0 &lt;n&quot;</span></span></span><span>     
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p,&#915;, (c1, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;(0,&#915;,(Skip, snd(last ((c1, s)#xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p&#8804;0&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(0, &#915;, (c1, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span>min_calls</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(0, &#915;, (Skip, snd (last ((c1, s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(0,&#915;,((Catch c1 c2,s)#zs)) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>min_calls</span><span> </span><span>a2</span><span> </span><span>a4</span><span>    </span><span>CptnModNestCatch2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q_cptn_c1</span><span> </span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass0</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(p, &#915;, (c1, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>min_calls</span><span>  </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(p, &#915;, (Skip, snd (last ((c1, s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_mono2</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p,&#915;,((Catch c1 c2,s)#zs)) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>min_calls</span><span> </span><span>a2</span><span> </span><span>a4</span><span>   </span><span>CptnModNestCatch2</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q_cptn_c1</span><span class="delimiter">]</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass0</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span class="delimiter">=</span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&#8805;n &#8744; 0 &#8805;n&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_q</span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_catch_less_eq_n</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, Normal s)#xs) &#8712; cptn_mod_nest_call &#10233;        
   (n,&#915;,(c2, snd(last ((c1, Normal s)#xs)))#ys) &#8712; cptn_mod_nest_call &#10233;    
   min_call p &#915; ((c1, Normal s)#xs) &#8743; min_call q &#915; ((c2, snd(last ((c1, Normal s)#xs)))#ys) &#10233;
   p&#8804;n &#8743; q&#8804;n&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>le_less_linear</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_catch3</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Catch c1 c2,Normal s)#zs) &#10233;
   (n,&#915;, (c1, Normal s)#xs) &#8712; cptn_mod_nest_call &#10233; 
    fst(last ((c1, Normal s)#xs)) = Throw &#10233;
    snd(last ((c1, Normal s)#xs)) = Normal s&#39; &#10233;
   (n,&#915;,(c2, snd(last ((c1, Normal s)#xs)))#ys) &#8712; cptn_mod_nest_call &#10233;
    zs=(map (lift_catch c2) xs)@((c2, snd(last ((c1, Normal s)#xs)))#ys) &#10233;
   min_call n &#915; ((c1, Normal s)#xs) &#8744; min_call n &#915; ((c2, snd(last ((c1, Normal s)#xs)))#ys)
   &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Catch c1 c2,Normal s)#zs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, (c1, Normal s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst(last ((c1, Normal s)#xs)) = Throw&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd(last ((c1, Normal s)#xs)) = Normal s&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(c2, snd(last ((c1, Normal s)#xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs=(map (lift_catch c2) xs)@((c2, snd(last ((c1, Normal s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>p</span><span> </span><span>q</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>min_calls</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;min_call p &#915; ((c1, Normal s)#xs) &#8743; min_call q &#915; ((c2, snd(last ((c1, Normal s)#xs)))#ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span>minimum_nest_call</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&#8804;n &#8743; q&#8804;n&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a2&#39;</span><span> </span><span>a3</span><span> </span><span>a4</span><span> </span><span>min_call_less_eq_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&lt;n &#8743; q &lt;n&quot;</span></span></span><span>     
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p,&#915;, (c1, Normal s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>              </span><span class="string"><span class="delete"><span class="delete">&quot;(q,&#915;,(c2, snd(last ((c1, Normal s)#xs)))#ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p&#8804;q&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(q, &#915;, (c1,Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(q, &#915;, (c2, snd (last ((c1, Normal s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(q,&#915;,((Catch c1 c2, Normal s)#zs)) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>True</span><span> </span><span>min_calls</span><span> </span><span>a2</span><span> </span><span>a2&#39;</span><span> </span><span>a4</span><span>  </span><span>CptnModNestCatch3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q_cptn_c1</span><span> </span><span>a2</span><span> </span><span>a2&#39;</span><span> </span><span>q_cptn_c2</span><span> </span><span>a4</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass0</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(p, &#915;, (c1, Normal s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>  
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q_cptn_c2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(p, &#915;, (c2, snd (last ((c1, Normal s) # xs))) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_calls</span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>cptn_mod_nest_mono2</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(p,&#915;,((Catch c1 c2,Normal s)#zs)) &#8712;cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>min_calls</span><span> </span><span>a2</span><span> </span><span>a4</span><span>  </span><span>CptnModNestCatch3</span><span class="delimiter">[</span><span>OF</span><span> </span><span>q_cptn_c1</span><span> </span><span>a2</span><span> </span><span>a2&#39;</span><span> </span><span>q_cptn_c2</span><span> </span><span>a4</span><span class="delimiter">]</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass0</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span class="delimiter">=</span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;p&#8805;n &#8744; q &#8805;n&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p_q</span><span> </span><span>min_calls</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_seq_c1_not_finish</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg &#10233;
   cfg = (LanguageCon.com.Seq P0 P1, s) # (Q, t) # cfg1 &#10233;
   (n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call &#10233;
   (Q, t) # cfg1 = map (lift P1) xs &#10233;
   min_call  n &#915; ((P0, s)#xs)
   &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; cfg = (LanguageCon.com.Seq P0 P1, s) # (Q, t) # cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = map (lift P1) xs&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;n. (m, &#915;,(P0, s)#xs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">{</span></span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span>CptnModNestSeq1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ass1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P0, s) # xs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_seq_not_finish</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot; min_call  n &#915; ((P0, s)#xs) &#10233;
   cfg = (LanguageCon.com.Seq P0 P1, s) #  cfg1 &#10233;  
    cfg1 = map (lift P1) xs &#10233;
   min_call n &#915; cfg 
   &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call  n &#915; ((P0, s)#xs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; cfg = (LanguageCon.com.Seq P0 P1, s) #  cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>        
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; cfg1 = map (lift P1) xs&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,cfg) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>CptnModNestSeq1</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cfg1&quot;</span></span></span><span> </span><span>P1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;n. (m, &#915;,cfg) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">{</span></span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, cfg) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m,&#915;,(P0, s)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Seq_P_Not_finish</span><span> </span><span>div_seq_nest</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, cfg) &#8713; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_catch_c1_not_finish</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg &#10233;
   cfg = (LanguageCon.com.Catch P0 P1, s) # (Q, t) # cfg1 &#10233;
   (n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call &#10233;
   (Q, t) # cfg1 = map (lift_catch P1) xs &#10233;
   min_call  n &#915; ((P0, s)#xs)
   &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; cfg = (LanguageCon.com.Catch P0 P1, s) # (Q, t) # cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = map (lift_catch P1) xs&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;n. (m, &#915;,(P0, s)#xs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">{</span></span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a3</span><span> </span><span>CptnModNestCatch1</span><span class="delimiter">[</span><span>OF</span><span> </span><span>ass1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (P0, s) # xs) &#8713; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>min_call_catch_not_finish</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot; min_call  n &#915; ((P0, s)#xs) &#10233;
   cfg = (LanguageCon.com.Catch P0 P1, s) #  cfg1 &#10233;  
    cfg1 = map (lift_catch P1) xs &#10233;
   min_call n &#915; cfg 
   &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call  n &#915; ((P0, s)#xs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>        </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; cfg = (Catch P0 P1, s) #  cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>        
</span><span>        </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; cfg1 = map (lift_catch P1) xs&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,cfg) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>CptnModNestCatch1</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cfg1&quot;</span></span></span><span> </span><span>P1</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;m&lt;n. (m, &#915;,cfg) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">{</span></span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, cfg) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m,&#915;,(P0, s)#xs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Catch_P_Not_finish</span><span> </span><span>div_catch_nest</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>a0</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, cfg) &#8713; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>seq_xs_no_empty</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>     </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest ((Q,t)#cfg1) P1 xs P0 s s&#39;&#39; s&#39; &#915; n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>cfg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (LanguageCon.com.Seq P0 P1, s) # (Q, t) # cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;SmallStepCon.redex (LanguageCon.com.Seq P0 P1) = LanguageCon.com.Call f&quot;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;Q&#39; xs&#39;. Q=Seq Q&#39; P1 &#8743; xs=(Q&#39;,t)#xs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span>seq_cond_nest_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = map (&#955;(P, s). (LanguageCon.com.Seq P P1, s)) xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
        (&#8707;ys. (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
              (Q, t) # cfg1 =
              map (&#955;(P, s). (LanguageCon.com.Seq P P1, s)) xs @
              (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8744;
        fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
        snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
        s = Normal s&#39;&#39; &#8743;
        (&#8707;ys. (n, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
              (Q, t) # cfg1 =
              map (&#955;(P, s). (LanguageCon.com.Seq P P1, s)) xs @
              (LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
        (&#8707;ys. (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
              (Q, t) # cfg1 =
              map (&#955;(P, s). (LanguageCon.com.Seq P P1, s)) xs @
              (P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfg</span><span> </span><span>a0</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xa</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xa = (a,b)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pps</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = ((case (a, b) of (c, x) &#8658; (LanguageCon.com.Seq c P1, x)) # map (&#955;(c, y). 
                             (LanguageCon.com.Seq c P1, y)) xsa) @ 
                             (P1, snd (((P0, s) # xs) ! length xs)) # pps&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xa</span><span> </span><span>ass</span><span> </span><span>local.Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xa</span><span> </span><span>local.Cons</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
        snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
        s = Normal s&#39;&#39; &#8743;
        (&#8707;ys. (n, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
              (Q, t) # cfg1 =
              map (&#955;(P, s). (LanguageCon.com.Seq P P1, s)) xs @
              (LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfg</span><span> </span><span>a0</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xa</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xa = (a,b)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pps</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = ((case (a, b) of (c, x) &#8658; (LanguageCon.com.Seq c P1, x)) # map (&#955;(c, y). 
              (LanguageCon.com.Seq c P1, y)) xsa) @ (LanguageCon.com.Throw, Normal s&#39;) # pps&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>local.Cons</span><span> </span><span>xa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.Cons</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>           
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>catch_xs_no_empty</span><span class="delimiter">:</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span>
</span><span>     </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest ((Q,t)#cfg1) P1 xs P0 s s&#39;&#39; s&#39; &#915; n&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>cfg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (LanguageCon.com.Catch P0 P1, s) # (Q, t) # cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;SmallStepCon.redex (LanguageCon.com.Catch P0 P1) = LanguageCon.com.Call f&quot;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">shows</span></span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;Q&#39; xs&#39;. Q=Catch Q&#39; P1 &#8743; xs=(Q&#39;,t)#xs&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq</span><span>
</span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span> </span><span>catch_cond_nest_def</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = map (&#955;(P, s). (LanguageCon.com.Catch P P1, s)) xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
    snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
    s = Normal s&#39;&#39; &#8743;
    (&#8707;ys. (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
          (Q, t) # cfg1 = map (&#955;(P, s). (LanguageCon.com.Catch P P1, s)) xs @ 
                                          (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8744;
    fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
    (&#8707;ys. (n, &#915;, (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
          (Q, t) # cfg1 =
          map (&#955;(P, s). (LanguageCon.com.Catch P P1, s)) xs @ 
                         (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
                snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                s = Normal s&#39;&#39; &#8743;
                (&#8707;ys. (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                  (Q, t) # cfg1 = map (&#955;(P, s). (LanguageCon.com.Catch P P1, s)) xs @ 
                                          (P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfg</span><span> </span><span>a0</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xa</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xa = (a,b)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pps</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = ((case (a, b) of (c, x) &#8658; (LanguageCon.com.Catch c P1, x)) # 
            map (&#955;(c, y). (LanguageCon.com.Catch c P1, y)) xsa) @ 
                           (P1, snd (((P0, s) # xs) ! length xs)) # pps&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>local.Cons</span><span> </span><span>xa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.Cons</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>     
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
    (&#8707;ys. (n, &#915;, (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
          (Q, t) # cfg1 =
          map (&#955;(P, s). (LanguageCon.com.Catch P P1, s)) xs @ 
                         (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cfg</span><span> </span><span>a0</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xa</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xa = (a,b)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>      
</span><span>      </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>pps</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215; (&#39;a, &#39;c) xstate) list&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = ((case (a, b) of (c, x) &#8658; 
           (LanguageCon.com.Catch c P1, x)) # map (&#955;(c, y). 
             (LanguageCon.com.Catch c P1, y)) xsa) @ 
               (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # pps&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>local.Cons</span><span> </span><span>xa</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.Cons</span><span> </span><span>xa</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>        
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>redex_call_cptn_mod_min_nest_call_gr_zero</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,s)#(Q,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;redex P = Call f &#8743;  
             &#915; f = Some bdy &#8743; (&#8707;sa. s=Normal sa) &#8743; t=s&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(P,s)&#8594;(Q,t)&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;n&gt;0&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a3</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Q</span><span> </span><span>cfg1</span><span> </span><span>cfg</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Call</span><span> </span><span>f1</span><span class="delimiter">)</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>7</span><span class="delimiter">)</span><span> </span><span>elim_cptn_mod_nest_call_n_greater_zero</span><span> </span><span>min_call_def</span><span> </span><span>option.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>stepc_Normal_elim_cases</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>P0</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest ((Q,t)#cfg1) P1 xs P0 s s&#39;&#39; s&#39; &#915; n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>cfg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>min</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call m &#915; ((P0, s)#xs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>minimum_nest_call</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;Q&#39; xs&#39;. Q=Seq Q&#39; P1 &#8743; xs=(Q&#39;,t)#xs&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq</span><span> </span><span>Seq</span><span> </span><span>seq_xs_no_empty</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&lt;m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span>min</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>stepc_elim_cases_Seq_Seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>min</span><span> </span><span>min_call_def</span><span> </span><span>not_gr0</span><span> </span><span>p0_cptn</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catch</span><span> </span><span>P0</span><span> </span><span>P1</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest ((Q,t)#cfg1) P1 xs P0 s s&#39;&#39; s&#39; &#915; n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>cfg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>m</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>min</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call m &#915; ((P0, s)#xs)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>minimum_nest_call</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Catch Q&#39; P1 &#8743; xs=(Q&#39;,t)#xs&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch_xs_no_empty</span><span class="delimiter">[</span><span>OF</span><span> </span><span>seq</span><span> </span><span>Catch</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">]</span><span> </span><span>Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;0&lt;m&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span class="delimiter">(</span><span>1</span><span class="delimiter">,</span><span>5</span><span class="delimiter">,</span><span>6</span><span class="delimiter">)</span><span> </span><span>min</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>SmallStepCon.redex.simps</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>stepc_elim_cases_Catch_Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>min</span><span> </span><span>min_call_def</span><span> </span><span>not_gr0</span><span> </span><span>p0_cptn</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>elim_redex_call_cptn_mod_min_nest_call</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; cfg&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg = (P,s)#(Q,t)#cfg1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;redex P = Call f &#8743;  
             &#915; f = Some bdy &#8743; (&#8707;sa. s=Normal sa) &#8743; t=s &quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P s ((Q,t)#cfg1) &#915; n&quot;</span></span></span><span>  
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q,t)#cfg1)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a3</span><span> 
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>P</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>Q</span><span> </span><span>cfg1</span><span> </span><span>cfg</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span>n</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cond</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>P0</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest ((Q,t)#cfg1) P1 xs P0 s s&#39;&#39; s&#39; &#915; n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>cfg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>seq_cond_nest_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = map (lift P1) xs&quot;</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Seq Q&#39; P1 &#8743; xs=(Q&#39;,t)#xs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ctpn_P0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(P0, s) # xs = (P0, s) # (Q&#39;, t) # xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_p0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s)#xs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call_seq_c1_not_finish</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Seq</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Seq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>p0_cptn</span><span class="delimiter">]</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;xs. min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift P1) xs&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift P1) xs&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p0</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs= (SOME xs. (min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift P1) xs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;xsa. min_call n &#915; ((P0, s)#xsa) &#8743; (Q, t) # cfg1 = map (lift P1) xsa &#10230; xsa = xs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs&#39;</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>map_lift_eq_xs_xs&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_xs</span><span> </span><span>some_equality</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>big</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s ((Q&#39;, t) # xs&#39;) &#915; n&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>biggest_nest_call.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((Q, t) # cfg1)&quot;</span></span></span><span> </span><span>&#915;</span><span> </span><span>n</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>Seq</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>xs&#39;</span><span> </span><span>ex_xs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>         
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reP0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;redex P0 = (Call f) &#8743; &#915; f = Some bdy &#8743; 
              (&#8707;saa. s = Normal saa) &#8743; t = s &quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q&#39;, t) # xs&#39;)&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_p0</span><span> </span><span>ctpn_P0</span><span> </span><span>reP0</span><span class="delimiter">]</span><span> </span><span>big</span><span> </span><span>xs&#39;</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call_seq_not_finish</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_call</span><span class="delimiter">]</span><span> </span><span>ass</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
                  (&#8707;ys. (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                  (Q, t) # cfg1 = map (lift P1) xs @ (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8744;
                fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
                  snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                  s = Normal s&#39;&#39; &#8743;
                  (&#8707;ys. (n, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
                     (Q, t) # cfg1 = map (lift P1) xs @ (LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
            (&#8707;ys. (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
            (Q, t) # cfg1 = map (lift P1) xs @ (P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>     
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>seq2_ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743; 
          (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
          (Q, t) # cfg1 = map (lift P1) (xa#xsa) @ (P1, snd (((P0, s) # xs) ! length xs)) # ys&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>mq</span><span> </span><span>mp1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>min_call_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call mq &#915; ((P0, s) # xs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>min_call_p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call mp1 &#915; ((P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>         
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> </span><span>minimum_nest_call</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>               
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mq&#8804;n &#8743; mp1 &#8804;n&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> </span><span>min_call_less_eq_n</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>s</span><span> </span><span>xs</span><span> </span><span>P1</span><span> </span><span>ys</span><span>  </span><span>mq</span><span> </span><span>mp1</span><span class="delimiter">]</span><span> 
</span><span>             </span><span>Seq</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s) # xs) &#8744; 
             min_call n &#915; ((P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> </span><span>min_call_seq2</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span> </span><span>xs</span><span> </span><span>ys</span><span class="delimiter">]</span><span> 
</span><span>             </span><span>Seq</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span> </span><span>local.Cons</span><span class="delimiter">)</span><span>       
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>seq2_ass</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Seq Q&#39; P1 &#8743; xa=(Q&#39;,t)&quot;</span></span></span><span>          
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>fst_conv</span><span> </span><span>length_greater_0_conv</span><span> 
</span><span>             </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>9</span><span class="delimiter">)</span><span> </span><span>nth_Cons_0</span><span> </span><span>nth_append</span><span> </span><span>prod.case_eq_if</span><span> </span><span>prod.collapse</span><span> </span><span>snd_conv</span><span class="delimiter">)</span><span>  
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q&#39;_n_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q&#39;,t)#xsa)&#8712;cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p0_cptn</span><span> </span><span>Q&#39;</span><span> </span><span>Cons</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>       </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mp1=n&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call_p1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_P1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P1, snd ((xa # xsa) ! length xsa)) # ys)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>seq2_ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>         
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1_n_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,  (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>         </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Q_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>             
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_P1</span><span> </span><span>ass</span><span> </span><span>Q&#39;</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P1, snd ((xa # xsa) ! length xsa)) # ys) &#8712; cptn_mod_nest_call &#8743; (&#8704;m&lt;n. (m, &#915;, (P1, snd ((xa # xsa) ! length xsa)) # ys) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n f ps. (n, f, ps) &#8713; cptn_mod_nest_call &#8744; (&#8704;x c ca psa. ps &#8800; (LanguageCon.com.Seq (c::(&#39;b, &#39;a, &#39;c,&#39;d) LanguageCon.com) ca, x) # psa &#8744; (&#8707;ps b ba. (n, f, (c, x) # ps) &#8712; cptn_mod_nest_call &#8743; seq_cond_nest psa ca ps c x ba b f n))&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P1, snd (last ((Q&#39;, t) # xsa))) # ys = (P1, snd (((P0, s) # xs) ! length xs)) # ys&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Q&#39;</span><span> </span><span>last_length</span><span> </span><span>local.Cons</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Q&#39;, t) # xsa)) = LanguageCon.com.Skip&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Q&#39;</span><span> </span><span>last_ConsR</span><span> </span><span>last_length</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>local.Cons</span><span> </span><span>seq2_ass</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Cons_lift_append</span><span> </span><span>Q&#39;</span><span> </span><span>Seq_P_Ends_Normal</span><span> </span><span>Q_m</span><span> </span><span>ass</span><span> </span><span>seq2_ass</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">qed</span></span><span>           
</span><span>         </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mp1&lt;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_min_call_p1_n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; min_call n &#915; ((P1, snd (last ((P0, s) # xs))) # ys)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call_p1</span><span> </span><span>last_length</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s) # xs)&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>last_length</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P0, s) # xs = (P0, s) # xa#xsa&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>big</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s (((Q&#39;,t))#xsa) &#915; n&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>           </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;xs. min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift P1) xs)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>seq2_ass</span><span> </span><span>Cons</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((LanguageCon.com.Seq P0 P1, s) # (Q, t) # cfg1)&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Seq_P_Not_finish</span><span> </span><span>append_Nil2</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>                          </span><span>local.Cons</span><span> </span><span>min_call_def</span><span> </span><span>same_append_eq</span><span> </span><span>seq</span><span> </span><span>seq2_ass</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;xs ys. cond_seq_1 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_seq_1_def</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span> </span><span>local.Cons</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(SOME xs. &#8707;ys. cond_seq_1 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys) = xs&quot;</span></span></span><span>  
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;xsa. &#8707;ys. (n, &#915;, (P0, s) # xsa) &#8712; cptn_mod_nest_call &#8743;
                   fst (last ((P0, s) # xsa)) = LanguageCon.com.Skip &#8743;
                   (n, &#915;, (P1, snd (last ((P0, s) # xsa))) # ys) &#8712; cptn_mod_nest_call &#8743;
                   (Q, t) # cfg1 = map (lift P1) xsa @ (P1, snd (last ((P0, s) # xsa))) # ys&quot;</span></span></span><span>             
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x. &#8707;ys. (n, &#915;, (P0, s) # x) &#8712; cptn_mod_nest_call &#8743;
               fst (last ((P0, s) # x)) = LanguageCon.com.Skip &#8743;
               (n, &#915;, (P1, snd (last ((P0, s) # x))) # ys) &#8712; cptn_mod_nest_call &#8743;
               (Q, t) # cfg1 = map (lift P1) x @ (P1, snd (last ((P0, s) # x))) # ys &#10233;
                   x = xs)&quot;</span></span></span><span>              
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_P_Ends_Normal</span><span> </span><span>cptn_mod_nest_call.CptnModNestSeq2</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ys. (n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call &#8743;
                   fst (last ((P0, s) # xs)) = LanguageCon.com.Skip &#8743;
                   (n, &#915;, (P1, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
                   (Q, t) # cfg1 = map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span>  </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>               
</span><span>              </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span> </span><span>xs</span><span class="delimiter">]</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_seq_1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(SOME ys. cond_seq_1 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys) = ys&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>               </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;ys. (n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call &#8743;
                   fst (last ((P0, s) # xs)) = LanguageCon.com.Skip &#8743;
                   (n, &#915;, (P1, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
                   (Q, t) # cfg1 = map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call &#8743;
                   fst (last ((P0, s) # xs)) = LanguageCon.com.Skip &#8743;
                   (n, &#915;, (P1, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
                   (Q, t) # cfg1 = map (lift P1) xs @ (P1, snd (last ((P0, s) # xs))) # ys&quot;</span></span></span><span>
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p0_cptn</span><span> </span><span>seq2_ass</span><span> </span><span>Cons</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span> </span><span>ys</span><span class="delimiter">]</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_seq_1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>      
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s xs &#915; n&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_min_call_p1_n</span><span> </span><span>Seq</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> 
</span><span>                    </span><span>biggest_nest_call.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span> </span><span>&#915;</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(P0, s) # xs = (P0, s) # (Q&#39;, t) # xsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reP0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;redex P0 = (Call f) &#8743; &#915; f = Some bdy &#8743; 
            (&#8707;saa. s = Normal saa) &#8743; t = s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q&#39;, t) # xsa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_call</span><span> </span><span>C</span><span> </span><span>reP0</span><span> </span><span>big</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1_n_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,  (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>           </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>             </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Q_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xsa&#39;</span><span> </span><span>s1</span><span> </span><span>s1&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                  </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Q&#39;, t)#xsa&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>                  </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest cfg1 P1 xsa&#39; Q&#39; t s1 s1&#39; &#915; m&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xsa=xsa&#39;&quot;</span></span></span><span> 
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> 
</span><span>                 </span><span>Seq_P_Ends_Normal</span><span class="delimiter">[</span><span>of</span><span> </span><span>cfg1</span><span> </span><span>P1</span><span> </span><span>xsa</span><span> </span><span>Q&#39;</span><span> </span><span>t</span><span> </span><span>ys</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span>xsa&#39;</span><span> </span><span>s1</span><span> </span><span>s1&#39;</span><span class="delimiter">]</span><span> </span><span>Cons</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_lift_append</span><span> </span><span>Q&#39;</span><span> </span><span>Q_m</span><span> </span><span>last.simps</span><span> </span><span>last_length</span><span> </span><span>list.inject</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>p0_cptn</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>             
</span><span>         </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span class="delimiter">=</span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
             snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
            s = Normal s&#39;&#39; &#8743; (&#8707;ys. (n, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
          (Q, t) # cfg1 = map (lift P1) xs @ (LanguageCon.com.Throw, Normal s&#39;) # ys)&quot;</span></span></span><span>          
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(LanguageCon.com.Seq P0 P1, s) &#8594; (Q,t)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>           </span><span>seq2_ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
             snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
            s = Normal s&#39;&#39; &#8743;  (n, &#915;, (LanguageCon.com.Throw, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743;
           (Q, t) # cfg1 = map (lift P1) xs @ (LanguageCon.com.Throw, Normal s&#39;) # ys&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal s&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>mq</span><span> </span><span>mp1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>           </span><span>min_call_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call mq &#915; ((P0, s) # xs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>           </span><span>min_call_p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call mp1 &#915; ((Throw, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>         
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> </span><span>minimum_nest_call</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mp1_zero</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;mp1=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>throw_min_nested_call_0</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s) # xs)&quot;</span></span></span><span>  
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> </span><span>min_call_seq3</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span> </span><span>s&#39;&#39;</span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span class="delimiter">]</span><span>
</span><span>             </span><span>Seq</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>      
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_z</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&gt;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>redex_call_cptn_mod_min_nest_call_gr_zero</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Seq</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Seq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Seq</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>True</span><span class="delimiter">]</span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>          
</span><span>         </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>seq2_ass</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Seq Q&#39; P1 &#8743; xa=(Q&#39;,t)&quot;</span></span></span><span>          
</span><span>           </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;Q&#39;. Q = LanguageCon.com.Seq Q&#39; P1 &#8743; xa = (Q&#39;, t) &#10233; thesis&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Seq (fst xa) P1, snd xa) = ((Q, t) # cfg1) ! 0&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_def</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span> </span><span>case_prod_unfold</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>big_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s ((Q&#39;,t)#xsa) &#915; n&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>           </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;xs. min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift P1) xs)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>seq2_ass</span><span> </span><span>Cons</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq_P_Not_finish</span><span> </span><span>append_Nil2</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>min_call_def</span><span> </span><span>same_append_eq</span><span> </span><span>seq</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;xs ys. cond_seq_1 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys)&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>seq2_ass</span><span> </span><span>p0_cptn</span><span> </span><span>Cons</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_seq_1_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>com.distinct</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> </span><span>com.distinct</span><span class="delimiter">(</span><span>71</span><span class="delimiter">)</span><span> </span><span>last_length</span><span> 
</span><span>                      </span><span>map_lift_some_eq</span><span> </span><span>seq_and_if_not_eq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(SOME xs. &#8707;ys s&#39; s&#39;&#39;. cond_seq_2 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys s&#39; s&#39;&#39;) = xs&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>             </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;xsa. &#8707;ys s&#39; s&#39;&#39;. s= Normal s&#39;&#39; &#8743; 
                    (n,&#915;, (P0, s)#xs) &#8712; cptn_mod_nest_call &#8743; 
                    fst(last ((P0, s)#xs)) = Throw &#8743;
                    snd(last ((P0, s)#xs)) = Normal s&#39; &#8743; 
                    (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743; 
                     ((Q, t) # cfg1)=(map (lift P1) xs)@((Throw,Normal s&#39;)#ys)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x. &#8707;ys s&#39; s&#39;&#39;. s= Normal s&#39;&#39; &#8743; 
                    (n,&#915;, (P0, s)#x) &#8712; cptn_mod_nest_call &#8743; 
                    fst(last ((P0, s)#x)) = Throw &#8743;
                    snd(last ((P0, s)#x)) = Normal s&#39; &#8743; 
                    (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743; 
                     ((Q, t) # cfg1)=(map (lift P1) x)@((Throw,Normal s&#39;)#ys) &#10233;
                    x=xs)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_lift_some_eq</span><span> </span><span>seq2_ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>             </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ys s&#39; s&#39;&#39;. s= Normal s&#39;&#39; &#8743; 
                    (n,&#915;, (P0, s)#xs) &#8712; cptn_mod_nest_call &#8743; 
                    fst(last ((P0, s)#xs)) = Throw &#8743;
                    snd(last ((P0, s)#xs)) = Normal s&#39; &#8743; 
                    (n,&#915;,(Throw,Normal s&#39;)#ys) &#8712; cptn_mod_nest_call &#8743; 
                     ((Q, t) # cfg1)=(map (lift P1) xs)@((Throw,Normal s&#39;)#ys)&quot;</span></span></span><span> 
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span> </span><span>Cons</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span> </span><span>xs</span><span class="delimiter">]</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_seq_2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s xs &#915; n&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>Seq</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> 
</span><span>                  </span><span>biggest_nest_call.simps</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span> </span><span>&#915;</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>           </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">qed</span></span><span>         
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q&#39;,t)#xsa)&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_call</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>big_call</span><span class="delimiter">]</span><span> </span><span>Seq</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1_n_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,  (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>           </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>             </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Q_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xsa&#39;</span><span> </span><span>s1</span><span> </span><span>s1&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                  </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Q&#39;, t)#xsa&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>                  </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;seq_cond_nest cfg1 P1 xsa&#39; Q&#39; (Normal s&#39;&#39;) s1 s1&#39; &#915; m&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_seq_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>Q&#39;</span><span> </span><span>t_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xsa=xsa&#39;&quot;</span></span></span><span> 
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>seq2_ass</span><span> 
</span><span>                 </span><span>Seq_P_Ends_Abort</span><span class="delimiter">[</span><span>of</span><span> </span><span>cfg1</span><span> </span><span>P1</span><span> </span><span>xsa</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span> </span><span>Q&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span>xsa&#39;</span><span> </span><span>s1</span><span> </span><span>s1&#39;</span><span> </span><span class="delimiter">]</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span>Q_m</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons_lift_append</span><span> </span><span>last_length</span><span> </span><span>t_eq</span><span class="delimiter">)</span><span>                 
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>p0_cptn</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span>         </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>env</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(LanguageCon.com.Seq P0 P1, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Q,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>elim_cptn_mod_nest_step_c</span><span> </span><span>min_call_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Seq P0 P1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>env_c_c&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>       </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Seq</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;b, &#39;a, &#39;c,&#39;d) LanguageCon.com &#215; (&#39;b, &#39;c) xstate) list &#8658; 
                         (&#39;a &#8658; (&#39;b, &#39;a, &#39;c,&#39;d) LanguageCon.com option) &#8658; nat &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x0 x1 x2. (&#8707;v3&lt;x2. (v3, x1, x0) &#8712; cptn_mod_nest_call) = (nn x0 x1 x2 &lt; x2 &#8743; (nn x0 x1 x2, x1, x0) &#8712; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (LanguageCon.com.Seq P0 P1, s) # (Q, t) # cfg1) &#8712; cptn_mod_nest_call &#8743; (&#8704;n. &#172; n &lt; n &#8744; (n, &#915;, (LanguageCon.com.Seq P0 P1, s) # (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.Seq</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>local.Seq</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; nn ((Q, t) # cfg1) &#915; n &lt; n &#8744; (nn ((Q, t) # cfg1) &#915; n, &#915;, (Q, t) # cfg1) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>env</span><span> </span><span>env_c_c&#39;</span><span>  </span><span>not_func_redex_cptn_mod_nest_n_env</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Seq.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>min_call_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_call_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Catch</span><span> </span><span>P0</span><span> </span><span>P1</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>          </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>catch</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest ((Q,t)#cfg1) P1 xs P0 s s&#39;&#39; s&#39; &#915; n&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>cfg</span><span class="delimiter">]</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>catch_cond_nest_def</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1 = map (lift_catch P1) xs&quot;</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q&#39;</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>xs&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Catch Q&#39; P1 &#8743; xs=(Q&#39;,t)#xs&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ctpn_P0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(P0, s) # xs = (P0, s) # (Q&#39;, t) # xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_p0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s)#xs)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call_catch_c1_not_finish</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Catch</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Catch</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>p0_cptn</span><span class="delimiter">]</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ex_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;xs. min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift_catch P1) xs&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift_catch P1) xs&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_p0</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs= (SOME xs. (min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift_catch P1) xs))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;xsa. min_call n &#915; ((P0, s)#xsa) &#8743; (Q, t) # cfg1 = map (lift_catch P1) xsa &#10230; xsa = xs&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs&#39;</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>map_lift_catch_eq_xs_xs&#39;</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_xs</span><span> </span><span>some_equality</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>mono_tags</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>big</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s ((Q&#39;, t) # xs&#39;) &#915; n&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>biggest_nest_call.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((Q, t) # cfg1)&quot;</span></span></span><span> </span><span>&#915;</span><span> </span><span>n</span><span class="delimiter">]</span><span> 
</span><span>            </span><span>Catch</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> </span><span>xs&#39;</span><span> </span><span>ex_xs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>          
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reP0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;redex P0 = (Call f) &#8743; &#915; f = Some bdy &#8743; 
              (&#8707;saa. s = Normal saa) &#8743; t = s &quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q&#39;, t) # xs&#39;)&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_p0</span><span> </span><span>ctpn_P0</span><span> </span><span>reP0</span><span class="delimiter">]</span><span> </span><span>big</span><span> </span><span>xs&#39;</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call_catch_not_finish</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_call</span><span class="delimiter">]</span><span> </span><span>ass</span><span> </span><span>xs&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
                snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                s = Normal s&#39;&#39; &#8743;
               (&#8707;ys. (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                  (Q, t) # cfg1 = map (lift_catch P1) xs @ (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8744;
                   fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
                  (&#8707;ys. (n, &#915;, (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
                (Q, t) # cfg1 = map (lift_catch P1) xs @ (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
                snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                s = Normal s&#39;&#39; &#8743;
               (&#8707;ys. (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                  (Q, t) # cfg1 = map (lift_catch P1) xs @ (P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>     
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>catch2_ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743;
                snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                s = Normal s&#39;&#39; &#8743;
                (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743;
                (Q, t) # cfg1 = map (lift_catch P1) xs @ (P1, snd (((P0, s) # xs) ! length xs)) # ys&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>mq</span><span> </span><span>mp1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>         </span><span>min_call_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call mq &#915; ((P0, s) # xs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>min_call_p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call mp1 &#915; ((P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>         
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>minimum_nest_call</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>               
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mq&#8804;n &#8743; mp1 &#8804;n&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>min_call_less_eq_n</span><span> 
</span><span>             </span><span>Catch</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s) # xs) &#8744; 
             min_call n &#915; ((P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>min_call_catch3</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s&#39;&#39;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span> </span><span>xs</span><span> </span><span>s&#39;</span><span> </span><span>ys</span><span class="delimiter">]</span><span> 
</span><span>             </span><span>Catch</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>       
</span><span>       </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>catch2_ass</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Catch Q&#39; P1 &#8743; xa=(Q&#39;,t)&quot;</span></span></span><span>          
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;Q&#39;. Q = LanguageCon.com.Catch Q&#39; P1 &#8743; xa = (Q&#39;, t) &#10233; thesis&quot;</span></span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Throw &#8743; snd (last ((P0, s) # xs)) = Normal s&#39; &#8743; s = Normal s&#39;&#39; &#8743; (n, &#915;, (P1, snd (((P0, s) # xs) ! length xs)) # ys) &#8712; cptn_mod_nest_call &#8743; (Q, t) # cfg1 = map (&#955;(P, s). (LanguageCon.com.Catch P P1, s)) xs @ (P1, snd (((P0, s) # xs) ! length xs)) # ys&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(LanguageCon.com.Catch (fst xa) P1, snd xa) = ((Q, t) # cfg1) ! 0&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>local.Cons</span><span> </span><span>prod.case_eq_if</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>            
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>q&#39;_n_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,(Q&#39;,t)#xsa)&#8712;cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p0_cptn</span><span> </span><span>Q&#39;</span><span> </span><span>Cons</span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>       </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mp1=n&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P1, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call_p1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_P1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P1, snd ((xa # xsa) ! length xsa)) # ys)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>catch2_ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>         
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1_n_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,  (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>         </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>           </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Q_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>   
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_eq_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal s&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span> </span><span>catch2_ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>                      
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xsa&#39;</span><span> </span><span>s1</span><span> </span><span>s1&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                  </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Q&#39;, t)#xsa&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>                  </span><span>catch_cond</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest cfg1 P1 xsa&#39; Q&#39; (Normal s&#39;&#39;) s1 s1&#39; &#915; m&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q_m</span><span> </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Q&#39;, Normal s&#39;&#39;) # xsa)) = LanguageCon.com.Throw&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span>  </span><span>t_eq_s</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cfg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg1 = map (lift_catch P1) xsa @ (P1, snd (last ((Q&#39;, Normal s&#39;&#39;) # xsa))) # ys&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span>  </span><span>t_eq_s</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Q&#39;, Normal s&#39;&#39;) # xsa)) = Normal s&#39;&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span>  </span><span>t_eq_s</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xsa=xsa&#39; &#8743; 
                   (m, &#915;, (P1, snd (((Q&#39;, Normal s&#39;&#39;) # xsa) ! length xsa)) # ys) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>Catch_P_Ends_Normal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cfg</span><span> </span><span>fst</span><span> </span><span>snd</span><span> </span><span>catch_cond</span><span class="delimiter">]</span><span> </span><span>Cons</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_P1</span><span> </span><span>ass</span><span> </span><span>Q&#39;</span><span> </span><span>t_eq_s</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>              
</span><span>           </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">qed</span></span><span>           
</span><span>         </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mp1&lt;n&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>mp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>not_min_call_p1_n</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; min_call n &#915; ((P1, snd (last ((P0, s) # xs))) # ys)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call_p1</span><span> </span><span>last_length</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s) # xs)&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>last_length</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(P0, s) # xs = (P0, s) # xa#xsa&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>big</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s (((Q&#39;,t))#xsa) &#915; n&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>           </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;xs. min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift_catch P1) xs)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>catch2_ass</span><span> </span><span>Cons</span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Catch P0 P1, s) # (Q, t) # cfg1)&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Catch_P_Not_finish</span><span> </span><span>append_Nil2</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>                     </span><span>same_append_eq</span><span> </span><span>catch</span><span> </span><span>catch2_ass</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;xs ys. cond_catch_1 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys)&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_catch_1_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Catch_P_Ends_Skip</span><span> </span><span>LanguageCon.com.distinct</span><span class="delimiter">(</span><span>17</span><span class="delimiter">)</span><span> </span><span>catch</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;xs ys. cond_catch_2 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys s&#39; s&#39;&#39;&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_catch_2_def</span><span> </span><span>last_length</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(SOME xs. &#8707;ys s&#39; s&#39;&#39;. cond_catch_2 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys s&#39; s&#39;&#39;) = xs&quot;</span></span></span><span>  
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>              </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;xsa. s = Normal s&#39;&#39; &#8743;
                              (n, &#915;, (P0, s) # xsa) &#8712; cptn_mod_nest_call &#8743;
                              fst (last ((P0, s) # xsa)) = LanguageCon.com.Throw &#8743;
                              snd (last ((P0, s) # xsa)) = Normal s&#39; &#8743;
                               (n, &#915;, (P1, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743; 
                               (Q, t) # cfg1 = map (lift_catch P1) xsa @ (P1, Normal s&#39;) # ys&quot;</span></span></span><span>             
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x. &#8707;ys s&#39; s&#39;&#39;. s = Normal s&#39;&#39; &#8743;
                              (n, &#915;, (P0, s) # x) &#8712; cptn_mod_nest_call &#8743;
                              fst (last ((P0, s) # x)) = LanguageCon.com.Throw &#8743;
                              snd (last ((P0, s) # x)) = Normal s&#39; &#8743;
                               (n, &#915;, (P1, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743; 
                               (Q, t) # cfg1 = map (lift_catch P1) x @ (P1, Normal s&#39;) # ys &#10233;
                   x = xs)&quot;</span></span></span><span>              
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Catch_P_Ends_Normal</span><span> </span><span>catch</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ys. s = Normal s&#39;&#39; &#8743;
                              (n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call &#8743;
                              fst (last ((P0, s) # xs)) = LanguageCon.com.Throw &#8743;
                              snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                               (n, &#915;, (P1, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743; 
                               (Q, t) # cfg1 = map (lift_catch P1) xs @ (P1, Normal s&#39;) # ys&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span>  </span><span>p0_cptn</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>last_length</span><span> </span><span class="delimiter">)</span><span>             
</span><span>              </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span> </span><span>xs</span><span class="delimiter">]</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_catch_2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(SOME ys. &#8707;s&#39; s&#39;&#39;. cond_catch_2 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys s&#39; s&#39;&#39;) = ys&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>               </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;ysa. s = Normal s&#39;&#39; &#8743;
                              (n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call &#8743;
                              fst (last ((P0, s) # xs)) = LanguageCon.com.Throw &#8743;
                              snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                               (n, &#915;, (P1, Normal s&#39;) # ysa) &#8712; cptn_mod_nest_call &#8743; 
                               (Q, t) # cfg1 = map (lift_catch P1) xs @ (P1, Normal s&#39;) # ysa&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;x.  &#8707;s&#39; s&#39;&#39;. s = Normal s&#39;&#39; &#8743;
                          (n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call &#8743;
                          fst (last ((P0, s) # xs)) = LanguageCon.com.Throw &#8743;
                          snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                          (n, &#915;, (P1, Normal s&#39;) # x) &#8712; cptn_mod_nest_call &#8743; (Q, t) # cfg1 = map (lift_catch P1) xs @ (P1, Normal s&#39;) # x &#10233;
                          x = ys)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>                </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = Normal s&#39;&#39; &#8743;
                      (n, &#915;, (P0, s) # xs) &#8712; cptn_mod_nest_call &#8743;
                       fst (last ((P0, s) # xs)) = LanguageCon.com.Throw &#8743;
                       snd (last ((P0, s) # xs)) = Normal s&#39; &#8743;
                      (n, &#915;, (P1, Normal s&#39;) # ys) &#8712; cptn_mod_nest_call &#8743; 
                       (Q, t) # cfg1 = map (lift_catch P1) xs @ (P1, Normal s&#39;) # ys&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span>  </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>full_types</span><span class="delimiter">)</span><span> </span><span>catch2_ass</span><span> </span><span>last_length</span><span> </span><span>p0_cptn</span><span class="delimiter">)</span><span>             
</span><span>                </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span> </span><span>ys</span><span class="delimiter">]</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_catch_2_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>            </span><span class="keyword1"><span class="command">qed</span></span><span>            
</span><span>            </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s xs &#915; n&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>not_min_call_p1_n</span><span> </span><span>Catch</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> 
</span><span>                    </span><span>biggest_nest_call.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span> </span><span>&#915;</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>C</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(P0, s) # xs = (P0, s) # (Q&#39;, t) # xsa&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>reP0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;redex P0 = (Call f) &#8743; &#915; f = Some bdy &#8743; 
            (&#8707;saa. s = Normal saa) &#8743; t = s &quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q&#39;, t) # xsa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_call</span><span> </span><span>C</span><span> </span><span>reP0</span><span> </span><span>big</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1_n_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,  (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>           </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>             </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Q_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_eq_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=Normal s&#39;&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span> </span><span>catch2_ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xsa&#39;</span><span> </span><span>s1</span><span> </span><span>s1&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                  </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Q&#39;, t)#xsa&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>                  </span><span>catch_cond</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest cfg1 P1 xsa&#39; Q&#39; (Normal s&#39;&#39;) s1 s1&#39; &#915; m&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Q_m</span><span> </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>               </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (last ((Q&#39;, Normal s&#39;&#39;) # xsa)) = LanguageCon.com.Throw&quot;</span></span></span><span> 
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span>  </span><span>t_eq_s</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>cfg</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg1 = map (lift_catch P1) xsa @ (P1, snd (last ((Q&#39;, Normal s&#39;&#39;) # xsa))) # ys&quot;</span></span></span><span>
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span>  </span><span>t_eq_s</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (last ((Q&#39;, Normal s&#39;&#39;) # xsa)) = Normal s&#39;&quot;</span></span></span><span>
</span><span>                </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span>  </span><span>t_eq_s</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xsa=xsa&#39;&quot;</span></span></span><span> 
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>Catch_P_Ends_Normal</span><span class="delimiter">[</span><span>OF</span><span> </span><span>cfg</span><span> </span><span>fst</span><span> </span><span>snd</span><span> </span><span>catch_cond</span><span class="delimiter">]</span><span> </span><span>Cons</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>p0_cptn</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">qed</span></span><span>    
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">note</span></span><span> </span><span>l</span><span class="delimiter">=</span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
             (&#8707;ys. (n, &#915;, (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
             (Q, t) # cfg1 = map (lift_catch P1) xs @ (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch P0 P1, s) &#8594; (Q,t)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>       </span><span class="keyword3"><span class="command">thus</span></span><span>  </span><span class="var">?thesis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>xsa</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>ys</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>           </span><span>catch2_ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (((P0, s) # xs) ! length xs) = LanguageCon.com.Skip &#8743;
             (n, &#915;, (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
             (Q, t) # cfg1 = map (lift_catch P1) xs @ (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>t_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;t=s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>mq</span><span> </span><span>mp1</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>           </span><span>min_call_q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call mq &#915; ((P0, s) # xs)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>           </span><span>min_call_p1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call mp1 &#915; ((Skip, snd (((P0, s) # xs) ! length xs)) # ys)&quot;</span></span></span><span>         
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>minimum_nest_call</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>mp1_zero</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;mp1=0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>skip_min_nested_call_0</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((P0, s) # xs)&quot;</span></span></span><span>  
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>min_call_catch2</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span> </span><span>xs</span><span> </span><span>ys</span><span class="delimiter">]</span><span>
</span><span>             </span><span>Catch</span><span class="delimiter">(</span><span>3</span><span class="delimiter">,</span><span>4</span><span class="delimiter">)</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>last_length</span><span class="delimiter">)</span><span>      
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>n_z</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;n&gt;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>redex_call_cptn_mod_min_nest_call_gr_zero</span><span class="delimiter">[</span><span>OF</span><span> </span><span>Catch</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>Catch</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>Catch</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>True</span><span class="delimiter">]</span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>          
</span><span>         </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>catch2_ass</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Q&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>Q&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Catch Q&#39; P1 &#8743; xa=(Q&#39;,t)&quot;</span></span></span><span>          
</span><span>           </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>            </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;Q&#39;. Q = Catch Q&#39; P1 &#8743; xa = (Q&#39;, t) &#10233; thesis&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch (fst xa) P1, snd xa) = ((Q, t) # cfg1) ! 0&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>lift_catch_def</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cons</span><span> </span><span>case_prod_unfold</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>big_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s ((Q&#39;,t)#xsa) &#915; n&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>           </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172;(&#8707;xs. min_call n &#915; ((P0, s)#xs) &#8743; (Q, t) # cfg1 = map (lift_catch P1) xs)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>catch2_ass</span><span> </span><span>Cons</span><span>
</span><span>           </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>             </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Catch P0 P1, s) # (Q, t) # cfg1)&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>               </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>Catch_P_Not_finish</span><span> </span><span>append_Nil2</span><span> </span><span>list.simps</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> 
</span><span>                     </span><span>same_append_eq</span><span> </span><span>catch</span><span> </span><span>catch2_ass</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;xs ys. cond_catch_1 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys)&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_catch_1_def</span><span> </span><span>last_length</span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>           </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(SOME xs. &#8707;ys. cond_catch_1 n &#915; P0 s xs P1 ((Q, t) # cfg1) ys) = xs&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>             </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?P</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#955;xsa. &#8707;ys. (n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call &#8743; 
                            fst (last ((P0, s) # xs)) = LanguageCon.com.Skip &#8743;
                             (n, &#915;, (LanguageCon.com.Skip, 
                                snd (last ((P0, s) # xsa))) # ys) &#8712; cptn_mod_nest_call &#8743;
                             (Q, t) # cfg1 = map (lift_catch P1) xsa @ 
                               (LanguageCon.com.Skip, snd (last ((P0, s) # xsa))) # ys&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;xsa. &#8707;ys. (n, &#915;,(P0, s)#xsa) &#8712; cptn_mod_nest_call &#8743; 
                             fst (last ((P0, s) # xs)) = LanguageCon.com.Skip &#8743;
                             (n, &#915;, (LanguageCon.com.Skip, 
                                snd (last ((P0, s) # xsa))) # ys) &#8712; cptn_mod_nest_call &#8743;
                             (Q, t) # cfg1 = map (lift_catch P1) xsa @ 
                               (LanguageCon.com.Skip, snd (last ((P0, s) # xsa))) # ys &#10233;
                           xsa = xs&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch_P_Ends_Skip</span><span> </span><span>catch</span><span>  </span><span>catch2_ass</span><span> </span><span>map_lift_catch_some_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>             </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;ys. (n, &#915;,(P0, s)#xs) &#8712; cptn_mod_nest_call &#8743;
                               fst (last ((P0, s) # xs)) = LanguageCon.com.Skip &#8743;
                             (n, &#915;, (LanguageCon.com.Skip, 
                                snd (last ((P0, s) # xs))) # ys) &#8712; cptn_mod_nest_call &#8743;
                             (Q, t) # cfg1 = map (lift_catch P1) xs @ 
                               (LanguageCon.com.Skip, snd (last ((P0, s) # xs))) # ys&quot;</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ass</span><span> </span><span>p0_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_length</span><span class="delimiter">)</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>some_equality</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?P</span><span> </span><span>xs</span><span class="delimiter">]</span><span>
</span><span>                 </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cond_catch_1_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>           </span><span class="keyword1"><span class="command">qed</span></span><span>           
</span><span>           </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;biggest_nest_call P0 s xs &#915; n&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>Catch</span><span class="delimiter">(</span><span>6</span><span class="delimiter">)</span><span> 
</span><span>                  </span><span>biggest_nest_call.simps</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span class="delimiter">[</span><span>of</span><span> </span><span>P0</span><span> </span><span>P1</span><span> </span><span>s</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span> </span><span>&#915;</span><span> </span><span>n</span><span class="delimiter">]</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>           </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">qed</span></span><span>         
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>min_call</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;min_call n &#915; ((Q&#39;,t)#xsa)&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span class="delimiter">[</span><span>OF</span><span> </span><span>min_call</span><span> </span><span>_</span><span> </span><span>_</span><span>  </span><span>big_call</span><span class="delimiter">]</span><span> </span><span>Catch</span><span class="delimiter">(</span><span>5</span><span class="delimiter">)</span><span> </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p1_n_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;,  (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;m&lt;n. (m, &#915;, (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>           </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>m</span><span>
</span><span>             </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>ass</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;m&lt;n&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>Q_m</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;, (Q, t) # cfg1) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>xsa&#39;</span><span> </span><span>s1</span><span> </span><span>s1&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>                  </span><span>p0_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(m, &#915;,(Q&#39;, t)#xsa&#39;) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>                  </span><span>seq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;catch_cond_nest cfg1 P1 xsa&#39; Q&#39; t s1 s1&#39; &#915; m&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>div_catch_nest</span><span class="delimiter">[</span><span>of</span><span> </span><span>m</span><span> </span><span>&#915;</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Q, t) # cfg1&quot;</span></span></span><span class="delimiter">]</span><span> </span><span>Q&#39;</span><span> </span><span>t_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xsa=xsa&#39;&quot;</span></span></span><span> 
</span><span>                 </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>catch2_ass</span><span> 
</span><span>                 </span><span>Catch_P_Ends_Skip</span><span class="delimiter">[</span><span>of</span><span> </span><span>cfg1</span><span> </span><span>P1</span><span> </span><span>xsa</span><span> </span><span>Q&#39;</span><span> </span><span>t</span><span> </span><span>ys</span><span> </span><span>xsa&#39;</span><span> </span><span>s1</span><span> </span><span>s1&#39;</span><span class="delimiter">]</span><span>  
</span><span>                 </span><span>Cons</span><span> </span><span>Q&#39;</span><span> </span><span>Q_m</span><span> 
</span><span>                 </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>last_length</span><span class="delimiter">)</span><span>                 
</span><span>               </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>False</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>min_call</span><span> </span><span>p0_cptn</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>             </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> </span><span class="keyword1"><span class="command">qed</span></span><span>          
</span><span>         </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>env</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Catch P0 P1, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (Q,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>elim_cptn_mod_nest_step_c</span><span> </span><span>min_call_def</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Q</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Q=Catch P0 P1&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>env_c_c&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>        
</span><span>       </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Catch</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>nn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;b, &#39;a, &#39;c,&#39;d) LanguageCon.com &#215; (&#39;b, &#39;c) xstate) list &#8658; (&#39;a &#8658; (&#39;b, &#39;a, &#39;c,&#39;d) LanguageCon.com option) &#8658; nat &#8658; nat&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>            </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x0 x1 x2. (&#8707;v3&lt;x2. (v3, x1, x0) &#8712; cptn_mod_nest_call) = (nn x0 x1 x2 &lt; x2 &#8743; (nn x0 x1 x2, x1, x0) &#8712; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>moura</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, (LanguageCon.com.Catch P0 P1, s) # (Q, t) # cfg1) &#8712; cptn_mod_nest_call &#8743; (&#8704;n. &#172; n &lt; n &#8744; (n, &#915;, (LanguageCon.com.Catch P0 P1, s) # (Q, t) # cfg1) &#8713; cptn_mod_nest_call)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>local.Catch</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>local.Catch</span><span class="delimiter">(</span><span>4</span><span class="delimiter">)</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; nn ((Q, t) # cfg1) &#915; n &lt; n &#8744; (nn ((Q, t) # cfg1) &#915; n, &#915;, (Q, t) # cfg1) &#8713; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>False</span><span> </span><span>env</span><span> </span><span>env_c_c&#39;</span><span>  </span><span>not_func_redex_cptn_mod_nest_n_env</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Catch.prems</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>min_call_def</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>min_call_def</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l</span><span> </span><span>ass</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma elim_redex_call_cptn_mod_min_nest_call&#39;:
 assumes a0:&quot;min_call n &#915; cfg&quot; and
         a1:&quot;cfg = (P,s)#(Q,t)#cfg1&quot; and
         a2:&quot;redex P = Call f &#8743;  
             &#915; f = Some bdy &#8743; redex bdy = redex Q &#8743; (&#8707;sa. s=Normal sa) &#8743; t=s&quot; and
         a3:&quot;&#172; (biggest_nest_call P s ((Q,t)#cfg1) &#915; n)&quot;  
 shows &quot;min_call (n-1) &#915; ((Q,t)#cfg1)&quot;
sorry

lemma elim_cptn_mod_min_nest_call&#39;:
 assumes a0:&quot;min_call n &#915; cfg&quot; and
         a1:&quot;cfg = (P,s)#(Q,t)#cfg1&quot; and
         a2:&quot;redex P = Call f &#8743;  
             &#915; fn &#8800; None &#8743; (&#8707;sa. s=Normal sa)&quot;  
 shows &quot;min_call n &#915; ((Q,t)#cfg1)&quot; sorry

lemma elim_cptn_mod_nest_seq_call_n_dec:
 assumes a0:&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot; and
         a1:&quot;cfg = (P,Normal s)#(Q,t)#cfg1&quot; and
         a2:&quot;redex P = Call fn &#8743; &#915; fn = Some bdy &#8743; P=Seq P0 P1 &#8743;
            (r,&#915;, (P0, Normal s)#qxs) &#8712; cptn_mod_nest_call &#8743; fst(last ((P0, Normal s)#qxs)) = Skip &#8743;
            (s,&#915;,(Q1, snd(last ((P0, Normal s)#qxs)))#ys) &#8712; cptn_mod_nest_call &#8743;
            (Q,t)#cfg1=(map (lift Q1) qxs)@((Q1, snd(last ((P0, Normal s)#qxs)))#ys)&quot; and
         a3:&quot;r&#8804;n &#8743; s &#8804;n &#8743; r&gt;s&quot;         
 shows &quot;(n-1,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;
 
 sorry

lemma elim_cptn_mod_nest_seq_call_n_dec1:
 assumes a0:&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot; and
         a1:&quot;cfg = (P,Normal s)#(Q,t)#cfg1&quot; and
         a2:&quot;(redex P = Call fn &#8743; &#915; fn = Some bdy &#8743; P=Seq P0 P1 &#8743; Q=Seq Q0 Q1 &#8743;
            (r,&#915;, (Q0, t)#qxs) &#8712; cptn_mod_nest_call &#8743; fst(last ((Q0, t)#qxs)) = Skip &#8743;
            (s,&#915;,(Q1, snd(last ((Q0, t)#qxs)))#ys) &#8712; cptn_mod_nest_call &#8743;
            xs=(map (lift Q1) qxs)@((Q1, snd(last ((Q0, t)#qxs)))#ys))&quot; and
         a3:&quot;r&lt;n &#8743; s &lt;n &#8743; r&gt;s&quot;         
 shows &quot;(n-1,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot; sorry

lemma elim_cptn_mod_nest_catch_call_n_dec:
 assumes a0:&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot; and
         a1:&quot;cfg = (P,Normal s)#(Q,t)#cfg1&quot; and
         a2:&quot;(redex P = Call fn &#8743; &#915; fn = Some bdy &#8743; P=Catch P0 P1 &#8743; Q=Catch Q0 Q1 &#8743;
            (r,&#915;, (Q0, t)#qxs) &#8712; cptn_mod_nest_call &#8743; fst(last ((Q0, t)#qxs)) =Throw &#8743;
            snd(last ((Q0, t)#qxs)) =Normal sa&#39; &#8743;
            (s,&#915;,(Q1, snd(last ((Q0, t)#qxs)))#ys) &#8712; cptn_mod_nest_call &#8743;
            xs=(map (lift_catch Q1) qxs)@((Q1, snd(last ((Q0, t)#qxs)))#ys))&quot; and
         a3:&quot;r&lt;n &#8743; s &lt;n &#8743; r&gt;s&quot;         
 shows &quot;(n-1,&#915;,(Q,t)#cfg1) &#8712;  cptn_mod_nest_call&quot;
 using a0 a1 a3
 sorry
*)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_nest_n_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfs=(p,s)#cfs&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (min_call n &#915; cfs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n-1,&#915;,cfs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>Suc_diff_1</span><span> </span><span>Suc_leI</span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span>less_nat_zero_code</span><span> </span><span>min_call_def</span><span> </span><span>not_less</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_nest_tl_n_1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfs) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfs=(p,s)#(q,t)#cfs&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (min_call n &#915; cfs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n-1,&#915;,(q,t)#cfs&#39;) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>elim_cptn_mod_nest_call_n</span><span> </span><span>cptn_mod_nest_n_1</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_nest_tl_not_min</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;cfg=(p,s)#cfg&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (min_call n &#915; cfg)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (min_call n &#915; cfg&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>cfg&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, []) &#8713; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn.simps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_eq_cptn_mod_set</span><span> </span><span>cptn_mod_nest_cptn_mod</span><span> </span><span>local.Nil</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>xa</span><span> </span><span>cfga</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>q</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xa = (q,t)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n-1,&#915;,cfg&#39;) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>cptn_mod_nest_tl_n_1</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;,cfg&#39;) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span>Nat.diff_le_self</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>min_call_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a2</span><span> </span><span>min_call_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>cpn</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;nat &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) body &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) com &#8658; 
                  (&#39;s,&#39;f) xstate &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) confs) set&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;cpn n &#915; P s &#8801; {(&#915;1,l). l!0=(P,s) &#8743; (n,&#915;,l) &#8712; cptn_mod_nest_call &#8743; &#915;1=&#915;}&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>cptn_mod_same_n</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfs)&#8712; cptn_mod&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,cfs1)&#8712; cptn_mod&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;n. (n,&#915;,cfs) &#8712;  cptn_mod_nest_call &#8743; (n,&#915;,cfs1) &#8712;  cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>cptn_mod_nest_mono</span><span> </span><span>cptn_mod_cptn_mod_nest</span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span>cptn_mod_nest_mono2</span><span> </span><span>leI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">thm</span></span><span> </span><span>elim_cptn_mod_nest_call_n_dec</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma takecptn_leq_cptn_n [rule_format, elim!]:
  &quot;(n,&#915;,c) &#8712; cptn_mod_nest_call &#10233; &#8707;m. (m,&#915;, take (Suc j) c) &#8712; cptn_mod_nest_call &#8743; m&#8804;n&quot;
 proof (induct j arbitrary: n c)
  case 0 thus ?case
    by (metis cptn_mod_nest_call.intros(1) order_refl surj_pair take.simps(1) take_0 take_Suc)    
next
  case (Suc j) thus ?case
  proof (cases &quot;Suc (Suc j) &#8805; length c&quot;)
    case True thus ?thesis
      using Suc.prems by auto 
  next
    case False 
    then obtain a1 a2 a3 tc where c:&quot;c= a1#a2#a3#tc&quot; 
      by (metis (no_types, lifting) Cons_nth_drop_Suc Suc_lessE drop_0 le_less_linear lessI less_trans_Suc zero_less_Suc)     
    also then have &quot;length (a2#a3#tc) &gt; Suc j&quot; using False by auto
    from c have &quot;&#8707;tc1 tc2. tc=tc1@tc2 &#8743; length (a1#a2#a3#tc1) = Suc(Suc j)&quot; using False 
    proof (induct j)
      case 0 then have &quot;tc=Nil&quot; using False Suc sorry
        thus ?case sorry
    next
      case (Suc j) then show ?case sorry
    qed
    thus ?thesis using Suc sorry
  qed   
    (*
   have not_empty:&quot;c&#8800;[]&quot;
     using Suc(2) cptn.simps cptn_if_cptn_mod cptn_mod_nest_cptn_mod by fastforce   
   { assume a0:&quot;tl c=[]&quot;
     then have &quot;take (Suc (Suc j)) c = [c!0]&quot; 
        by (simp add: not_empty hd_conv_nth take_Suc)        
     have ?case using Suc.hyps Suc.prems a0 not_empty take_Suc by fastforce   
   } note l=this
   {
     assume a0:&quot;tl c&#8800;[]&quot;
     then obtain p q s t c&#39; where &quot;(p,s)#(q,t)#c&#39; = c&quot;
       using not_empty a0 Suc by (metis list.exhaust_sel surjective_pairing) 
     then have &quot;(n,&#915;,tl c)&#8712;cptn_mod_nest_call&quot; 
       using Suc elim_cptn_mod_nest_call_n by fastforce
     then have &quot;&#8707;m. (m, &#915;, take (Suc j) (tl c)) &#8712; cptn_mod_nest_call &#8743; m &#8804; n&quot;
       using Suc by auto
     then have ?case using Suc sorry
   }  
   thus ?case using l by auto *)
qed
*)</span></span></span></span></span><span>
</span><span>   
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
lemma takecptnn_is_cptnn [rule_format, elim!]:
  &quot;&#8704;j. (n,&#915;,c) &#8712; cptn_mod_nest_call &#10230; (n,&#915;, take (Suc j) c) &#8712; cptn_mod_nest_call&quot;
proof -
{
  fix j
  assume a0:&quot;(n,&#915;,c) &#8712; cptn_mod_nest_call&quot; 
  then obtain m where &quot;(m,&#915;,take (Suc j) c) &#8712; cptn_mod_nest_call &#8743; m&#8804;n&quot;
    using  takecptn_leq_cptn_n[OF a0] by blast
  then have &quot;(n,&#915;, take (Suc j) c) &#8712; cptn_mod_nest_call&quot;
    using cptn_mod_nest_mono by blast 
} thus ?thesis by auto
qed
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* &#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;&#8896;! *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* lemma takecptnn_is_cptnn [rule_format, elim!]:
  &quot;&#8704;j. (n,&#915;,c) &#8712; cptn_mod_nest_call &#10230; (n,&#915;, take (Suc j) c) &#8712; cptn_mod_nest_call&quot;
proof (induct c arbitrary: n)
  case Nil thus ?case by auto
next
  case (Cons a as)
  {fix j
   assume a0:&quot;(n, &#915;, a # as) &#8712; cptn_mod_nest_call&quot;
   then obtain ca sa where a:&quot;a=(ca,sa)&quot; by fastforce
   have &quot;(n, &#915;, take (Suc j) (a # as)) &#8712; cptn_mod_nest_call&quot;
   using a0
   proof (cases rule:cptn_mod_nest_call.cases[of _ _ &quot;a#as&quot;]) 
     case (CptnModNestOne) thus ?thesis using a0 take_Nil take_Suc_Cons by auto
   next
     case (CptnModNestEnv) thus ?thesis using a0 Cons(1)
       by (simp add: cptn_mod_nest_call.CptnModNestEnv cptn_mod_nest_call.CptnModNestOne take_Cons&#39;)
   next
     case (CptnModNestSkip) thus ?thesis using a0 Cons(1)
       by (simp add: cptn_mod_nest_call.CptnModNestSkip cptn_mod_nest_call.CptnModNestOne take_Cons&#39;)
   next 
     case (CptnModNestThrow) thus ?thesis using a0 Cons(1)
        by (simp add: cptn_mod_nest_call.CptnModNestThrow cptn_mod_nest_call.CptnModNestOne take_Cons&#39;)     
   next
     case (CptnModNestCondT) thus ?thesis using a0 Cons(1)
        by (simp add: cptn_mod_nest_call.CptnModNestCondT cptn_mod_nest_call.CptnModNestOne take_Cons&#39;)
   next
     case (CptnModNestCondF) thus ?thesis using a0 Cons(1)
        by (simp add: cptn_mod_nest_call.CptnModNestCondF cptn_mod_nest_call.CptnModNestOne take_Cons&#39;)
   next
     case (CptnModNestSeq1) thus ?thesis using a0 Cons(1)
        sorry   
   qed
  } thus ?thesis by auto
} *)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* apply(fastforce intro:cptn_mod_nest_call.intros elim:cptn_mod_nest_call.cases) *)</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dropcptn_is_cptn1</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span>elim</span><span class="delimiter">!</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&lt;length c. (n,&#915;,c) &#8712; cptn_mod_nest_call &#10230; (n,&#915;, drop j c) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&lt;length c &#8743; (n,&#915;,c) &#8712; cptn_mod_nest_call&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n,&#915;, drop j c) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span class="delimiter">(</span><span>induction</span><span> </span><span>j</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Suc</span><span> </span><span>j</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span>c&#39;</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c=a#b#c&#39;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Cons_nth_drop_Suc</span><span> </span><span>Suc_lessE</span><span> </span><span>drop_0</span><span> </span><span>less_trans_Suc</span><span> </span><span>zero_less_Suc</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j&lt;length (b#c&#39;)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(n, &#915;, drop j (b # c&#39;)) &#8712; cptn_mod_nest_call&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>elim_cptn_mod_nest_call_n</span><span class="delimiter">[</span><span>of</span><span> </span><span>n</span><span> </span><span>&#915;</span><span> </span><span>c</span><span class="delimiter">]</span><span> </span><span>Suc</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>surj_pair</span><span class="delimiter">)</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span> </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>   
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Compositionality of the Semantics&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="cartouche"><span class="delete"><span class="delete">&#8249;Definition of the conjoin operator&#8250;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>same_length</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) par_confs &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) confs) list &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;same_length c clist &#8801; (&#8704;i&lt;length clist. length(snd (clist!i))=length (snd c))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_length_non_pair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;same_length c clist &quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;clist&#39;=map (&#955;x. snd x) clist&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i &lt;length clist&#39;. length( (clist&#39;!i))=length (snd c))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>same_length_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>same_state</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) par_confs &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) confs) list &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;same_state c clist &#8801; (&#8704;i &lt;length clist. &#8704;j&lt;length (snd c). snd((snd c)!j) = snd((snd (clist!i))!j))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_state_non_pair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;same_state c clist &quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;clist&#39;=map (&#955;x. snd x) clist&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i &lt;length clist&#39;. &#8704;j&lt;length (snd c). snd((snd c)!j) = snd( (clist&#39;!i)!j))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>same_state_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>same_program</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) par_confs &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) confs) list &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;same_program c clist &#8801; (&#8704;j&lt;length (snd c). fst((snd c)!j) = map (&#955;x. fst(nth (snd x) j)) clist)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>same_program_non_pair</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;same_program c clist &quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>          </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;clist&#39;=map (&#955;x. snd x) clist&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;j&lt;length (snd c). fst((snd c)!j) = map (&#955;x. fst(nth x j)) clist&#39;)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>same_program_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>same_functions</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) par_confs &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) confs) list &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_functions c clist &#8801; &#8704;i &lt;length clist. fst (clist!i) = fst c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>compat_label</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f,&#39;e) par_confs &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) confs) list &#8658; bool&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;compat_label c clist &#8801; 
     (&#8704;j. Suc j&lt;length (snd c) &#10230; 
         ( ((fst c)&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd c)!j)  &#8594; ((snd c)!(Suc j))) &#8743; 
            (&#8707;i&lt;length clist. 
               ((fst (clist!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd (clist!i))!j)  &#8594; ((snd (clist!i))!(Suc j))) &#8743; 
            (&#8704;l&lt;length clist. 
               l&#8800;i &#10230;  (fst (clist!l))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (clist!l))!j  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (clist!l))!(Suc j))  ))) &#8744; 
         ((fst c)&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd c)!j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd c)!(Suc j)) &#8743; 
          (&#8704;i&lt;length clist.  (fst (clist!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (clist!i))!j  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (clist!i))!(Suc j))   )))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>compat_label_tran_0</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>assm1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;compat_label c clist &#8743; length (snd c) &gt; Suc 0&quot;</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((fst c)&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd c)!0)  &#8594; ((snd c)!(Suc 0))) &#8744; 
      ((fst c)&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd c)!0)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd c)!(Suc 0)))&quot;</span></span></span><span>    
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assm1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>compat_label_def</span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>conjoin</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;s,&#39;p,&#39;f,&#39;e) par_confs) &#8658; ((&#39;s,&#39;p,&#39;f,&#39;e) confs) list &#8658; bool&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8733; _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>65</span><span class="delimiter">,</span><span>65</span><span class="delimiter">]</span><span> </span><span>64</span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist &#8801; (same_length c clist) &#8743; (same_state c clist) &#8743; (same_program c clist) &#8743; 
                (compat_label c clist) &#8743; (same_functions c clist)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjoin_same_length</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist &#10233; &#8704;i &lt; length (snd c). length (fst ((snd c)!i)) =  length clist&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; length (snd c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;j&lt;length (snd c). fst((snd c)!j) = map (&#955;x. fst(nth (snd x) j)) clist)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (fst (snd c ! i)) = length clist&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist &#10233;
       i&lt; length (snd c) &#8743; j &lt; length (snd c) &#10233;  
       length (fst ((snd c)!i)) = length (fst ((snd c)!j))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_same_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjoin_same_length_i_suci</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist &#10233;
       Suc i&lt; length (snd c) &#10233;
       length (fst ((snd c)!i)) = length (fst ((snd c)!(Suc i)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_same_length</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjoin_same_program_i</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist &#10233;
   j &lt; length (snd c) &#10233;
   i &lt; length clist &#10233;
   fst ((snd (clist!i))!j) = (fst ((snd c)!j))!i&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; length (snd c)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; length clist&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (fst ((snd c)!j)) = length clist&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_same_length</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (snd c ! j) = map (&#955;x. fst (snd x ! j)) clist&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjoin_same_program_i_j</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist &#10233;
   Suc j &lt; length (snd c) &#10233;
   &#8704;l&lt; length clist. fst ((snd (clist!l))!j) = fst ((snd (clist!l))!(Suc j)) &#10233;
   fst ((snd c)!j) = (fst ((snd c)!(Suc j)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;c &#8733; clist&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Suc j &lt; length (snd c)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;l&lt; length clist. fst ((snd (clist!l))!j) = fst ((snd (clist!l))!(Suc j))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (fst ((snd c)!j)) = length clist&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_same_length</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. fst (snd x ! j)) clist = map (&#955;x. fst (snd x ! (Suc j))) clist&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>in_set_conv_nth</span><span> </span><span>map_eq_conv</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (snd c ! j) = map (&#955;x. fst (snd x ! j)) clist&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (snd c ! Suc j) = map (&#955;x. fst (snd x ! Suc j)) clist&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjoin_last_same_state</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a0</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,l)&#8733; clist&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; length clist&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>   </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(snd (clist!i))&#8800;[]&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (last (snd (clist!i))) = snd (last l)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length l = length (snd (clist!i))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_length_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>length_l</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length l &#8800;0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;last (snd (clist!i)) = (snd (clist!i))!((length l)-1)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>last_conv_nth</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_l</span><span> </span><span>a0</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>a2</span><span> </span><span>last_conv_nth</span><span> </span><span class="delimiter">)</span><span>      
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_eq_if</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;ys. xs=ys &#10230; (length xs = length ys) &#10230; (&#8704;i&lt;length xs. xs!i=ys!i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>xs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(length xs = length ys &#8743; (&#8704;i&lt;length xs. xs!i=ys!i)) = (xs=ys)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; ys!0=a; ys&#8800;[] &#10215; &#10233; ys=(a#(tl ys))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl_if</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ys&#8800;[] &#10230; ys!0=a &#10230; P ys &#10230; P (a#(tl ys))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl_onlyif</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ys&#8800;[] &#10230; ys!0=a &#10230; P (a#(tl ys)) &#10230; P ys&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl_eq</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ys&#8800;[] &#10230; ys!0=a &#10230; P (a#(tl ys)) = P ys&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl_pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;p=(u,ys); ys!0=a; ys&#8800;[] &#10215; &#10233; p=(u,(a#(tl ys)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>SmallStepCon.nth_tl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>nth_tl_eq_Pair</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p=(u,ys) &#10230; ys&#8800;[] &#10230; ys!0=a &#10230; P ((u,a#(tl ys))) = P (u,ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_in_cptn</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; (g,a#xs) &#8712;cptn; xs&#8800;[] &#10215; &#10233; (g,xs)&#8712;cptn&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span> </span><span>cptn.cases</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot; Suc j&lt;length ys &#10230; P (ys!Suc j) &#10230; P (tl(ys)!j)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>List.nth_tl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero1</span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Suc j&lt;length ys &#10230;P (tl(ys)!j) &#10230;P (ys!Suc j)&quot;</span></span></span><span>
</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>List.nth_tl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero_eq</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Suc j&lt;length ys &#10230; (P (tl(ys)!j) = P (ys!Suc j))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>List.nth_tl</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero_eq&#39;</span><span> </span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j. Suc j&lt;length ys &#10230; (P (tl(ys)!j) = P (ys!Suc j))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tl_zero_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero_pair</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; length ys &#10233; length ys = length zs &#10233;
       Suc j &lt; length (snd (ys!i)) &#10233;
       snd (zs!i) = tl (snd (ys!i)) &#10233;        
       P ((snd (ys!i))!(Suc j)) =
       P ((snd (zs!i))!j)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tl_zero_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero_pair&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. length ys = length zs &#10230;
       Suc j &lt; length (snd (ys!i)) &#10230;
       snd (zs!i) = tl (snd (ys!i)) &#10230;        
       (P ((snd (ys!i))!(Suc j)) =
       P ((snd (zs!i))!j))&quot;</span></span></span><span>  
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tl_zero_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero_pair2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; length ys &#10233; length ys = length zs &#10233;
       Suc (Suc j) &lt; length (snd (ys!i)) &#10233;
       snd (zs!i) = tl (snd (ys!i)) &#10233;        
       P ((snd (ys!i))!(Suc (Suc j))) ((snd (ys!i))!(Suc j))  =
       P ((snd (zs!i))!(Suc j)) ((snd (zs!i))!j)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tl_zero_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero_pair2&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. length ys = length zs &#10230;
       Suc (Suc j) &lt; length (snd (ys!i)) &#10230;
       snd (zs!i) = tl (snd (ys!i)) &#10230;        
       P ((snd (ys!i))!(Suc (Suc j))) ((snd (ys!i))!(Suc j))  =
       P ((snd (zs!i))!(Suc j)) ((snd (zs!i))!j)&quot;</span></span></span><span>  
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tl_zero_pair2</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_zero_pair21</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. length ys = length zs &#10230;
       Suc (Suc j) &lt; length (snd (ys!i)) &#10230;
       snd (zs!i) = tl (snd (ys!i)) &#10230;        
       P  ((snd (ys!i))!(Suc j))  ((snd (ys!i))!(Suc (Suc j)))=
       P ((snd (zs!i))!j) ((snd (zs!i))!(Suc j)) &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>SmallStepCon.nth_tl</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>not_less0</span><span> </span><span>nth_Cons_Suc</span><span class="delimiter">)</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>tl_pair</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Suc (Suc j) &lt; length l &#10233;     
       l1 = tl l &#10233;
       P (l!(Suc (Suc j))) (l!(Suc j)) =
       P (l1!(Suc j)) (l1!j)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>tl_zero_eq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_as_map</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>     </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length clist &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>     </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = (map (&#955;x. fst (hd x)) clist)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ys = (map (&#955;x. tl x) clist)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt; length clist. length (clist!i) &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>     
</span><span>     </span><span>a5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. &#8704;j&lt; length clist. &#8704;k&lt;length  (clist!i).
           snd ((clist!i)!k) = snd ((clist!j)!k)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a6</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. &#8704;j&lt; length clist. 
            length (clist!i) = length (clist!j)&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;i. (fst i,snd ((clist!0)!0))#snd i) (zip xs ys)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist&#39;</span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;i. (fst i,snd ((clist!0)!0))#snd i) (zip xs ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lens</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length ?clist&#39;&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length clist. clist ! i = ?clist&#39; ! i)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>    
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a11</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length clist&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs!i = fst (hd (clist!i))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ys_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;ys!i = tl (clist ! i)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd_zero</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (hd (clist!i)) = snd ((clist!0)!0)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a5</span><span> </span><span>a4</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>a1</span><span> </span><span>a11</span><span> </span><span>hd_conv_nth</span><span> </span><span>less_numeral_extra</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;i. (fst i,snd ((clist!0)!0))#snd i) ((zip xs ys)!i) = clist !i&quot;</span></span></span><span>               
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length clist&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>length_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#172; (0::nat) &lt; 0&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>less_not_refl</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>lifting</span><span class="delimiter">)</span><span> </span><span>a11</span><span> </span><span>a3</span><span> </span><span>a4</span><span> 
</span><span>                         </span><span>fst_conv</span><span> </span><span>length_map</span><span> </span><span>list.exhaust_sel</span><span> 
</span><span>                         </span><span>list.size</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span>nth_zip</span><span> </span><span>prod.collapse</span><span> 
</span><span>                         </span><span>snd_conv</span><span> </span><span>snd_zero</span><span> </span><span>xs_clist</span><span> </span><span>ys_clist</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist ! i = ?clist&#39; ! i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lens</span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lens</span><span> </span><span>list_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_as_map&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>     </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length clist &gt; 0&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>     </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = (map (&#955;x. hd x) clist)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ys = (map (&#955;x. tl x) clist)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>     </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt; length clist. length (clist!i) &gt; 0&quot;</span></span></span><span>
</span><span>     </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;i. (fst i)#snd i) (zip xs ys)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist&#39;</span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;i.(fst i)#snd i) (zip xs ys)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lens</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length ?clist&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length clist. clist ! i = ?clist&#39; ! i)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>    
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a11</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length clist&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs!i = hd (clist!i)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ys_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;ys!i = tl (clist ! i)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;i. fst i#snd i) ((zip xs ys)!i) = clist !i&quot;</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs_clist</span><span> </span><span>ys_clist</span><span> </span><span>a11</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span>a4</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist ! i = ?clist&#39; ! i&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lens</span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>lens</span><span> </span><span>list_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conjoin_tl</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,x#xs) &#8733; ys&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;zs = map (&#955;i. (fst i, tl (snd i))) ys&quot;</span></span></span><span>    
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,xs) &#8733; zs&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_p</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;same_program (&#915;,x#xs) ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_l</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;same_length (&#915;,x#xs) ys&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length zs. snd (zs!i) = tl (snd (ys!i))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a2</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_length (&#915;,xs) zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>same_length_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>same_len</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>       </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a11</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;j&lt;length (snd (&#915;, xs))&quot;</span></span></span><span>                                                               
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_suc</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst (snd (&#915;, xs) ! j) = fst(snd (&#915;,x#xs)! Suc j)&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (snd (&#915;, xs) ! j) = map (&#955;x. fst (snd x ! j)) zs&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_l_y_z</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length ys = length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Suc_j_l_ys</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. Suc j &lt; length (snd (ys!i))&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a11</span><span> </span><span>s_l</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>same_length_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. snd (zs!i) = tl (snd (ys!i))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> 
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>                  
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>l_xs_zs_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length (fst (snd (&#915;, xs) ! j)) = length zs&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_suc</span><span> </span><span>s_l_y_z</span><span> </span><span>s_p</span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>same_program_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>         
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length ys. 
           fst (snd (&#915;, x#xs) ! Suc j)!i = fst (snd (ys!i) ! (Suc j))&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_p</span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>same_program_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length zs. 
           fst (snd (&#915;, x#xs) ! Suc j)!i = fst (snd (zs!i) ! (j))&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_j_l_ys</span><span> </span><span>tail</span><span> </span><span>s_l_y_z</span><span> </span><span>tl_zero_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length zs. 
           fst (snd (&#915;, xs) ! j)!i = map (&#955;x. fst (snd x !  j)) zs!i&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>fst_suc</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (fst (snd (&#915;, xs) ! j)) = 
                   length (map (&#955;x. fst (snd x !  j)) zs) &quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>l_xs_zs_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>l_xs_zs_eq</span><span> </span><span>list_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>       </span><span class="keyword1"><span class="command">qed</span></span><span>                 
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_program  (&#915;,xs) zs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span>  </span><span>same_program_def</span><span> </span><span>same_length_def</span><span>     
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>same_prog</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_state  (&#915;,xs) zs&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_length_def</span><span> </span><span>same_state_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>List.nth_tl</span><span> </span><span>Suc_less_eq</span><span> </span><span>diff_Suc_1</span><span> </span><span>length_tl</span><span> </span><span>nth_Cons_Suc</span><span class="delimiter">)</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>same_sta</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_functions  (&#915;,xs) zs&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>same_functions_def</span><span class="delimiter">)</span><span>          
</span><span>     </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>same_fun</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span> </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>j</span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a11</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Suc j&lt;length (snd (&#915;, xs))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_l_y_z</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length ys = length zs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Suc_j_l_ys</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. Suc (Suc j) &lt; length (snd (ys!i))&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a11</span><span> </span><span>s_l</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>same_length_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>tail</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. snd (zs!i) = tl (snd (ys!i))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> 
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>    
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>same_env</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. (fst (ys!i)) = &#915;&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_functions_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;x. fst(&#915;, x) = &#915;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fun_ys_eq_fun_zs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. (fst (ys!i)) = (fst (zs!i))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>same_env</span><span> </span><span>s_l_y_z</span><span>
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n. &#172; n &lt; length ys &#8744; fst (zs ! n) = fst (ys ! n)&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a2</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>        </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>suc_j</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;Suc (Suc j) &lt; length (snd (&#915;, x#xs))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a11</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>or_compat</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;( (&#915; &#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, x#xs))!(Suc j))  &#8594; ((snd  (&#915;, x#xs))!(Suc (Suc j)))) &#8743; 
            (&#8707;i&lt;length ys. 
               ((fst (ys!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd (ys!i))!(Suc j))  &#8594; ((snd (ys!i))!(Suc (Suc j)))) &#8743; 
            (&#8704;l&lt;length ys. 
               l&#8800;i &#10230; (fst (ys!l))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (ys!l))!(Suc j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (ys!l))!(Suc (Suc j)))  ))) &#8744; 
            (&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, x#xs))!(Suc j))  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd  (&#915;, x#xs))!(Suc (Suc j))) &#8743; 
            (&#8704;i&lt;length ys. (fst (ys!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (ys!i))!(Suc j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (ys!i))!(Suc (Suc j)))))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>suc_j</span><span> </span><span>a1</span><span> </span><span>same_env</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>compat_label_def</span><span> </span><span>fst</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>         </span><span class="string"><span class="delete"><span class="delete">&quot;( (fst (&#915;, xs) &#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, xs))!(j))  &#8594; ((snd  (&#915;,xs))!((Suc j)))) &#8743; 
              (&#8707;i&lt;length zs. 
                 ((fst (zs!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd (zs!i))!( j))  &#8594; ((snd (zs!i))!( (Suc j)))) &#8743; 
              (&#8704;l&lt;length zs. 
                 l&#8800;i &#10230; (fst (zs!l))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (zs!l))!( j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (( snd (zs!l))!( (Suc j)))  )))&#8744;
               ((fst (&#915;, xs)&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, xs))!(j))  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd  (&#915;, xs))!((Suc j))) &#8743; 
           (&#8704;i&lt;length zs. (fst (zs!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (zs!i))!(j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (zs!i))!((Suc j)))   )))&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>         </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a21</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;( (&#915; &#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, x#xs))!(Suc j))  &#8594; ((snd  (&#915;, x#xs))!(Suc (Suc j)))) &#8743; 
              (&#8707;i&lt;length ys. 
                 ((fst (ys!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd (ys!i))!(Suc j))  &#8594; ((snd (ys!i))!(Suc (Suc j)))) &#8743; 
              (&#8704;l&lt;length ys. 
                 l&#8800;i &#10230; (fst (ys!l))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (ys!l))!(Suc j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (ys!l))!(Suc (Suc j)))  )))&quot;</span></span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>              </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;( (&#915; &#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, x#xs))!(Suc j))  &#8594; ((snd  (&#915;, x#xs))!(Suc (Suc j)))) &#8743; 
              (i&lt;length ys &#8743; 
                 ((fst (ys!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd (ys!i))!(Suc j))  &#8594; ((snd (ys!i))!(Suc (Suc j)))) &#8743; 
              (&#8704;l&lt;length ys. 
                 l&#8800;i &#10230; (fst (ys!l))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (ys!l))!(Suc j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (ys!l))!(Suc (Suc j)))  )))&quot;</span></span></span><span>       
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;( (&#915; &#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, x#xs))!(Suc j))  &#8594; ((snd  (&#915;, x#xs))!(Suc (Suc j)))) &#8743; 
              (&#8707;i&lt;length ys. 
                 ((fst (ys!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd (zs!i))!( j))  &#8594; ((snd (zs!i))!( (Suc j)))) &#8743; 
              (&#8704;l&lt;length ys. 
                 l&#8800;i &#10230; (fst (ys!l))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (zs!l))!( j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (( snd (zs!l))!( (Suc j)))  )))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> snd (&#915;, x # xs) ! Suc j &#8594; snd (&#915;, x # xs) ! Suc (Suc j) &#8743; i &lt; length ys &#8743; fst (ys ! i)&#8866;<span class="hidden">&#8681;</span><sub>c</sub> snd (ys ! i) ! Suc j &#8594; snd (ys ! i) ! Suc (Suc j) &#8743; (&#8704;n. (&#172; n &lt; length ys &#8744; n = i) &#8744; fst (ys ! n)&#8866;<span class="hidden">&#8681;</span><sub>c</sub> snd (ys ! n) ! Suc j &#8594;<span class="hidden">&#8681;</span><sub>e</sub> snd (ys ! n) ! Suc (Suc j))&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;j &lt; length (snd (&#915;, xs))&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>Suc_lessD</span><span> </span><span>a11</span><span class="delimiter">)</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n. &#172; n &lt; length zs &#8744; length (snd (zs ! n)) = length (snd (&#915;, xs))&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>same_len</span><span> </span><span>same_length_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n. &#172; n &lt; length ys &#8744; snd (zs ! n) = tl (snd (ys ! n))&quot;</span></span></span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>tail</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>                </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>                  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f3</span><span> </span><span>f2</span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span> </span><span>List.nth_tl</span><span> </span><span>a11</span><span> </span><span>s_l_y_z</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">qed</span></span><span>           
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span class="string"><span class="delete"><span class="delete">&quot;( (&#915; &#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, xs))!(j))  &#8594; ((snd  (&#915;,xs))!((Suc j)))) &#8743; 
              (&#8707;i&lt;length zs. 
                 ((fst (zs!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd (zs!i))!( j))  &#8594; ((snd (zs!i))!( (Suc j)))) &#8743; 
              (&#8704;l&lt;length zs. 
                 l&#8800;i &#10230; (fst (zs!l))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (zs!l))!( j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (( snd (zs!l))!( (Suc j)))  )))&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>same_env</span><span> </span><span>s_l_y_z</span><span> </span><span>fun_ys_eq_fun_zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>             </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span class="string"><span class="delete"><span class="delete">&quot;( (fst (&#915;, xs) &#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, xs))!(j))  &#8594; ((snd  (&#915;,xs))!((Suc j)))) &#8743; 
              (&#8707;i&lt;length zs. 
                 ((fst (zs!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd (zs!i))!( j))  &#8594; ((snd (zs!i))!( (Suc j)))) &#8743; 
              (&#8704;l&lt;length zs. 
                 l&#8800;i &#10230; (fst (zs!l))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (zs!l))!( j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (( snd (zs!l))!( (Suc j)))  )))&quot;</span></span></span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>             </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>             </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">next</span></span><span>    
</span><span>        </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a22</span><span class="delimiter">:</span><span>
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, x#xs))!(Suc j))  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd  (&#915;, x#xs))!(Suc (Suc j))) &#8743; 
            (&#8704;i&lt;length ys. (fst (ys!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (ys!i))!(Suc j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (ys!i))!(Suc (Suc j)))   ))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, x#xs))!(Suc j))  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd  (&#915;, x#xs))!(Suc (Suc j))) &#8743; 
           (&#8704;i&lt;length ys. (fst (ys!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (zs!i))!(j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (zs!i))!((Suc j)))   ))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Suc_j_l_ys</span><span> </span><span>tail</span><span> </span><span>s_l_y_z</span><span> </span><span>tl_zero_pair21</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>        </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd  (&#915;, xs))!(j))  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd  (&#915;, xs))!((Suc j))) &#8743; 
           (&#8704;i&lt;length zs. (fst (zs!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (snd (zs!i))!(j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (zs!i))!((Suc j)))   ))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>same_env</span><span> </span><span>s_l_y_z</span><span> </span><span>fun_ys_eq_fun_zs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;compat_label  (&#915;,xs) zs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compat_label_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>same_label</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clist_tail</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length clist&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>    </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;ys = (map (&#955;i. (&#915;,(fst i,s)#snd i)) (zip xs clist))&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ys. tl (snd (ys!i)) = clist!i &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>   
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a1</span><span class="delimiter">)</span><span>           
</span><span class="keyword1"><span class="command">qed</span></span><span>   
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clist_map</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length clist&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map ((&#955;p. tl (snd p)) &#8728; (&#955;i. (&#915;, (fst i, s) # snd i))) (zip xs clist)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map snd (zip xs clist) = clist&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>map_snd_zip</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map snd (zip xs clist) = map ((&#955;p. tl (snd p)) &#8728; (&#955;p. (&#915;, (fst p, s) # snd p))) (zip xs clist)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>f1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clist_map1</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> 
</span><span>    </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length clist&quot;</span></span></span><span>     
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;p. tl (snd p)) (map (&#955;i. (&#915;,(fst i,s)#snd i)) (zip xs clist))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map ((&#955;p. tl (snd p)) &#8728; (&#955;i. (&#915;, (fst i, s) # snd i))) (zip xs clist)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>  </span><span>clist_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clist_map2</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;(clist = map (&#955;p. tl (snd p)) (l::(&#39;a &#215;&#39;b list) list) ) &#10233;
       clist = map (&#955;p. (snd p)) (map (&#955;p. (fst p, tl (snd p))) (l::(&#39;a &#215;&#39;b list) list)) &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_snd</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y = map  (&#955;x. f x) l&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;y=(map snd (map (&#955;x. (g x, f x)) l)) &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>assms</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>map_snd_sym</span><span> </span><span class="delimiter">=</span><span> </span><span>map_snd</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_snd&#39;</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot; map  (&#955;x. f x) l=(map snd (map (&#955;x. (g x, f x)) l)) &quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clist_snd</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, a # ys) &#8733; map (&#955;x. (fst x, tl (snd x)))
                    (map (&#955;i. (&#915;, (fst i, s) # snd i)) (zip xs clist))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length clist &gt; 0 &#8743; length clist = length xs&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist = (map snd
          (map (&#955;x. (&#915;, (fst x, snd (clist ! 0 ! 0)) # snd x))
            (zip (map (&#955;x. fst (hd x)) clist) (map tl clist))))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?concat_zip</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;i. (&#915;, (fst i, s) # snd i))&quot;</span></span></span><span>  
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist_ext</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map ?concat_zip (zip xs clist)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?exec_run</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs, s) # a # ys&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?exec</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,?exec_run)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?exec_ext</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. (fst x, tl (snd x))) ?clist_ext&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?zip</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(zip (map (&#955;x. fst (hd x)) clist) 
                         (map (&#955;x. tl x) clist))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>&#915;_all</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?clist_ext. fst (?clist_ext !i) = &#915;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length clist&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_clist_exec</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length ?exec_ext&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_clist_exec_map</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length ?exec_ext = 
              length (map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) 
                          ?zip)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>               
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_snd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;x. snd x) ?exec_ext&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_map1</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span> </span><span>clist</span><span> </span><span>&#915;</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>clist_map2</span><span> </span><span>len</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_len_eq_ays</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. length( (clist!i))=length (snd (&#915;,a#ys))&quot;</span></span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len</span><span>  </span><span>same_length_non_pair</span><span> </span><span>a1</span><span> </span><span>conjoin_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_gz</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. length (clist!i) &gt; 0&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_len_eq</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. &#8704;j &lt; length clist. 
        length (clist ! i) = length (clist ! j)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_len_eq_ays</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_same_state</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. &#8704;j&lt; length clist. &#8704;k&lt;length  (clist!i).
       snd ((clist!i)!k) = snd ((clist!j)!k)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i &lt;length clist. &#8704;j&lt;length (snd (&#915;, a # ys)). snd((snd (&#915;, a # ys))!j) = snd( (clist!i)!j))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len</span><span> </span><span>clist_snd</span><span> </span><span>conjoin_def</span><span> </span><span>a1</span><span> </span><span>conjoin_def</span><span> </span><span>same_state_non_pair</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_len_eq_ays</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_map</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;i. (fst i,snd ((clist!0)!0))#snd i) ?zip&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_as_map</span><span> </span><span>a2</span><span> </span><span>clist_gz</span><span> </span><span>clist_len_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;i. (fst i,snd ((clist!0)!0))#snd i) ?zip =
             map snd (map (&#955;x. (&#915;, (fst x, snd (clist ! 0 ! 0)) # snd x))
       (zip (map (&#955;x. fst (hd x)) clist) (map tl clist)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_snd&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>list_as_zip</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, a # ys) &#8733; map (&#955;x. (fst x, tl (snd x)))
                    (map (&#955;i. (&#915;, (fst i, s) # snd i)) (zip xs clist))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>         </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length clist &gt; 0 &#8743; length clist = length xs&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;  map (&#955;x. (fst x, tl (snd x)))
                    (map (&#955;i. (&#915;, (fst i, s) # snd i)) (zip xs clist)) =
          map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) 
                       (zip (map (&#955;x. fst (hd x)) clist) 
                         (map (&#955;x. tl x) clist))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?concat_zip</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;i. (&#915;, (fst i, s) # snd i))&quot;</span></span></span><span>  
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist_ext</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map ?concat_zip (zip xs clist)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?exec_run</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs, s) # a # ys&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?exec</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,?exec_run)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?exec_ext</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. (fst x, tl (snd x))) ?clist_ext&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?zip</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(zip (map (&#955;x. fst (hd x)) clist) 
                         (map (&#955;x. tl x) clist))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>&#915;_all</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?clist_ext. fst (?clist_ext !i) = &#915;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length clist&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_clist_exec</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length ?exec_ext&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_clist_exec_map</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;length ?exec_ext = 
              length (map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) 
                          ?zip)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>               
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_snd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;x. snd x) ?exec_ext&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_map1</span><span> </span><span class="delimiter">[</span><span>of</span><span> </span><span>xs</span><span> </span><span>clist</span><span> </span><span>&#915;</span><span> </span><span>s</span><span class="delimiter">]</span><span> </span><span>clist_map2</span><span> </span><span>len</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_len_eq_ays</span><span class="delimiter">:</span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. length( (clist!i))=length (snd (&#915;,a#ys))&quot;</span></span></span><span>      
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len</span><span>  </span><span>same_length_non_pair</span><span> </span><span>a1</span><span> </span><span>conjoin_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_gz</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. length (clist!i) &gt; 0&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_len_eq</span><span class="delimiter">:</span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. &#8704;j &lt; length clist. 
        length (clist ! i) = length (clist ! j)&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_len_eq_ays</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>          
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_same_state</span><span class="delimiter">:</span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. &#8704;j&lt; length clist. &#8704;k&lt;length  (clist!i).
       snd ((clist!i)!k) = snd ((clist!j)!k)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i &lt;length clist. &#8704;j&lt;length (snd (&#915;, a # ys)). snd((snd (&#915;, a # ys))!j) = snd( (clist!i)!j))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len</span><span> </span><span>clist_snd</span><span> </span><span>conjoin_def</span><span> </span><span>a1</span><span> </span><span>conjoin_def</span><span> </span><span>same_state_non_pair</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_len_eq_ays</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>      
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_map</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;i. (fst i,snd ((clist!0)!0))#snd i) ?zip&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_as_map</span><span> </span><span>a2</span><span> </span><span>clist_gz</span><span> </span><span>clist_len_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>      
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. 
                clist ! i = (fst (?zip!i),snd ((clist!0)!0)) # snd (?zip!i)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len</span><span> </span><span>nth_map</span><span> </span><span>length_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. 
     ?exec_ext ! i = (&#915;, (fst (?zip!i),snd ((clist!0)!0)) # snd (?zip!i))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>&#915;_all</span><span> </span><span>len</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>           
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. 
    (&#915;, (fst (?zip!i),snd ((clist!0)!0)) # snd (?zip!i)) = 
    (map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) 
                          ?zip)!i&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>        
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. 
       ?exec_ext ! i =(map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) 
                          ?zip)!i&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length ?exec_ext&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>exec_ext_eq_clist_map</span><span class="delimiter">:</span><span>
</span><span>     </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?exec_ext. 
       ?exec_ext ! i =(map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) 
                          ?zip)!i&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length ?exec_ext = 
              length (map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) 
                          ?zip)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>len</span><span> </span><span>clist_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>    
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hd_nth</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt; length l &#8743; ( length( (l!i)) &gt; 0)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;f (hd (l!i)) = f (nth (l!i) 0)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span> </span><span>hd_conv_nth</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>map_hd_nth</span><span class="delimiter">:</span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i &lt;length l. length( (l!i)) &gt; 0)&quot;</span></span></span><span>
</span><span>   </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. f (hd x)) l = map (&#955;x. f (nth (x) 0)) l&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length l. (map (&#955;x. f (hd x)) l)!i = f (nth (l!i) 0)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd_nth</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length l. (map (&#955;x. f (nth x 0)) l)!i = f (nth (l!i) 0)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hd_nth</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length l. (map (&#955;x. f (hd x)) l)!i =(map (&#955;x. f (nth x 0)) l)!i &quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length (map (&#955;x. f (hd x)) l) = length l&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (map (&#955;x. f (nth x 0)) l) = length l&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_equalityI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length clist &#10233; clist!i = (x1,ys) &#10233; ys = (map (&#955;x. (fst (hd (snd x)),s)#tl (snd x)) clist)!i &#10233;
         ys = (map (&#955;x. (fst x, s)#snd x) 
               (zip (map (&#955;x. fst (hd (snd x))) clist) 
                    (map (&#955;x. tl (snd x)) clist)))!i&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>y</span><span> </span><span>ys</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;n ps f. &#172; n &lt; length ps &#8744; map f ps ! n = (f (ps ! n::&#39;a &#215; (&#39;b &#215; &#39;c) list)::(&#39;b &#215; &#39;c) list)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;y # ys = (fst (hd (snd (clist ! i))), s) # tl (snd (clist ! i))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>3</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>presburger</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>clist_map_zip</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[] &#10233; (&#915;,(xs,s)#ys) &#8733; clist &#10233; 
      clist = map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs ((map (&#955;x. tl (snd x))) clist))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map snd clist&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(xs,s)#ys) &#8733; clist&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_in_clist_not_empty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?clist. (?clist!i) &#8800; []&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_length_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>hd_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?clist. hd (?clist!i) = (?clist!i)!0&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_conv_nth</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt; length ?clist. fst (hd (?clist!i)) = xs!i&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span>all_s</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?clist. snd (hd (?clist!i)) = s&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span>hd_clist</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_state_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_clist_&#915;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length clist. fst (clist!i) = &#915;&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_functions_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>p2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length clist&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_same_length</span><span> </span><span>a2</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  
</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt; length (map (&#955;x. fst (hd x)) ?clist). 
               (map (&#955;x. fst (hd x)) ?clist)!i = xs!i&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_xs</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (map (&#955;x. fst (hd x)) ?clist) = length xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (&#955;x. fst (hd x)) ?clist) = xs&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_equalityI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. fst (hd (snd x))) clist = xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>       
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_hd_tl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?clist. ?clist!i = hd (?clist!i) # (tl (?clist!i))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_in_clist_not_empty</span><span> </span><span>list.exhaust_sel</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?clist. ?clist!i =(fst  (hd (?clist!i)),snd  (hd (?clist!i)))# (tl (?clist!i))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?clist = map (&#955;x. (fst (hd x),snd (hd x))#tl x) ?clist&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_map</span><span> </span><span>list_eq_iff_nth_eq</span><span> </span><span>list_update_id</span><span> </span><span>map_update</span><span> </span><span>nth_list_update_eq</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span>length_map</span><span> </span><span>list_eq_iff_nth_eq</span><span> </span><span>list_update_id</span><span> </span><span>map_update</span><span> </span><span>nth_list_update_eq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?clist = map (&#955;x. (fst (hd x),s)#tl x) ?clist&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>all_s</span><span> </span><span>length_map</span><span> </span><span>nth_equalityI</span><span> </span><span>nth_map</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>map_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. (fst (hd (snd x)),s)#tl (snd x)) clist = ?clist&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (&#955;x. (fst x, s)#snd x) 
               (zip (map (&#955;x. fst (hd (snd x))) clist) 
                    (map (&#955;x. tl (snd x)) clist))) =  ?clist&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_clist</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length clist. clist!i =  (&#915;,(map (&#955;x. (fst x, s)#snd x) 
               (zip xs 
                   (map (&#955;x. tl (snd x)) clist)))!i)&quot;</span></span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>xs_clist</span><span> </span><span>fst_clist_&#915;</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length (map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs ((map (&#955;x. tl (snd x))) clist)))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs ((map (&#955;x. tl (snd x))) clist))&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>length_map</span><span> </span><span>length_zip</span><span> </span><span>nth_equalityI</span><span> </span><span>nth_map</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>lifting</span><span class="delimiter">)</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>            
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aux_if&#39;</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length clist &gt; 0 &#8743; length clist = length xs &#8743; 
             (&#8704;i&lt;length xs. (&#915;,(xs!i,s)#clist!i) &#8712; cptn) &#8743; 
             ((&#915;,(xs, s)#ys) &#8733; map (&#955;i. (&#915;,(fst i,s)#snd i)) (zip xs clist))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(xs, s)#ys) &#8712; par_cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>xs</span><span> </span><span>s</span><span> </span><span>clist</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>par_cptn.ParCptnOne</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>ys</span><span> </span><span>xs</span><span> </span><span>s</span><span> </span><span>clist</span><span class="delimiter">)</span><span>     
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?concat_zip</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#955;i. (&#915;, (fst i, s) # snd i))&quot;</span></span></span><span>  
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?com_clist_xs</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map ?concat_zip (zip xs clist)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xs_a_ys_run</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(xs, s) # a # ys&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xs_a_ys_run_exec</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,?xs_a_ys_run)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?com_clist&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. (fst x, tl (snd x))) ?com_clist_xs&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?xs&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (&#955;x. fst (hd x)) clist)&quot;</span></span></span><span>     
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (&#955;x. tl x) clist)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?zip_xs&#39;_clist&#39;</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;zip ?xs&#39; 
                            ?clist&#39;&quot;</span></span></span><span>         
</span><span>     </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>sa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a_pair</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a=(as,sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?comp_clist&#39;_alt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) ?zip_xs&#39;_clist&#39; &quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist&#39;_alt</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. snd x) ?comp_clist&#39;_alt&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?comp_a_ys</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (as,sa) # ys)&quot;</span></span></span><span>   
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conjoin_hyp1</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (as,sa) # ys) &#8733; ?com_clist&#39;&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_tl</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_pair</span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>     
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conjoin_hyp</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (as,sa) # ys) &#8733; map (&#955;x. (&#915;, (fst x,snd ((clist!0)!0))#snd x)) ?zip_xs&#39;_clist&#39;&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>list_as_zip</span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>    
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length clist&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_snd_map</span><span class="delimiter">:</span><span>
</span><span>        </span><span class="string"><span class="delete"><span class="delete">&quot;(map snd
          (map (&#955;x. (&#915;, (fst x, snd (clist ! 0 ! 0)) # snd x))
         (zip (map (&#955;x. fst (hd x)) clist) (map tl clist)))) = clist&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_snd</span><span> </span><span>Cons.prems</span><span> </span><span>conjoin_hyp1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_len_clist_clist&#39;</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;length ?clist&#39; &gt; 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i &lt;length clist. &#8704;j&lt;length (snd ?comp_a_ys). snd((snd ?comp_a_ys)!j) = snd( (clist!i)!j))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_snd_map</span><span> </span><span>conjoin_hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_state_non_pair</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?comp_a_ys</span><span> </span><span class="var">?comp_clist&#39;_alt</span><span> </span><span class="var">?clist&#39;_alt</span><span class="delimiter">]</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>   
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length clist.
                  sa = snd ( (clist ! i)!0)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>     </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_i_grz</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i &lt;length clist. length( (clist!i)) &gt; 0)&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_snd_map</span><span> </span><span>conjoin_hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_length_non_pair</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?comp_a_ys</span><span> </span><span class="var">?comp_clist&#39;_alt</span><span> </span><span class="var">?clist&#39;_alt</span><span class="delimiter">]</span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>     </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_i_sa_hd_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length clist.
                  sa = snd (hd (clist ! i))&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_conv_nth</span><span class="delimiter">)</span><span>      
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>as_sa_eq_xs&#39;_s&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;as = ?xs&#39; &#8743;  sa = snd ((clist!0)!0)&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>              
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;j&lt;length (snd ?comp_a_ys). fst((snd ?comp_a_ys)!j) = 
                map (&#955;x. fst(nth x j)) ?clist&#39;_alt)&quot;</span></span></span><span>       
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_program_non_pair</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?comp_a_ys</span><span> </span><span class="var">?comp_clist&#39;_alt</span><span> </span><span class="var">?clist&#39;_alt</span><span class="delimiter">]</span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fast</span><span>
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>are_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst((snd ?comp_a_ys)!0) = 
                map (&#955;x. fst(nth x 0)) ?clist&#39;_alt&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>fst_exec_is_as</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;fst((snd ?comp_a_ys)!0) =as&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>              
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. fst(hd x)) clist=map (&#955;x. fst(x!0)) clist&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>map_hd_nth</span><span> </span><span>clist_i_grz</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>       </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;x. fst(nth x 0)) ?clist&#39;_alt =?xs&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_snd_map</span><span> </span><span>map_hd_nth</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i &lt;length clist. &#8704;j&lt;length (snd ?comp_a_ys). snd((snd ?comp_a_ys)!j) = snd( (clist!i)!j))&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_snd_map</span><span> </span><span>conjoin_hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_state_non_pair</span><span class="delimiter">[</span><span>of</span><span> </span><span class="var">?comp_a_ys</span><span> </span><span class="var">?comp_clist&#39;_alt</span><span> </span><span class="var">?clist&#39;_alt</span><span class="delimiter">]</span><span>
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>       </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>are_eq</span><span> </span><span>fst_exec_is_as</span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conjoin_hyp</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (as,sa) # ys) &#8733; map (&#955;x. (&#915;, (fst x,sa)#snd x))
                            (zip as (map tl clist))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_hyp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>eq_len_as_clist&#39;</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;length as = length ?clist&#39;&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span>as_sa_eq_xs&#39;_s&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>len_as_ys_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length as = length xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; (&#8704;i&lt;length as. (&#915;, ((as!i),sa)#(map (&#955;x. tl x) clist)!i) &#8712; cptn)&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span>cptn_dest</span><span> </span><span>clist_snd_map</span><span> </span><span>len</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>     
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length clist. clist!i = (hd (clist!i))#(tl (clist!i))&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_i_grz</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length clist. (&#915;, (xs ! i, s) # (hd (clist!i))#(tl (clist!i))) &#8712; cptn)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.prems</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length clist. (&#915;, (hd (clist!i))#(tl (clist!i))) &#8712; cptn)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>list.distinct</span><span class="delimiter">(</span><span>2</span><span class="delimiter">)</span><span> </span><span>tl_in_cptn</span><span class="delimiter">)</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length clist. (&#915;, ((as!i),sa)#(tl (clist!i))) &#8712; cptn)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>as_sa_eq_xs&#39;_s&#39;</span><span> </span><span>all_i_sa_hd_clist</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length clist. (&#915;, ((as!i),sa)#(map (&#955;x. tl x) clist)!i) &#8712; cptn)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>len</span><span> </span><span>clist_i_grz</span><span> </span><span>len_as_ys_eq</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a_ys_par_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (as, sa) # ys) &#8712; par_cptn&quot;</span></span></span><span>           
</span><span>   </span><span class="keyword1"><span class="command">using</span></span><span> 
</span><span>    </span><span>conjoin_hyp</span><span> </span><span>eq_len_clist_clist&#39;</span><span> </span><span>eq_len_as_clist&#39;</span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span> </span><span>Cons.hyps</span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>  
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>&#915;_all</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length ?com_clist_xs. fst (?com_clist_xs !i) = &#915;&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>Gamma</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;= (fst ?xs_a_ys_run_exec)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>exec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;?xs_a_ys_run = (snd ?xs_a_ys_run_exec)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>split_par</span><span class="delimiter">:</span><span>
</span><span>       </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> ((xs, s) # a # ys) ! 0 &#8594; ((a # ys) ! 0) &#8744;
        &#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> ((xs, s) # a # ys) ! 0 &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((a # ys) ! 0)&quot;</span></span></span><span>     
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>compat_label_def</span><span> </span><span>compat_label_tran_0</span><span>
</span><span>             </span><span>Cons.prems</span><span> </span><span>Gamma</span><span> </span><span>exec</span><span> 
</span><span>             </span><span>compat_label_tran_0</span><span class="delimiter">[</span><span>of</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # a # ys)&quot;</span></span></span><span> 
</span><span>                                   </span><span class="string"><span class="delete"><span class="delete">&quot;(map (&#955;i. (&#915;, (fst i, s) # snd i)) (zip xs clist))&quot;</span></span></span><span class="delimiter">]</span><span>    
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>      
</span><span>     </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> ((xs, s) # a # ys) ! 0 &#8594; ((a # ys) ! 0)&quot;</span></span></span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot; (&#915;, (xs, s) # a # ys) &#8712; par_cptn&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_ys_par_cptn</span><span> </span><span>a_pair</span><span> </span><span>par_cptn.ParCptnComp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>env_sol</span><span class="delimiter">=</span><span>this</span><span>
</span><span>     </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; &#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> ((xs, s) # a # ys) ! 0 &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((a # ys) ! 0)&quot;</span></span></span><span>      
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>env_tran</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; &#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (xs, s)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (as,sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs = as&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>env_pe_c_c&#39;_false</span><span> </span><span>env_tran</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; (&#915;, (xs, s) # a # ys) &#8712; par_cptn&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a_ys_par_cptn</span><span> </span><span>a_pair</span><span> </span><span>env_tran</span><span> </span><span>ParCptnEnv</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # a # ys) &#8712; par_cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>env_sol</span><span> </span><span>Cons</span><span> </span><span>split_par</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mapzip_upd</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; length as = length clist  &#10233;
       (map (&#955;j. (as ! j, sa) # clist ! j) [0..&lt;length as]) =  
       map (&#955;j. ((fst j, sa)#snd j)) (zip as clist)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>    
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length as = length clist&quot;</span></span></span><span>   
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length  (map (&#955;j. (as ! j, sa) # clist ! j) [0..&lt;length as]). (map (&#955;j. (as ! j, sa) # clist ! j) [0..&lt;length as])!i = map (&#955;j. ((fst j, sa)#snd j)) (zip as clist)!i&quot;</span></span></span><span>  
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length (map (&#955;j. (as ! j, sa) # clist ! j) [0..&lt;length as]) =
         length (map (&#955;j. ((fst j, sa)#snd j)) (zip as clist))&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(map (&#955;j. (as ! j, sa) # clist ! j) [0..&lt;length as]) = map (&#955;j. ((fst j, sa)#snd j)) (zip as clist)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_equalityI</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;j. (as ! j, sa) # clist ! j) [0..&lt;length as] = 
        map (&#955;j. (fst j, sa) # snd j) (zip as clist) &quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aux_if</span><span> </span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>a</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot; length clist = length xs &#8743; 
             (&#8704;i&lt;length xs. (&#915;,(xs!i,s)#clist!i) &#8712; cptn) &#8743; 
             ((&#915;,(xs, s)#ys) &#8733; map (&#955;i. (&#915;,(fst i,s)#snd i)) (zip xs clist))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(xs, s)#ys) &#8712; par_cptn&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length clist&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>0</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_empty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;clist = []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>map_clist_empty</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;i. (&#915;,(fst i,s)#snd i)) (zip xs clist) = []&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conjoin</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(xs, s)#ys) &#8733; []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>   
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>all_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j&lt;length (snd (&#915;,(xs, s)#ys)). fst (snd (&#915;,(xs, s)#ys) ! j) = []&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conjoin</span><span>          
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span> </span><span>arbitrary</span><span class="delimiter">:</span><span> </span><span>s</span><span> </span><span>xs</span><span class="delimiter">)</span><span> 
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>par_cptn.ParCptnOne</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>       </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>ys</span><span class="delimiter">)</span><span>          
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conjoin_ind</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # a # ys) &#8733; []&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,(a # ys)) &#8733; []&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>conjoin_def</span><span> </span><span>same_length_def</span><span> 
</span><span>                 </span><span>same_state_def</span><span> </span><span>same_program_def</span><span> </span><span>same_functions_def</span><span>
</span><span>                 </span><span>compat_label_def</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">moreover</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>sa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>pair_a</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=(as,sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ays_par_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, a # ys) &#8712; par_cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;j. Suc j&lt;length (snd (&#915;,(xs, s)#(as,sa)#ys)) &#10230; 
                   &#172;(&#8707;i&lt;length []. 
                     ((fst ([]!i))&#8866;<span class="hidden">&#8681;</span><sub>c</sub> ((snd ([]!i))!j)  &#8594; ((snd ([]!i))!(Suc j))))&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_def</span><span> </span><span>compat_label_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;j. Suc j&lt;length (snd (&#915;,(xs, s)#(as,sa)#ys)) &#10230; 
                    ((fst (&#915;,(xs, s)#(as,sa)#ys))&#8866;<span class="hidden">&#8681;</span><sub>p</sub>((snd (&#915;,(xs, s)#(as,sa)#ys))!j)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> ((snd (&#915;,(xs, s)#(as,sa)#ys))!(Suc j))))&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_def</span><span> </span><span>compat_label_def</span><span> </span><span>conjoin_ind</span><span> </span><span>pair_a</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>env_tran</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (xs, s)  &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (as,sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>               
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; (&#915;, (xs, s) # a # ys) &#8712; par_cptn&quot;</span></span></span><span> 
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ays_par_cptn</span><span> </span><span>pair_a</span><span> </span><span>env_tran</span><span> </span><span>ParCptnEnv</span><span> </span><span>env_pe_c_c&#39;_false</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span> </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Suc</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length clist &gt; 0&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a</span><span> </span><span>aux_if&#39;</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snormal_enviroment</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;s = Normal nsa &#8744; s = sa &#8743; (&#8704;sa. s &#8800; Normal sa) &#10233;
        &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (x, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (x, sa)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>aux_onlyif</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;xs s. (&#915;,(xs, s)#ys) &#8712; par_cptn &#10230; 
  (&#8707;clist. (length clist = length xs) &#8743; 
  (&#915;, (xs, s)#ys) &#8733; map (&#955;i. (&#915;, (fst i,s)#(snd i))) (zip xs clist) &#8743; 
  (&#8704;i&lt;length xs. (&#915;, (xs!i,s)#(clist!i)) &#8712; cptn))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>ys</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>xs</span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(xs, s)]) &#8712; par_cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length (map (&#955;i. []) [0..&lt;length xs]) = length xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, [(xs, s)]) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                              (zip xs (map (&#955;i. []) [0..&lt;length xs]))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_length_def</span><span> </span><span>same_functions_def</span><span> </span><span>same_state_def</span><span> </span><span>same_program_def</span><span> </span><span>compat_label_def</span><span>            
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span> </span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>h</span><span> </span><span class="delimiter">=</span><span> </span><span>conjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>f1</span><span> </span><span>f2</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>f3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # (map (&#955;i. []) [0..&lt;length xs]) ! i) &#8712; cptn)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cptn.CptnOne</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>this</span><span> </span><span class="delimiter">=</span><span> </span><span>conjI</span><span class="delimiter">[</span><span>OF</span><span> </span><span>h</span><span> </span><span>f3</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>ys</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span>  </span><span>xs</span><span> </span><span>s</span><span>
</span><span>   </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # a # ys) &#8712; par_cptn&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>as</span><span> </span><span>sa</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a_pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=(as,sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>par_cptn&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;,( (as,sa)#ys)) &#8712; par_cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>par_cptn_dest</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>clist</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>hyp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;
              length clist = length as &#8743;
              (&#915;, (as, sa) #
                   ys) &#8733; map (&#955;i. (&#915;, (fst i, sa) # snd i)) (zip as clist) &#8743;
              (&#8704;i&lt;length as. (&#915;, (as ! i, sa) # clist ! i) &#8712; cptn)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Cons.hyps</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a11</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # (as,sa) # ys) &#8712; par_cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>   </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>par_cptn_dest</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (xs, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (as, sa) &#8744; &#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (xs, s) &#8594; (as, sa)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>par_cptn_elim_cases</span><span> </span><span>par_cptn&#39;</span><span> </span><span>a1</span><span>  </span><span>a_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (xs, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (as, sa)&quot;</span></span></span><span>          
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs_as_eq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs=as&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>meson</span><span> </span><span>env_pe_c_c&#39;_false</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ce</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i &lt; length xs. &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (xs!i, s) &#8594;<span class="hidden">&#8681;</span><sub>e</sub> (as!i, sa)&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>pe_ce</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(map (&#955;j. (xs!j, sa)#(clist!j)) [0..&lt;length xs])&quot;</span></span></span><span>    
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length ?clist = length xs&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # ?clist ! i) &#8712; cptn)&quot;</span></span></span><span>  
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>hyp</span><span> </span><span>CptnEnv</span><span> </span><span>xs_as_eq</span><span> </span><span>ce</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) #
                       (as,sa) # ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist)&quot;</span></span></span><span>     
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>        
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_len</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;same_length (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_length_def</span><span> </span><span>xs_as_eq</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_state</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_state (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_state_def</span><span>  </span><span>a1</span><span class="delimiter">)</span><span>              
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">)</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_as_eq</span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_as_eq</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_function</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_functions (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_functions_def</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_program</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_program (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span>          
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span> </span><span>same_length_def</span><span> </span><span>a1</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">)</span><span>                
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">)</span><span> 
</span><span>                </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>              
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hyp</span><span> </span><span>xs_as_eq</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>xs_as_eq</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_compat</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;compat_label (&#915;, (xs, s) # (xs,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span> </span><span>a1</span><span> </span><span>pe_ce</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>hyp</span><span> </span><span>conjoin_def</span><span> </span><span>compat_label_def</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">,</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_as_eq</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>xs_as_eq</span><span> </span><span>step_e.intros</span><span> </span><span>step_pe.intros</span><span class="delimiter">)</span><span>
</span><span>             </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span>assumption</span><span class="delimiter">)</span><span>             
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>i</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span class="delimiter">)</span><span class="delimiter">+</span><span>                            
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_len</span><span> </span><span>s_program</span><span> </span><span>s_state</span><span> </span><span>s_function</span><span> </span><span>conjoin_def</span><span> </span><span>xs_as_eq</span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;clist.
                  length clist = length xs &#8743;
                  (&#915;, (xs, s) #
                       a # ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs clist) &#8743;
                  (&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # clist ! i) &#8712; cptn))&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span>a_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>s1</span><span class="delimiter">=</span><span>this</span><span>
</span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>p</sub> (xs, s) &#8594; (as, sa)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>i</span><span> </span><span>r</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>       </span><span>inter_tran</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i &lt; length xs &#8743; &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (xs ! i, s) &#8594; (r, sa) &#8743; as = xs[i := r]&quot;</span></span></span><span> 
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_p_pair_elim_cases</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>metis</span><span>     
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>xs_as_eq_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length xs = length as&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>     </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>inter_tran</span><span> 
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_states</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;nsa. s=Normal nsa &#8744; (s=sa &#8743; (&#8704;sa. (s&#8800;Normal sa)))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>step_not_normal_s_eq_t</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>as_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&#39;&lt;length as. (i&#39;=i &#8743; as!i&#39;=r) &#8744; (as!i&#39;=xs!i&#39;)&quot;</span></span></span><span> 
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>xs_as_eq_len</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>inter_tran</span><span> </span><span>nth_list_update</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?clist</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;(map (&#955;j. (as!j, sa)#(clist!j)) [0..&lt;length xs]) [i:=((r, sa)#(clist!i))]&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length ?clist = length xs&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&#39;&lt;length xs. (&#915;, (xs ! i&#39;, s) # ?clist ! i&#39;) &#8712; cptn)&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>         </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i&#39;</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&#39; &lt; length xs&quot;</span></span></span><span>          
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs ! i&#39;, s) # ?clist ! i&#39;) &#8712; cptn&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=i&#39;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>True</span><span> 
</span><span>             </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inter_tran</span><span>  </span><span>hyp</span><span> </span><span>cptn.CptnComp</span><span>               
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>  
</span><span>          </span><span class="keyword1"><span class="command">next</span></span><span>              
</span><span>            </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>False</span><span>            
</span><span>            </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_states</span><span> </span><span>inter_tran</span><span>  </span><span>False</span><span> </span><span>hyp</span><span> </span><span>cptn.CptnComp</span><span> </span><span>a1</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>i&#39;</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>CptnEnv</span><span class="delimiter">)</span><span> 
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Env</span><span> </span><span>Env_n</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>      </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) #
                       (as,sa) # ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist)&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hyp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>         </span><span>len_list</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length as&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>        </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hyp</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>same_len</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;same_length (&#915;, (as, sa) # ys)  
                      (map (&#955;i. (&#915;, (fst i, sa) # snd i)) (zip as clist))&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>        
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_len</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_length (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span>  
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> 
</span><span>            </span><span>same_len</span><span>  </span><span>inter_tran</span><span>  
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_length_def</span><span>
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span> 
</span><span>            </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=ia&quot;</span></span></span><span class="delimiter">)</span><span>            
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>len_list</span><span class="delimiter">)</span><span>            
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_state</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_state (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span> </span><span>inter_tran</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_state_def</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">,</span><span> </span><span>simp</span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_simp</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span>               </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=ia&quot;</span></span></span><span class="delimiter">,</span><span>simp</span><span> </span><span class="delimiter">,</span><span> </span><span>simp</span><span> </span><span class="delimiter">)</span><span>
</span><span>              </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>metis</span><span> </span><span class="delimiter">(</span><span>no_types</span><span class="delimiter">,</span><span> </span><span>hide_lams</span><span class="delimiter">)</span><span> </span><span>as_xs</span><span> </span><span>nth_list_update_eq</span><span> </span><span>xs_as_eq_len</span><span class="delimiter">)</span><span>              
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_function</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_functions (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span>
</span><span>              </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span> </span><span>conjoin_def</span><span> </span><span>same_functions_def</span><span> </span><span>a1</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_program</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;same_program (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span>          
</span><span>          </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>hyp</span><span> </span><span>inter_tran</span><span> </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>same_program_def</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>           
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;j. H j &#10230; (fst (a j))=((b j))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span>a</span><span> </span><span>b</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>nat</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=ia&quot;</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=ia&quot;</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>                   
</span><span>        </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>s_compat</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;compat_label (&#915;, (xs, s) # (as,sa) # ys) 
                           (map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs ?clist))&quot;</span></span></span><span> 
</span><span>        </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>inter_tran</span><span> </span><span>hyp</span><span> </span><span>s_states</span><span>
</span><span>        </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>conjoin_def</span><span> </span><span>compat_label_def</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>j</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>ParComp</span><span class="delimiter">,</span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>exI</span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x</span><span class="delimiter">=</span><span>i</span><span class="delimiter">]</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>snormal_enviroment</span><span class="delimiter">,</span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>nat</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;j. H j &#10230; (P j &#8744; Q j)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span>P</span><span> </span><span>Q</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s = Normal nsa &#8744; s = sa &#8743; (&#8704;sa. s &#8800; Normal sa)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>disjE</span><span> </span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ia</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=ia&quot;</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=l&quot;</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;l=ia&quot;</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>l</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span>assumption</span><span class="delimiter">,</span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>l</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span>assumption</span><span class="delimiter">,</span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; &#8704;ia&lt;length xs. (&#915;, (xs[i := r] ! ia, sa) # clist ! ia) &#8712; cptn&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>ia</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;j. H j &#10230; (P j)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span>P</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>impE</span><span class="delimiter">,</span><span> </span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i=ia&quot;</span></span></span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>               
</span><span>        </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s_len</span><span> </span><span>s_program</span><span> </span><span>s_state</span><span> </span><span>s_function</span><span> </span><span>conjoin_def</span><span>  
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>     
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;clist.
                  length clist = length xs &#8743;
                  (&#915;, (xs, s) #
                       a # ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs clist) &#8743;
                  (&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # clist ! i) &#8712; cptn))&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1</span><span> </span><span>s2</span><span> </span><span>a_pair</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>   </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;clist.
                  length clist = length xs &#8743;
                  (&#915;, (xs, s) #
                       a # ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                                   (zip xs clist) &#8743;
                  (&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # clist ! i) &#8712; cptn))&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>s1</span><span> </span><span>par_cptn_dest</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>  
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?case</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>  
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_iff_aux_if</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[] &#10233; (&#8704;ys. ((&#915;,((xs, s)#ys)) &#8712; par_cptn) = 
 (&#8707;clist. length clist= length xs &#8743; 
 ((&#915;,(xs, s)#ys) &#8733; map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs clist)) &#8743; 
 (&#8704;i&lt;length xs. (&#915;,(xs!i,s)#(clist!i)) &#8712; cptn))) &#10233;
 (par_cp &#915; (xs) s = {(&#915;1,c). &#8707;clist. (length clist)=(length xs) &#8743;
 (&#8704;i&lt;length clist. clist!i &#8712; cp &#915; (xs!i) s) &#8743; (&#915;,c) &#8733; clist &#8743; &#915;1=&#915;})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;ys. ((&#915;, (xs, s) # ys) &#8712; par_cptn) =
         (&#8707;clist.
             length clist = length xs &#8743;
             (&#915;,
              (xs, s) #
              ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                      (zip xs clist) &#8743;
             (&#8704;i&lt;length xs.
                 (&#915;, (xs ! i, s) # clist ! i) &#8712; cptn))&quot;</span></span></span><span>         
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;par_cp &#915; xs s &#8838; 
             {(&#915;1, c). &#8707;clist.
               length clist = length xs &#8743;
               (&#8704;i&lt;length clist. clist ! i &#8712; cp &#915; (xs ! i) s) &#8743;
               (&#915;, c) &#8733; clist &#8743; &#915;1 = &#915;}&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span class="keyword1"><span class="command">{</span></span><span>     
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>     </span><span class="keyword1"><span class="command">let</span></span><span> </span><span class="var">?show</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712; {(&#915;1, c). &#8707;clist.
       length clist = length xs &#8743;
       (&#8704;i&lt;length clist. clist ! i &#8712; cp &#915; (xs ! i) s) &#8743;
        (&#915;, c) &#8733; clist &#8743; &#915;1 = &#915;}&quot;</span></span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;par_cp &#915; xs s&quot;</span></span></span><span>   
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>y</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=(&#915;,y)&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>par_cp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>       
</span><span>     </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="var">?show</span><span>          
</span><span>     </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>y</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> </span><span class="keyword1"><span class="command">then</span></span><span> 
</span><span>         </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?show</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span>x_pair</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>par_cp_def</span><span> </span><span>cp_def</span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>force</span><span> </span><span>elim</span><span class="delimiter">:</span><span>par_cptn.cases</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">next</span></span><span> 
</span><span>        </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>list</span><span class="delimiter">)</span><span> </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>          </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?show</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>a3</span><span> </span><span>x_pair</span><span>
</span><span>          </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>par_cp_def</span><span> </span><span>cp_def</span><span>         
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>auto</span><span class="delimiter">,</span><span> </span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;map (&#955;i. (&#915;,(fst i, s) # snd i)) (zip xs clist)&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">}</span></span><span> </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">{</span></span><span>   
</span><span>   </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{(&#915;1, c). &#8707;clist.
          length clist = length xs &#8743;
          (&#8704;i&lt;length clist. clist ! i &#8712; cp &#915; (xs ! i) s) &#8743;
          (&#915;, c) &#8733; clist &#8743; &#915;1 = &#915;} &#8838; par_cp &#915; xs s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> 
</span><span>   </span><span class="keyword1"><span class="command">proof</span></span><span>-</span><span>
</span><span>     </span><span class="keyword1"><span class="command">{</span></span><span> 
</span><span>     </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>x</span><span>
</span><span>     </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;{(&#915;1, c). &#8707;clist.
          length clist = length xs &#8743;
          (&#8704;i&lt;length clist. clist ! i &#8712; cp &#915; (xs ! i) s) &#8743;
          (&#915;, c) &#8733; clist &#8743; &#915;1 = &#915;}&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>c</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>x_pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=(&#915;,c)&quot;</span></span></span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>clist</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> 
</span><span>      </span><span>props</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length xs &#8743;
           (&#8704;i&lt;length clist. clist ! i &#8712; cp &#915; (xs ! i) s) &#8743;
           (&#915;, c) &#8733; clist &quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;par_cp &#915; xs s&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>         </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_0</span><span class="delimiter">:</span><span> 
</span><span>           </span><span class="string"><span class="delete"><span class="delete">&quot;clist ! 0 &#8712; cp &#915; (xs ! 0) s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>props</span><span> </span><span>a1</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;par_cp &#915; xs s&quot;</span></span></span><span>  
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>props</span><span> </span><span>Nil</span><span> </span><span>x_pair</span><span>
</span><span>         </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>cp_def</span><span> </span><span>conjoin_def</span><span> </span><span>same_length_def</span><span> 
</span><span>         </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>                  
</span><span>         </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>cptn.cases</span><span class="delimiter">,</span><span>fastforce</span><span class="delimiter">,</span><span>fastforce</span><span class="delimiter">,</span><span>fastforce</span><span class="delimiter">)</span><span>
</span><span>       </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>         </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>a</span><span> </span><span>ys</span><span class="delimiter">)</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>a_pair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;a=(a1,a2)&quot;</span></span></span><span> 
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>         </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>               </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(((&#915;, (xs, s) # ys) &#8712; par_cptn) =
                   (&#8707;clist. length clist = length xs &#8743;
                   (&#915;, (xs, s) # ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i)) (zip xs clist) &#8743;
                   (&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # clist ! i) &#8712; cptn)))&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a2_s</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a2=s&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>props</span><span> </span><span>a_pair</span><span> </span><span>Cons</span><span>
</span><span>           </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>conjoin_def</span><span>   </span><span>same_state_def</span><span>  </span><span>cp_def</span><span>         
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>force</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a1_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;a1 = xs&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>props</span><span> </span><span>a_pair</span><span> </span><span>Cons</span><span> 
</span><span>           </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>par_cp_def</span><span> </span><span>conjoin_def</span><span>  </span><span>same_program_def</span><span> </span><span>cp_def</span><span>           
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>           </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>0</span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;j. H j &#10230; (fst (s j))=((t j))&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>H</span><span> </span><span>s</span><span> </span><span>t</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>                      
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>nth_equalityI</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>   
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conjoin_clist_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs,s)#ys) &#8733; clist&quot;</span></span></span><span>     
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span>  </span><span>props</span><span> </span><span>a_pair</span><span> </span><span>Cons</span><span> </span><span>a1_xs</span><span> </span><span>a2_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;clist = map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs ((map (&#955;x. tl (snd x))) clist))&quot;</span></span></span><span>             
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_map_zip</span><span> </span><span>a1</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>conjoin_map</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i)) (zip xs ((map (&#955;x. tl (snd x))) clist))&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>props</span><span> </span><span>x_pair</span><span> </span><span>Cons</span><span> </span><span>a_pair</span><span> </span><span>a1_xs</span><span> </span><span>a2_s</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>    
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;n. &#172; n &lt; length xs &#8744; clist ! n &#8712; {(f, ps). ps ! 0 = (xs ! n, a2) &#8743; (&#915;, ps) &#8712; cptn &#8743; f = &#915;}&quot;</span></span></span><span>
</span><span>               </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1_xs</span><span> </span><span>a2_s</span><span> </span><span>props</span><span> </span><span>cp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length clist. (fst (clist!i) = &#915;) &#8743; 
                                 (&#915;, snd (clist!i)) &#8712; cptn &#8743;
                                 (snd (clist!i))!0 = (xs!i,s))&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1_xs</span><span> </span><span>a2_s</span><span> </span><span>props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>         
</span><span>                       
</span><span>          </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>i</span><span>
</span><span>          </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length xs&quot;</span></span></span><span>     
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_i_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(fst (clist!i) = &#915;) &#8743; 
                     (&#915;, snd (clist!i)) &#8712; cptn &#8743;
                     (snd (clist!i))!0 = (xs!i,s)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>props</span><span> </span><span>clist_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a4</span><span> </span><span>props</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>a4&#39;</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;i&lt;length clist&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>lengz</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length (snd (clist!i))&gt;0&quot;</span></span></span><span> 
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conjoin_clist_xs</span><span> </span><span>a4&#39;</span><span>
</span><span>            </span><span class="keyword1"><span class="command">unfolding</span></span><span>  </span><span>conjoin_def</span><span> </span><span>same_length_def</span><span> 
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_hd_tl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (clist!i) =  hd (snd (clist!i)) # tl (snd (clist ! i))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>        
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot; hd (snd (clist!i)) =  (snd (clist!i))!0&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a4&#39;</span><span> </span><span>lengz</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>hd_conv_nth</span><span class="delimiter">)</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_i_tl</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (clist!i) =  (xs!i,s) # tl (snd (clist ! i))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_i_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fastforce</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;tl (snd (clist ! i)) = map (&#955;x. tl (snd x)) clist!i&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>nth_map</span><span> </span><span>a4&#39;</span><span> 
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>snd_clist</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;snd (clist!i) =  (xs ! i, s) # map (&#955;x. tl (snd x)) clist ! i&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">also</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(clist!i) = (fst (clist!i),snd (clist!i))&quot;</span></span></span><span>
</span><span>            </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(clist!i) =(&#915;, (xs ! i, s) # map (&#955;x. tl (snd x)) clist ! i)&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_i_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs ! i, s) # map (&#955;x. tl (snd x)) clist ! i) &#8712; cptn&quot;</span></span></span><span> 
</span><span>             </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>clist_i_cptn</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>          </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span>          </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>clist_in_cptn</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # ((map (&#955;x. tl (snd x))) clist) ! i) &#8712; cptn)&quot;</span></span></span><span>
</span><span>          </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>same_length_clist_xs</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;length ((map (&#955;x. tl (snd x))) clist)  = length xs&quot;</span></span></span><span>
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>props</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8707;clist. length clist = length xs &#8743;
                        (&#915;, (xs, s) # ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i)) (zip xs clist) &#8743;
                        (&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # clist ! i) &#8712; cptn))&quot;</span></span></span><span>
</span><span>         </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a1</span><span>  </span><span>props</span><span> </span><span>x_pair</span><span> </span><span>a_pair</span><span> </span><span>Cons</span><span> </span><span>a1_xs</span><span> </span><span>a2_s</span><span> </span><span>conjoin_clist_xs</span><span> </span><span>clist_in_cptn</span><span>
</span><span>            </span><span>conjoin_map</span><span> </span><span>clist_map</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>         
</span><span>         </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, c) &#8712; par_cptn&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">using</span></span><span>  </span><span>a1</span><span> </span><span>a2</span><span>  </span><span>props</span><span> </span><span>x_pair</span><span> </span><span>a_pair</span><span> </span><span>Cons</span><span> </span><span>a1_xs</span><span> </span><span>a2_s</span><span>
</span><span>         </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>par_cp_def</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>          
</span><span>         </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x&#8712;par_cp &#915; xs s&quot;</span></span></span><span>  
</span><span>           </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span>  </span><span>props</span><span> </span><span>x_pair</span><span> </span><span>a_pair</span><span> </span><span>Cons</span><span> </span><span>a1_xs</span><span> </span><span>a2_s</span><span>
</span><span>         </span><span class="keyword1"><span class="command">unfolding</span></span><span> </span><span>par_cp_def</span><span> </span><span>conjoin_def</span><span>  </span><span>same_length_def</span><span> </span><span>same_program_def</span><span> </span><span>same_state_def</span><span> </span><span>same_functions_def</span><span> </span><span>compat_label_def</span><span> 
</span><span>           </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>          
</span><span>       </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>     </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>  
</span><span>   </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_iff_aux_only_if</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[] &#10233;  
 (par_cp &#915; (xs) s = {(&#915;1,c). &#8707;clist. (length clist)=(length xs) &#8743;
 (&#8704;i&lt;length clist. clist!i &#8712; cp &#915; (xs!i) s) &#8743; (&#915;,c) &#8733; clist &#8743; &#915;1=&#915;}) &#10233;
(&#8704;ys. ((&#915;,((xs, s)#ys)) &#8712; par_cptn) = 
 (&#8707;clist. length clist= length xs &#8743; 
 ((&#915;,(xs, s)#ys) &#8733; map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs clist)) &#8743; 
 (&#8704;i&lt;length xs. (&#915;,(xs!i,s)#(clist!i)) &#8712; cptn)))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>ys</span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;par_cp &#915; xs s =
          {(&#915;1, c).
           &#8707;clist.
              length clist = length xs &#8743;
              (&#8704;i&lt;length clist.
                  clist ! i &#8712; cp &#915; (xs ! i) s) &#8743;
              (&#915;, c) &#8733; clist &#8743; &#915;1 = &#915;}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword3"><span class="command">show</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((&#915;, (xs, s) # ys) &#8712; par_cptn) =
          (&#8707;clist.
              length clist = length xs &#8743;
              (&#915;,
               (xs, s) #
               ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                       (zip xs clist) &#8743;
              (&#8704;i&lt;length xs.
                  (&#915;, (xs ! i, s) # clist ! i) &#8712; cptn))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # ys) &#8712; par_cptn&quot;</span></span></span><span>
</span><span>     </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8707;clist.
       length clist = length xs &#8743;
       (&#915;,
        (xs, s) #
        ys) &#8733; map (&#955;i. (&#915;, (fst i, s) # snd i))
                (zip xs clist) &#8743;
       (&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # clist ! i) &#8712; cptn)&quot;</span></span></span><span>
</span><span>       </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>aux_onlyif</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>clist</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;a, &#39;b, &#39;c, &#39;d) LanguageCon.com &#215;
             (&#39;a, &#39;c) xstate) list list&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a3</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;length clist = length xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a4</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # ys) &#8733; 
               map (&#955;i. (&#915;, (fst i, s) # snd i))
                (zip xs clist)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a5</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;i&lt;length xs. (&#915;, (xs ! i, s) # clist ! i)
                     &#8712; cptn&quot;</span></span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#915;, (xs, s) # ys) &#8712; par_cptn&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>a3</span><span> </span><span>a4</span><span> </span><span>a5</span><span> </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>aux_if</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>one_iff_aux</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[] &#10233; (&#8704;ys. ((&#915;,((xs, s)#ys)) &#8712; par_cptn) = 
 (&#8707;clist. length clist= length xs &#8743; 
 ((&#915;,(xs, s)#ys) &#8733; map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs clist)) &#8743; 
 (&#8704;i&lt;length xs. (&#915;,(xs!i,s)#(clist!i)) &#8712; cptn))) = 
 (par_cp &#915; (xs) s = {(&#915;1,c). &#8707;clist. (length clist)=(length xs) &#8743;
 (&#8704;i&lt;length clist. clist!i &#8712; cp &#915; (xs!i) s) &#8743; (&#915;,c) &#8733; clist &#8743; &#915;1=&#915;})&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>  </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a1</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;ys. ((&#915;,((xs, s)#ys)) &#8712; par_cptn) = 
   (&#8707;clist. length clist= length xs &#8743; 
   ((&#915;,(xs, s)#ys) &#8733; map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs clist)) &#8743; 
   (&#8704;i&lt;length xs. (&#915;,(xs!i,s)#(clist!i)) &#8712; cptn)))&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(par_cp &#915; (xs) s = {(&#915;1,c). &#8707;clist. (length clist)=(length xs) &#8743;
   (&#8704;i&lt;length clist. clist!i &#8712; cp &#915; (xs!i) s) &#8743; (&#915;,c) &#8733; clist &#8743; &#915;1=&#915;})&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>one_iff_aux_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">{</span></span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>a2</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;(par_cp &#915; (xs) s = {(&#915;1,c). &#8707;clist. (length clist)=(length xs) &#8743;
   (&#8704;i&lt;length clist. clist!i &#8712; cp &#915; (xs!i) s) &#8743; (&#915;,c) &#8733; clist &#8743; &#915;1=&#915;})&quot;</span></span></span><span>    
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8704;ys. ((&#915;,((xs, s)#ys)) &#8712; par_cptn) = 
   (&#8707;clist. length clist= length xs &#8743; 
   ((&#915;,(xs, s)#ys) &#8733; map (&#955;i. (&#915;,(fst i,s)#(snd i))) (zip xs clist)) &#8743; 
   (&#8704;i&lt;length xs. (&#915;,(xs!i,s)#(clist!i)) &#8712; cptn)))&quot;</span></span></span><span>
</span><span>   </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>a1</span><span> </span><span>a2</span><span> </span><span>one_iff_aux_only_if</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">}</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">theorem</span></span><span> </span><span>one</span><span class="delimiter">:</span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;xs&#8800;[] &#10233;  
 par_cp &#915; xs s = 
    {(&#915;1,c). &#8707;clist. (length clist)=(length xs) &#8743; 
             (&#8704;i&lt;length clist. (clist!i) &#8712; cp &#915; (xs!i) s) &#8743; 
             (&#915;,c) &#8733; clist &#8743; &#915;1=&#915;}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>frule</span><span> </span><span>one_iff_aux</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>drule</span><span> </span><span>sym</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>iffD2</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>rule</span><span> </span><span>iffI</span><span class="delimiter">)</span><span> 
</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>erule</span><span> </span><span>aux_onlyif</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span class="delimiter">(</span><span>force</span><span> </span><span>intro</span><span class="delimiter">:</span><span>aux_if</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(************************************************************************ *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* subsection {* Equivalence between Small-Step and Big-Step Semantics *} *)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* ************************************************************************ *)</span></span></span></span></span><span>
</span><span> 
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* 

?&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (LanguageCon.com.Seq ?c1.0 ?c2.0, ?s) &#8594;
       (LanguageCon.com.Seq ?c1&#39; ?c2.0,
        ?s&#39;) &#10233;
(?&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (?c1.0, ?s) &#8594; (?c1&#39;, ?s&#39;) &#10233; ?P) &#10233;
?P

lemma 
   assumes 
           step_a: &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Await b c, Normal s) &#8594; (t,u)&quot;
   shows step_await_step_c:&quot;(&#915;<span class="hidden">&#8681;</span><sub>&#172;</sub><span class="hidden">&#8681;</span><sub>a</sub>)&#8866;(c, Normal s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (sequential t,u)&quot; 
using step_a
proof cases
  fix t1
  assume
      &quot;(t, u) = (Skip, t1)&quot; &quot;s &#8712; b&quot; &quot;&#915;&#8866; &#10216;c,Normal s&#10217; &#8658; t1&quot; &quot;&#8704;t&#39;. t1 &#8800; Abrupt t&#39;&quot;
  thus ?thesis 
   by (cases u) 
   (auto intro: exec_impl_steps_Fault exec_impl_steps_Normal exec_impl_steps_Stuck)
next
  fix t1
  assume &quot;(t, u) = (Throw, Normal t1)&quot; &quot;s &#8712; b&quot; &quot;&#915;&#8866; &#10216;c,Normal s&#10217; &#8658; Abrupt t1&quot;
  thus ?thesis by (simp add: exec_impl_steps_Normal_Abrupt)
qed

lemma 
   assumes (* exec: &quot;&#915;&#8866;&#10216;c,Normal s&#10217; &#8658; t&quot; and
           b: &quot;s &#8712; b&quot; and *)
           step_a: &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>(Await b c, Normal s) &#8594; u&quot;
   shows step_await_final1:&quot;final u&quot;
using step_a 
proof cases
  case  (1 t) thus &quot;final u&quot;  by (simp add: final_def)
next
  case (2 t)
  thus &quot;final u&quot; by (simp add: exec_impl_steps_Normal_Abrupt final_def)
qed

lemma step_Abrupt_end: 
  assumes step: &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;
  shows &quot;s&#39;=Abrupt x &#10233; s=Abrupt x&quot;
using step
by induct auto


lemma step_Stuck_end: 
  assumes step: &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;
  shows &quot;s&#39;=Stuck &#10233; 
          s=Stuck &#8744; 
          (&#8707;r x. redex c<span class="hidden">&#8681;</span><sub>1</sub> = Spec r &#8743; s=Normal x &#8743; (&#8704;t. (x,t)&#8713;r)) &#8744; 
          (&#8707;p x. redex c<span class="hidden">&#8681;</span><sub>1</sub>=  Call p &#8743; s=Normal x &#8743; &#915; p = None) &#8744;
          (&#8707;b c x.  redex c<span class="hidden">&#8681;</span><sub>1</sub> = Await b c &#8743; s=Normal x &#8743; x &#8712; b &#8743; &#915;&#8866;&#10216;c,s&#10217;&#8658;s&#39;)&quot;
using step
by induct auto

lemma step_Fault_end: 
  assumes step: &quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>&#39;, s&#39;)&quot;
  shows &quot;s&#39;=Fault f &#10233; 
          s=Fault f &#8744; 
          (&#8707;g c x.  redex c<span class="hidden">&#8681;</span><sub>1</sub> = Guard f g c &#8743; s=Normal x &#8743; x &#8713; g) &#8744;
          (&#8707;b c1 x.  redex c<span class="hidden">&#8681;</span><sub>1</sub> = Await b c1 &#8743; s=Normal x &#8743; x &#8712; b &#8743; &#915;&#8866;&#10216;c1,s&#10217;&#8658;s&#39;)&quot;
using step 
by induct auto



(* ************************************************************************ *)
subsection {* Infinite Computations: @{text &quot;&#915;&#8866;(c, s) &#8594; &#8230;(&#8734;)&quot;}*}
(* ************************************************************************ *)

definition inf_c:: &quot;(&#39;s,&#39;p,&#39;f,&#39;e) body &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) config &#8658; bool&quot;
 (&quot;_&#8866;<span class="hidden">&#8681;</span><sub>c</sub> _ &#8594; &#8230;&#39;(&#8734;&#39;)&quot; [60,80] 100) where
&quot;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg &#8594; &#8230;(&#8734;) &#8801; (&#8707;f. f (0::nat) = cfg &#8743; (&#8704;i. &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>f i &#8594; f (i+1)))&quot; 

lemma not_infI: &quot;&#10214;&#8896;f. &#10214;f 0 = cfg; &#8896;i. &#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub>f i &#8594; f (Suc i)&#10215; &#10233; False&#10215;  
                &#10233; &#172;&#915;&#8866;<span class="hidden">&#8681;</span><sub>c</sub> cfg &#8594; &#8230;(&#8734;)&quot;
  by (auto simp add: inf_c_def)

(* ************************************************************************ *)
subsection {* Equivalence between Termination and the Absence of Infinite Computations*}
(* ************************************************************************ *)


lemma step_preserves_termination: 
  assumes step: &quot;&#915;&#8866;(c,s) &#8594; (c&#39;,s&#39;)&quot;
  shows &quot;&#915;&#8866;c&#8595;s &#10233; &#915;&#8866;c&#39;&#8595;s&#39;&quot;  
using step
proof (induct)
  case Basic thus ?case by (fastforce intro: terminates.intros)
next
  case Spec thus ?case by (fastforce intro: terminates.intros)
next
  case SpecStuck thus ?case by (fastforce intro: terminates.intros)
next
  case Guard thus ?case 
    by (fastforce intro: terminates.intros elim: terminates_Normal_elim_cases)
next
  case GuardFault thus ?case by (fastforce intro: terminates.intros)
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> s c<span class="hidden">&#8681;</span><sub>1</sub>&#39; s&#39; c<span class="hidden">&#8681;</span><sub>2</sub>) thus ?case
    apply (cases s)
    apply     (cases s&#39;)
    apply         (fastforce intro: terminates.intros step_extend 
                    elim: terminates_Normal_elim_cases)
    apply (fastforce intro: terminates.intros dest: step_Abrupt_prop 
      step_Fault_prop step_Stuck_prop)+
    done
next
  case (SeqSkip c<span class="hidden">&#8681;</span><sub>2</sub> s) 
  thus ?case 
    apply (cases s)
    apply (fastforce intro: terminates.intros exec.intros
            elim: terminates_Normal_elim_cases )+
    done
next
  case (SeqThrow c<span class="hidden">&#8681;</span><sub>2</sub> s) 
  thus ?case 
    by (fastforce intro: terminates.intros exec.intros
            elim: terminates_Normal_elim_cases )
next
  case CondTrue 
  thus ?case 
    by (fastforce intro: terminates.intros exec.intros
            elim: terminates_Normal_elim_cases )
next
  case CondFalse 
  thus ?case 
    by (fastforce intro: terminates.intros 
            elim: terminates_Normal_elim_cases )
next
  case WhileTrue
  thus ?case 
    by (fastforce intro: terminates.intros 
            elim: terminates_Normal_elim_cases )
next
  case WhileFalse 
  thus ?case 
    by (fastforce intro: terminates.intros 
            elim: terminates_Normal_elim_cases )
next
  case Call 
  thus ?case 
    by (fastforce intro: terminates.intros 
            elim: terminates_Normal_elim_cases )
next
  case CallUndefined
  thus ?case 
    by (fastforce intro: terminates.intros 
            elim: terminates_Normal_elim_cases )
next
  case DynCom
  thus ?case 
    by (fastforce intro: terminates.intros 
            elim: terminates_Normal_elim_cases )
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> s c<span class="hidden">&#8681;</span><sub>1</sub>&#39; s&#39; c<span class="hidden">&#8681;</span><sub>2</sub>) thus ?case
    apply (cases s)
    apply     (cases s&#39;)
    apply         (fastforce intro: terminates.intros step_extend 
                    elim: terminates_Normal_elim_cases)
    apply (fastforce intro: terminates.intros dest: step_Abrupt_prop 
      step_Fault_prop step_Stuck_prop)+
    done
next
  case CatchThrow
  thus ?case 
   by (fastforce intro: terminates.intros exec.intros
            elim: terminates_Normal_elim_cases )
next
  case (CatchSkip c<span class="hidden">&#8681;</span><sub>2</sub> s) 
  thus ?case 
    by (cases s) (fastforce intro: terminates.intros)+
next
  case FaultProp thus ?case by (fastforce intro: terminates.intros)
next
  case StuckProp thus ?case by (fastforce intro: terminates.intros)
next
  case AbruptProp thus ?case by (fastforce intro: terminates.intros)
next 
  case Await thus ?case using terminates_Skip&#39; by blast 
next 
  case AwaitAbrupt thus ?case by (fastforce intro: terminates.intros)
qed

lemma steps_preserves_termination: 
  assumes steps: &quot;&#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;,s&#39;)&quot;
  shows &quot;&#915;&#8866;c&#8595;s &#10233; &#915;&#8866;c&#39;&#8595;s&#39;&quot;
using steps
proof (induct rule: rtranclp_induct2 [consumes 1, case_names Refl Trans])
  case Refl thus ?case  .
next
  case Trans
  thus ?case
    by (blast dest: step_preserves_termination)
qed

ML {*
  ML_Thms.bind_thm (&quot;tranclp_induct2&quot;, Split_Rule.split_rule @{context}
    (Rule_Insts.read_instantiate @{context}
      [(((&quot;a&quot;, 0), Position.none), &quot;(aa,ab)&quot;), (((&quot;b&quot;, 0), Position.none), &quot;(ba,bb)&quot;)] []
      @{thm tranclp_induct}));
*}

thm tranclp_induct2 tranclp_induct

lemma steps_preserves_termination&#39;: 
  assumes steps: &quot;&#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c&#39;,s&#39;)&quot;
  shows &quot;&#915;&#8866;c&#8595;s &#10233; &#915;&#8866;c&#39;&#8595;s&#39;&quot;
using steps
proof (induct rule: tranclp_induct2 [consumes 1, case_names Step Trans])
  case Step thus ?case by (blast intro: step_preserves_termination)
next
  case Trans
  thus ?case
    by (blast dest: step_preserves_termination)
qed



definition head_com:: &quot;(&#39;s,&#39;p,&#39;f,&#39;e) com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) com&quot;
where
&quot;head_com c =
  (case c of
     Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> &#8658; c<span class="hidden">&#8681;</span><sub>1</sub>
   | Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> &#8658; c<span class="hidden">&#8681;</span><sub>1</sub>
   | _ &#8658; c)&quot;

  
definition head:: &quot;(&#39;s,&#39;p,&#39;f,&#39;e) config &#8658; (&#39;s,&#39;p,&#39;f,&#39;e) config&quot;
  where &quot;head cfg = (head_com (fst cfg), snd cfg)&quot;

lemma le_Suc_cases: &quot;&#10214;&#8896;i. &#10214;i &lt; k&#10215; &#10233; P i; P k&#10215; &#10233; &#8704;i&lt;(Suc k). P i&quot;
  apply clarify
  apply (case_tac &quot;i=k&quot;)
  apply auto
  done

lemma redex_Seq_False: &quot;&#8896;c&#39; c&#39;&#39;. (redex c = Seq c&#39;&#39; c&#39;) = False&quot;
  by (induct c) auto

lemma redex_Catch_False: &quot;&#8896;c&#39; c&#39;&#39;. (redex c = Catch c&#39;&#39; c&#39;) = False&quot;
  by (induct c) auto


lemma infinite_computation_extract_head_Seq:
  assumes inf_comp: &quot;&#8704;i::nat. &#915;&#8866;f i &#8594; f (i+1)&quot;
  assumes f_0: &quot;f 0 = (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s)&quot;
  assumes not_fin: &quot;&#8704;i&lt;k. &#172; final (head (f i))&quot;
  shows &quot;&#8704;i&lt;k. (&#8707;c&#39; s&#39;. f (i + 1) = (Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)) &#8743;  
               &#915;&#8866;head (f i) &#8594; head (f (i+1))&quot;
        (is &quot;&#8704;i&lt;k. ?P i&quot;)
using not_fin
proof (induct k)
  case 0
  show ?case by simp
next
  case (Suc k)
  have not_fin_Suc: 
    &quot;&#8704;i&lt;Suc k. &#172; final (head (f i))&quot; by fact
  from this[rule_format] have not_fin_k: 
    &quot;&#8704;i&lt;k. &#172; final (head (f i))&quot; 
    apply clarify
    apply (subgoal_tac &quot;i &lt; Suc k&quot;)
    apply blast
    apply simp
    done

  from Suc.hyps [OF this]
  have hyp: &quot;&#8704;i&lt;k. (&#8707;c&#39; s&#39;. f (i + 1) = (Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)) &#8743; 
                   &#915;&#8866; head (f i) &#8594; head (f (i + 1))&quot;.
  show ?case
  proof (rule le_Suc_cases)
    fix i 
    assume &quot;i &lt; k&quot;
    then show &quot;?P i&quot;
      by (rule hyp [rule_format])
  next
    show &quot;?P k&quot;
    proof -
      from hyp [rule_format, of &quot;k - 1&quot;] f_0
      obtain c&#39; fs&#39; L&#39; s&#39; where  f_k: &quot;f k = (Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;
        by (cases k) auto
      from inf_comp [rule_format, of k] f_k
      have &quot;&#915;&#8866;(Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;) &#8594; f (k + 1)&quot;
        by simp
      moreover
      from not_fin_Suc [rule_format, of k] f_k
      have &quot;&#172; final (c&#39;,s&#39;)&quot;
        by (simp add: final_def head_def head_com_def)
      ultimately
      obtain c&#39;&#39; s&#39;&#39; where
         &quot;&#915;&#8866;(c&#39;, s&#39;) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
         &quot;f (k + 1) = (Seq c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;&#39;)&quot;
        by cases (auto simp add: redex_Seq_False final_def)
      with f_k
      show ?thesis
        by (simp add: head_def head_com_def)
    qed
  qed
qed

lemma infinite_computation_extract_head_Catch:
  assumes inf_comp: &quot;&#8704;i::nat. &#915;&#8866;f i &#8594; f (i+1)&quot;
  assumes f_0: &quot;f 0 = (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s)&quot;
  assumes not_fin: &quot;&#8704;i&lt;k. &#172; final (head (f i))&quot;
  shows &quot;&#8704;i&lt;k. (&#8707;c&#39; s&#39;. f (i + 1) = (Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)) &#8743;  
               &#915;&#8866;head (f i) &#8594; head (f (i+1))&quot;
        (is &quot;&#8704;i&lt;k. ?P i&quot;)
using not_fin
proof (induct k)
  case 0
  show ?case by simp
next
  case (Suc k)
  have not_fin_Suc: 
    &quot;&#8704;i&lt;Suc k. &#172; final (head (f i))&quot; by fact
  from this[rule_format] have not_fin_k: 
    &quot;&#8704;i&lt;k. &#172; final (head (f i))&quot; 
    apply clarify
    apply (subgoal_tac &quot;i &lt; Suc k&quot;)
    apply blast
    apply simp
    done

  from Suc.hyps [OF this]
  have hyp: &quot;&#8704;i&lt;k. (&#8707;c&#39; s&#39;. f (i + 1) = (Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)) &#8743; 
                   &#915;&#8866; head (f i) &#8594; head (f (i + 1))&quot;.
  show ?case
  proof (rule le_Suc_cases)
    fix i 
    assume &quot;i &lt; k&quot;
    then show &quot;?P i&quot;
      by (rule hyp [rule_format])
  next
    show &quot;?P k&quot;
    proof -
      from hyp [rule_format, of &quot;k - 1&quot;] f_0
      obtain c&#39; fs&#39; L&#39; s&#39; where  f_k: &quot;f k = (Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;
        by (cases k) auto
      from inf_comp [rule_format, of k] f_k
      have &quot;&#915;&#8866;(Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;) &#8594; f (k + 1)&quot;
        by simp
      moreover
      from not_fin_Suc [rule_format, of k] f_k
      have &quot;&#172; final (c&#39;,s&#39;)&quot;
        by (simp add: final_def head_def head_com_def)
      ultimately
      obtain c&#39;&#39; s&#39;&#39; where
         &quot;&#915;&#8866;(c&#39;, s&#39;) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
         &quot;f (k + 1) = (Catch c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;&#39;)&quot;
        by cases (auto simp add: redex_Catch_False final_def)+
      with f_k
      show ?thesis
        by (simp add: head_def head_com_def)
    qed
  qed
qed

lemma no_inf_Throw: &quot;&#172; &#915;&#8866;(Throw,s) &#8594; &#8230;(&#8734;)&quot;
proof 
  assume &quot;&#915;&#8866; (Throw, s) &#8594; &#8230;(&#8734;)&quot;
  then obtain f where
    step [rule_format]: &quot;&#8704;i::nat. &#915;&#8866;f i &#8594; f (i+1)&quot; and
    f_0: &quot;f 0 = (Throw, s)&quot;
    by (auto simp add: inf_def)
  from step [of 0, simplified f_0] step [of 1]
  show False
    by cases (auto elim: step_elim_cases)
qed

lemma split_inf_Seq: 
  assumes inf_comp: &quot;&#915;&#8866;(Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594; &#8230;(&#8734;)&quot;
  shows &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594; &#8230;(&#8734;) &#8744; 
         (&#8707;s&#39;. &#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip,s&#39;) &#8743; &#915;&#8866;(c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;) &#8594; &#8230;(&#8734;))&quot;
proof -
  from inf_comp obtain f where
    step: &quot;&#8704;i::nat. &#915;&#8866;f i &#8594; f (i+1)&quot; and
    f_0: &quot;f 0 = (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, s)&quot;
    by (auto simp add: inf_def)
  from f_0 have head_f_0: &quot;head (f 0) = (c<span class="hidden">&#8681;</span><sub>1</sub>,s)&quot; 
    by (simp add: head_def head_com_def)
  show ?thesis
  proof (cases &quot;&#8707;i. final (head (f i))&quot;)
    case True
    def k&#8801;&quot;(LEAST i. final (head (f i)))&quot;
    have less_k: &quot;&#8704;i&lt;k. &#172; final (head (f i))&quot;
      apply (intro allI impI)
      apply (unfold k_def)
      apply (drule not_less_Least)
      apply auto
      done
    from infinite_computation_extract_head_Seq [OF step f_0 this]
    obtain step_head: &quot;&#8704;i&lt;k. &#915;&#8866; head (f i) &#8594; head (f (i + 1))&quot; and
           conf: &quot;&#8704;i&lt;k. (&#8707;c&#39; s&#39;. f (i + 1) = (Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;))&quot;
      by blast 
    from True
    have final_f_k: &quot;final (head (f k))&quot;
      apply -
      apply (erule exE)
      apply (drule LeastI)
      apply (simp add: k_def)
      done
    moreover
    from f_0 conf [rule_format, of &quot;k - 1&quot;]
    obtain c&#39; s&#39; where f_k: &quot;f k = (Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot;
      by (cases k) auto
    moreover
    from step_head have steps_head: &quot;&#915;&#8866;head (f 0) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> head (f k)&quot;
    proof (induct k)
      case 0 thus ?case by simp
    next
      case (Suc m)
      have step: &quot;&#8704;i&lt;Suc m. &#915;&#8866; head (f i) &#8594; head (f (i + 1))&quot; by fact
      hence &quot;&#8704;i&lt;m. &#915;&#8866; head (f i) &#8594; head (f (i + 1))&quot;
        by auto
      hence &quot;&#915;&#8866; head (f 0) &#8594;<span class="hidden">&#8679;</span><sup>*</sup>  head (f m)&quot;
        by (rule Suc.hyps)
      also from step [rule_format, of m]
      have &quot;&#915;&#8866; head (f m) &#8594; head (f (m + 1))&quot; by simp
      finally show ?case by simp
    qed
    {
      assume f_k: &quot;f k = (Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;
      with steps_head
      have &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip,s&#39;)&quot;
        using head_f_0
        by (simp add: head_def head_com_def)
      moreover
      from step [rule_format, of k] f_k
      obtain &quot;&#915;&#8866;(Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot; and
        f_Suc_k: &quot;f (k + 1) = (c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot;
        by (fastforce elim: step.cases intro: step.intros)
      def g&#8801;&quot;&#955;i. f (i + (k + 1))&quot;
      from f_Suc_k
      have g_0: &quot;g 0 = (c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot;
        by (simp add: g_def)
      from step
      have &quot;&#8704;i. &#915;&#8866;g i &#8594; g (i + 1)&quot;
        by (simp add: g_def)
      with g_0 have &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;) &#8594; &#8230;(&#8734;)&quot;
        by (auto simp add: inf_def)
      ultimately
      have ?thesis
        by auto
    }
    moreover
    {
      fix x
      assume s&#39;: &quot;s&#39;=Normal x&quot; and f_k: &quot;f k = (Seq Throw c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;
      from step [rule_format, of k] f_k s&#39;
      obtain &quot;&#915;&#8866;(Seq Throw c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;) &#8594; (Throw,s&#39;)&quot; and
        f_Suc_k: &quot;f (k + 1) = (Throw,s&#39;)&quot;
        by (fastforce elim: step_elim_cases intro: step.intros)
      def g&#8801;&quot;&#955;i. f (i + (k + 1))&quot;
      from f_Suc_k
      have g_0: &quot;g 0 = (Throw,s&#39;)&quot;
        by (simp add: g_def)
      from step
      have &quot;&#8704;i. &#915;&#8866;g i &#8594; g (i + 1)&quot;
        by (simp add: g_def)
      with g_0 have &quot;&#915;&#8866;(Throw,s&#39;) &#8594; &#8230;(&#8734;)&quot;
        by (auto simp add: inf_def)
      with no_inf_Throw
      have ?thesis
        by auto
    }
    ultimately 
    show ?thesis
      by (auto simp add: final_def head_def head_com_def)
  next
    case False
    then have not_fin: &quot;&#8704;i. &#172; final (head (f i))&quot;
      by blast
    have &quot;&#8704;i. &#915;&#8866;head (f i) &#8594; head (f (i + 1))&quot;
    proof 
      fix k
      from not_fin 
      have &quot;&#8704;i&lt;(Suc k). &#172; final (head (f i))&quot;
        by simp
      
      from infinite_computation_extract_head_Seq [OF step f_0 this ]
      show &quot;&#915;&#8866; head (f k) &#8594; head (f (k + 1))&quot; by simp
    qed
    with head_f_0 have &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594; &#8230;(&#8734;)&quot;
      by (auto simp add: inf_def)
    thus ?thesis
      by simp
  qed
qed

lemma split_inf_Catch: 
  assumes inf_comp: &quot;&#915;&#8866;(Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>,s) &#8594; &#8230;(&#8734;)&quot;
  shows &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594; &#8230;(&#8734;) &#8744; 
         (&#8707;s&#39;. &#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Throw,Normal s&#39;) &#8743; &#915;&#8866;(c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s&#39;) &#8594; &#8230;(&#8734;))&quot;
proof -
  from inf_comp obtain f where
    step: &quot;&#8704;i::nat. &#915;&#8866;f i &#8594; f (i+1)&quot; and
    f_0: &quot;f 0 = (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, s)&quot;
    by (auto simp add: inf_def)
  from f_0 have head_f_0: &quot;head (f 0) = (c<span class="hidden">&#8681;</span><sub>1</sub>,s)&quot; 
    by (simp add: head_def head_com_def)
  show ?thesis
  proof (cases &quot;&#8707;i. final (head (f i))&quot;)
    case True
    def k&#8801;&quot;(LEAST i. final (head (f i)))&quot;
    have less_k: &quot;&#8704;i&lt;k. &#172; final (head (f i))&quot;
      apply (intro allI impI)
      apply (unfold k_def)
      apply (drule not_less_Least)
      apply auto
      done
    from infinite_computation_extract_head_Catch [OF step f_0 this]
    obtain step_head: &quot;&#8704;i&lt;k. &#915;&#8866; head (f i) &#8594; head (f (i + 1))&quot; and
           conf: &quot;&#8704;i&lt;k. (&#8707;c&#39; s&#39;. f (i + 1) = (Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;))&quot;
      by blast 
    from True
    have final_f_k: &quot;final (head (f k))&quot;
      apply -
      apply (erule exE)
      apply (drule LeastI)
      apply (simp add: k_def)
      done
    moreover
    from f_0 conf [rule_format, of &quot;k - 1&quot;]
    obtain c&#39; s&#39; where f_k: &quot;f k = (Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot;
      by (cases k) auto
    moreover
    from step_head have steps_head: &quot;&#915;&#8866;head (f 0) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> head (f k)&quot;
    proof (induct k)
      case 0 thus ?case by simp
    next
      case (Suc m)
      have step: &quot;&#8704;i&lt;Suc m. &#915;&#8866; head (f i) &#8594; head (f (i + 1))&quot; by fact
      hence &quot;&#8704;i&lt;m. &#915;&#8866; head (f i) &#8594; head (f (i + 1))&quot;
        by auto
      hence &quot;&#915;&#8866; head (f 0) &#8594;<span class="hidden">&#8679;</span><sup>*</sup>  head (f m)&quot;
        by (rule Suc.hyps)
      also from step [rule_format, of m]
      have &quot;&#915;&#8866; head (f m) &#8594; head (f (m + 1))&quot; by simp
      finally show ?case by simp
    qed
    {
      assume f_k: &quot;f k = (Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;
      with steps_head
      have &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Skip,s&#39;)&quot;
        using head_f_0
        by (simp add: head_def head_com_def)
      moreover
      from step [rule_format, of k] f_k
      obtain &quot;&#915;&#8866;(Catch Skip c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;) &#8594; (Skip,s&#39;)&quot; and
        f_Suc_k: &quot;f (k + 1) = (Skip,s&#39;)&quot;
        by (fastforce elim: step.cases intro: step.intros)
      from step [rule_format, of &quot;k+1&quot;, simplified f_Suc_k]
      have ?thesis
        by (rule no_step_final&#39;) (auto simp add: final_def)
    }
    moreover
    {
      fix x
      assume s&#39;: &quot;s&#39;=Normal x&quot; and f_k: &quot;f k = (Catch Throw c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;
      with steps_head
      have &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Throw,s&#39;)&quot;
        using head_f_0
        by (simp add: head_def head_com_def)
      moreover
      from step [rule_format, of k] f_k s&#39;
      obtain &quot;&#915;&#8866;(Catch Throw c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot; and
        f_Suc_k: &quot;f (k + 1) = (c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot;
        by (fastforce elim: step_elim_cases intro: step.intros)
      def g&#8801;&quot;&#955;i. f (i + (k + 1))&quot;
      from f_Suc_k
      have g_0: &quot;g 0 = (c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;)&quot;
        by (simp add: g_def)
      from step
      have &quot;&#8704;i. &#915;&#8866;g i &#8594; g (i + 1)&quot;
        by (simp add: g_def)
      with g_0 have &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>2</sub>,s&#39;) &#8594; &#8230;(&#8734;)&quot;
        by (auto simp add: inf_def)
      ultimately
      have ?thesis
        using s&#39;
        by auto
    }
    ultimately 
    show ?thesis
      by (auto simp add: final_def head_def head_com_def)
  next
    case False
    then have not_fin: &quot;&#8704;i. &#172; final (head (f i))&quot;
      by blast
    have &quot;&#8704;i. &#915;&#8866;head (f i) &#8594; head (f (i + 1))&quot;
    proof 
      fix k
      from not_fin 
      have &quot;&#8704;i&lt;(Suc k). &#172; final (head (f i))&quot;
        by simp
      
      from infinite_computation_extract_head_Catch [OF step f_0 this ]
      show &quot;&#915;&#8866; head (f k) &#8594; head (f (k + 1))&quot; by simp
    qed
    with head_f_0 have &quot;&#915;&#8866;(c<span class="hidden">&#8681;</span><sub>1</sub>,s) &#8594; &#8230;(&#8734;)&quot;
      by (auto simp add: inf_def)
    thus ?thesis
      by simp
  qed
qed

lemma Skip_no_step: &quot;&#915;&#8866;(Skip,s) &#8594; cfg &#10233; P&quot;
  apply (erule no_step_final&#39;)
  apply (simp add: final_def)
  done

lemma not_inf_Stuck: &quot;&#172; &#915;&#8866;(c,Stuck) &#8594; &#8230;(&#8734;)&quot;
proof (induct c)
  case Skip
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Skip, Stuck)&quot; 
    from f_step [of 0] f_0
    show False
      by (auto elim: Skip_no_step)
  qed
next
  case (Basic g) 
  thus ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Basic g, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Spec r) 
  thus ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Spec r, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  show ?case
  proof 
    assume &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Seq [OF this] Seq.hyps
    show False
      by (auto dest: steps_Stuck_prop)
  qed
next
  case (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (While b c) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (While b c, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Call p) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Call p, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (DynCom d) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (DynCom d, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Guard m g c)
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Guard m g c, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case Throw
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Throw, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  show ?case
  proof 
    assume &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Stuck) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Catch [OF this] Catch.hyps
    show False
      by (auto dest: steps_Stuck_prop)
  qed  
next 
  case (Await b c)
  show ?case 
   proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Await b c, Stuck)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
qed

lemma not_inf_Fault: &quot;&#172; &#915;&#8866;(c,Fault x) &#8594; &#8230;(&#8734;)&quot;
proof (induct c)
  case Skip
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Skip, Fault x)&quot; 
    from f_step [of 0] f_0
    show False
      by (auto elim: Skip_no_step)
  qed
next
  case (Basic g) 
  thus ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Basic g, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Spec r) 
  thus ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Spec r, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  show ?case
  proof 
    assume &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Fault x) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Seq [OF this] Seq.hyps
    show False
      by (auto dest: steps_Fault_prop)
  qed
next
  case (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (While b c) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (While b c, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Call p) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Call p, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (DynCom d) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (DynCom d, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Guard m g c)
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Guard m g c, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case Throw
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Throw, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  show ?case
  proof 
    assume &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Fault x) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Catch [OF this] Catch.hyps
    show False
      by (auto dest: steps_Fault_prop)
  qed  
next
  case (Await b c) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Await b c, Fault x)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
qed

lemma not_inf_Abrupt: &quot;&#172; &#915;&#8866;(c,Abrupt s) &#8594; &#8230;(&#8734;)&quot;
proof (induct c)
  case Skip
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Skip, Abrupt s)&quot; 
    from f_step [of 0] f_0
    show False
      by (auto elim: Skip_no_step)
  qed
next
  case (Basic g) 
  thus ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Basic g, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Spec r) 
  thus ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Spec r, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  show ?case
  proof 
    assume &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Seq [OF this] Seq.hyps
    show False
      by (auto dest: steps_Abrupt_prop)
  qed
next
  case (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (While b c) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (While b c, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Call p) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Call p, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (DynCom d) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (DynCom d, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Guard m g c)
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Guard m g c, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case Throw
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Throw, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  show ?case
  proof 
    assume &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Abrupt s) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Catch [OF this] Catch.hyps
    show False
      by (auto dest: steps_Abrupt_prop)
  qed  
case (Await b c) 
  show ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Await b c, Abrupt s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
qed


theorem terminates_impl_no_infinite_computation:
  assumes termi: &quot;&#915;&#8866;c &#8595; s&quot;
  shows &quot;&#172; &#915;&#8866;(c,s) &#8594; &#8230;(&#8734;)&quot;
using termi
proof (induct)
  case (Skip s) thus ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Skip, Normal s)&quot; 
    from f_step [of 0] f_0
    show False
      by (auto elim: Skip_no_step)
  qed
next
  case (Basic g s) 
  thus ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Basic g, Normal s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Spec r s) 
  thus ?case 
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Spec r, Normal s)&quot; 
    from f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Guard s g c m)
  have g: &quot;s &#8712; g&quot; by fact
  have hyp: &quot;&#172; &#915;&#8866; (c, Normal s) &#8594; &#8230;(&#8734;)&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Guard m g c, Normal s)&quot; 
    from f_step [of 0] f_0  g
    have &quot;f 1 = (c,Normal s)&quot;
      by (fastforce elim: step_elim_cases)
    with f_step
    have &quot;&#915;&#8866; (c, Normal s) &#8594; &#8230;(&#8734;)&quot;
      apply (simp add: inf_def)
      apply (rule_tac x=&quot;&#955;i. f (Suc i)&quot; in exI)
      by simp
    with hyp show False ..
  qed
next
  case (GuardFault s g m c)
  have g: &quot;s &#8713; g&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Guard m g c, Normal s)&quot; 
    from g f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Fault c m) 
  thus ?case
    by (rule not_inf_Fault)
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> s c<span class="hidden">&#8681;</span><sub>2</sub>)
  show ?case
  proof 
    assume &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Seq [OF this] Seq.hyps
    show False
      by (auto intro: steps_Skip_impl_exec)
  qed
next
  case (CondTrue s b c1 c2)
  have b: &quot;s &#8712; b&quot; by fact
  have hyp_c1: &quot;&#172; &#915;&#8866; (c1, Normal s) &#8594; &#8230;(&#8734;)&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Cond b c1 c2, Normal s)&quot; 
    from b f_step [of 0] f_0
    have &quot;f 1 = (c1,Normal s)&quot;
      by (auto elim: step_Normal_elim_cases)
    with f_step
    have &quot;&#915;&#8866; (c1, Normal s) &#8594; &#8230;(&#8734;)&quot;
      apply (simp add: inf_def)
      apply (rule_tac x=&quot;&#955;i. f (Suc i)&quot; in exI)
      by simp
    with hyp_c1 show False by simp
  qed    
next
  case (CondFalse s b c2 c1)
  have b: &quot;s &#8713; b&quot; by fact
  have hyp_c2: &quot;&#172; &#915;&#8866; (c2, Normal s) &#8594; &#8230;(&#8734;)&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Cond b c1 c2, Normal s)&quot; 
    from b f_step [of 0] f_0
    have &quot;f 1 = (c2,Normal s)&quot;
      by (auto elim: step_Normal_elim_cases)
    with f_step
    have &quot;&#915;&#8866; (c2, Normal s) &#8594; &#8230;(&#8734;)&quot;
      apply (simp add: inf_def)
      apply (rule_tac x=&quot;&#955;i. f (Suc i)&quot; in exI)
      by simp
    with hyp_c2 show False by simp
  qed
next    
  case (WhileTrue s b c)
  have b: &quot;s &#8712; b&quot; by fact
  have hyp_c: &quot;&#172; &#915;&#8866; (c, Normal s) &#8594; &#8230;(&#8734;)&quot; by fact
  have hyp_w: &quot;&#8704;s&#39;. &#915;&#8866; &#10216;c,Normal s&#10217; &#8658; s&#39; &#10230; 
                     &#915;&#8866;While b c &#8595; s&#39; &#8743; &#172; &#915;&#8866; (While b c, s&#39;) &#8594; &#8230;(&#8734;)&quot; by fact
  have not_inf_Seq: &quot;&#172; &#915;&#8866; (Seq c (While b c), Normal s) &#8594; &#8230;(&#8734;)&quot;
  proof 
    assume &quot;&#915;&#8866; (Seq c (While b c), Normal s) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Seq [OF this] hyp_c hyp_w show False
      by (auto intro: steps_Skip_impl_exec)
  qed
  show ?case
  proof 
    assume &quot;&#915;&#8866; (While b c, Normal s) &#8594; &#8230;(&#8734;)&quot;
    then obtain f where
      f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot; and
      f_0: &quot;f 0 = (While b c, Normal s)&quot; 
      by (auto simp add: inf_def)
    from f_step [of 0] f_0 b
    have &quot;f 1 = (Seq c (While b c),Normal s)&quot;
      by (auto elim: step_Normal_elim_cases)
    with f_step
    have &quot;&#915;&#8866; (Seq c (While b c), Normal s) &#8594; &#8230;(&#8734;)&quot;
      apply (simp add: inf_def)
      apply (rule_tac x=&quot;&#955;i. f (Suc i)&quot; in exI)
      by simp
    with not_inf_Seq show False by simp
  qed
next
  case (WhileFalse s b c)
  have b: &quot;s &#8713; b&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (While b c, Normal s)&quot; 
    from b f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Call p bdy s)
  have bdy: &quot;&#915; p = Some bdy&quot; by fact
  have hyp: &quot;&#172; &#915;&#8866; (bdy, Normal s) &#8594; &#8230;(&#8734;)&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Call p, Normal s)&quot; 
    from bdy f_step [of 0] f_0
    have &quot;f 1 = (bdy,Normal s)&quot;
      by (auto elim: step_Normal_elim_cases)
    with f_step
    have &quot;&#915;&#8866; (bdy, Normal s) &#8594; &#8230;(&#8734;)&quot;
      apply (simp add: inf_def)
      apply (rule_tac x=&quot;&#955;i. f (Suc i)&quot; in exI)
      by simp
    with hyp show False by simp
  qed    
next
  case (CallUndefined p s)
  have no_bdy: &quot;&#915; p = None&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Call p, Normal s)&quot; 
    from no_bdy f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
next
  case (Stuck c)
  show ?case
    by (rule not_inf_Stuck)
next
  case (DynCom c s)
  have hyp: &quot;&#172; &#915;&#8866; (c s, Normal s) &#8594; &#8230;(&#8734;)&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (DynCom c, Normal s)&quot; 
    from f_step [of 0] f_0
    have &quot;f (Suc 0) = (c s, Normal s)&quot;
      by (auto elim: step_elim_cases)
    with f_step have &quot;&#915;&#8866; (c s, Normal s) &#8594; &#8230;(&#8734;)&quot;
      apply (simp add: inf_def)
      apply (rule_tac x=&quot;&#955;i. f (Suc i)&quot; in exI)
      by simp
    with hyp
    show False by simp
  qed
next (&#915;,c) &#8733; clist
  case (Throw s) thus ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Throw, Normal s)&quot; 
    from f_step [of 0] f_0
    show False
      by (auto elim: step_elim_cases)
  qed  
next
  case (Abrupt c)
  show ?case
    by (rule not_inf_Abrupt)
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> s c<span class="hidden">&#8681;</span><sub>2</sub>)
  show ?case
  proof 
    assume &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; &#8230;(&#8734;)&quot;
    from split_inf_Catch [OF this] Catch.hyps
    show False
      by (auto intro: steps_Throw_impl_exec)
  qed
next
  case (AwaitTrue s b c)
  have b: &quot;s &#8712; b&quot; by fact
  show ?case
  proof (rule not_infI)
    fix f
    assume f_step: &quot;&#8896;i. &#915;&#8866;f i &#8594; f (Suc i)&quot;
    assume f_0: &quot;f 0 = (Await b c, Normal s)&quot; 
    from b f_step [of 0] f_0 f_step [of 1]
    show False
      by (fastforce elim: Skip_no_step step_elim_cases)
  qed
qed


definition
 termi_call_steps :: &quot;(&#39;s,&#39;p,&#39;f,&#39;e) body &#8658; ((&#39;s &#215; &#39;p) &#215; (&#39;s &#215; &#39;p))set&quot;
where
&quot;termi_call_steps &#915; =
 {((t,q),(s,p)). &#915;&#8866;Call p&#8595;Normal s &#8743; 
       (&#8707;c. &#915;&#8866;(Call p,Normal s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c,Normal t) &#8743; redex c = Call q)}&quot;


primrec subst_redex:: &quot;(&#39;s,&#39;p,&#39;f,&#39;e)com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e)com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e)com&quot;
where
&quot;subst_redex Skip c = c&quot; |
&quot;subst_redex (Basic f) c = c&quot; |
&quot;subst_redex (Spec r) c = c&quot; |
&quot;subst_redex (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) c  = Seq (subst_redex c<span class="hidden">&#8681;</span><sub>1</sub> c) c<span class="hidden">&#8681;</span><sub>2</sub>&quot; |
&quot;subst_redex (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) c = c&quot; |
&quot;subst_redex (While b c&#39;) c = c&quot; |
&quot;subst_redex (Await b c&#39;) c = c&quot; |
&quot;subst_redex (Call p) c = c&quot; |
&quot;subst_redex (DynCom d) c = c&quot; |
&quot;subst_redex (Guard f b c&#39;) c = c&quot; |
&quot;subst_redex (Throw) c = c&quot; |
&quot;subst_redex (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) c = Catch (subst_redex c<span class="hidden">&#8681;</span><sub>1</sub> c) c<span class="hidden">&#8681;</span><sub>2</sub>&quot;

lemma subst_redex_redex:
  &quot;subst_redex c (redex c) = c&quot;
  by (induct c) auto

lemma redex_subst_redex: &quot;redex (subst_redex c r) = redex r&quot;
  by (induct c) auto
  
lemma step_redex&#39;:
  shows &quot;&#915;&#8866;(redex c,s) &#8594; (r&#39;,s&#39;) &#10233; &#915;&#8866;(c,s) &#8594; (subst_redex c r&#39;,s&#39;)&quot;
by (induct c) (auto intro: step.Seq step.Catch)


lemma step_redex:
  shows &quot;&#915;&#8866;(r,s) &#8594; (r&#39;,s&#39;) &#10233; &#915;&#8866;(subst_redex c r,s) &#8594; (subst_redex c r&#39;,s&#39;)&quot;
by (induct c) (auto intro: step.Seq step.Catch)

lemma steps_redex:
  assumes steps: &quot;&#915;&#8866; (r, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (r&#39;, s&#39;)&quot;
  shows &quot;&#8896;c. &#915;&#8866;(subst_redex c r,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (subst_redex c r&#39;,s&#39;)&quot;
using steps
proof (induct rule: converse_rtranclp_induct2 [case_names Refl Trans])
  case Refl 
  show &quot;&#915;&#8866; (subst_redex c r&#39;, s&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (subst_redex c r&#39;, s&#39;)&quot;
    by simp
next
  case (Trans r s r&#39;&#39; s&#39;&#39;)
  have &quot;&#915;&#8866; (r, s) &#8594; (r&#39;&#39;, s&#39;&#39;)&quot; by fact
  from step_redex [OF this]
  have &quot;&#915;&#8866; (subst_redex c r, s) &#8594; (subst_redex c r&#39;&#39;, s&#39;&#39;)&quot;.
  also  
  have &quot;&#915;&#8866; (subst_redex c r&#39;&#39;, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (subst_redex c r&#39;, s&#39;)&quot; by fact
  finally show ?case .
qed

ML {*
  ML_Thms.bind_thm (&quot;trancl_induct2&quot;, Split_Rule.split_rule @{context}
    (Rule_Insts.read_instantiate @{context}
      [(((&quot;a&quot;, 0), Position.none), &quot;(aa, ab)&quot;), (((&quot;b&quot;, 0), Position.none), &quot;(ba, bb)&quot;)] []
      @{thm trancl_induct}));
*}

lemma steps_redex&#39;:
  assumes steps: &quot;&#915;&#8866; (r, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (r&#39;, s&#39;)&quot;
  shows &quot;&#8896;c. &#915;&#8866;(subst_redex c r,s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (subst_redex c r&#39;,s&#39;)&quot;
using steps
proof (induct rule: tranclp_induct2 [consumes 1,case_names Step Trans])
  case (Step r&#39; s&#39;)
  have &quot;&#915;&#8866; (r, s) &#8594; (r&#39;, s&#39;)&quot; by fact
  then have &quot;&#915;&#8866; (subst_redex c r, s) &#8594; (subst_redex c r&#39;, s&#39;)&quot;
    by (rule step_redex)
  then show &quot;&#915;&#8866; (subst_redex c r, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (subst_redex c r&#39;, s&#39;)&quot;..
next
  case (Trans r&#39; s&#39; r&#39;&#39; s&#39;&#39;)
  have &quot;&#915;&#8866; (subst_redex c r, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (subst_redex c r&#39;, s&#39;)&quot; by fact
  also
  have &quot;&#915;&#8866; (r&#39;, s&#39;) &#8594; (r&#39;&#39;, s&#39;&#39;)&quot; by fact
  hence &quot;&#915;&#8866; (subst_redex c r&#39;, s&#39;) &#8594; (subst_redex c r&#39;&#39;, s&#39;&#39;)&quot;
    by (rule step_redex)
  finally show &quot;&#915;&#8866; (subst_redex c r, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (subst_redex c r&#39;&#39;, s&#39;&#39;)&quot; .
qed

primrec seq:: &quot;(nat &#8658; (&#39;s,&#39;p,&#39;f,&#39;e)com) &#8658; &#39;p &#8658; nat &#8658; (&#39;s,&#39;p,&#39;f,&#39;e)com&quot;
where
&quot;seq c p 0 = Call p&quot; |
&quot;seq c p (Suc i) = subst_redex (seq c p i) (c i)&quot;


lemma renumber&#39;:
  assumes f: &quot;&#8704;i. (a,f i) &#8712; r<span class="hidden">&#8679;</span><sup>*</sup> &#8743; (f i,f(Suc i)) &#8712; r&quot; 
  assumes a_b: &quot;(a,b) &#8712; r<span class="hidden">&#8679;</span><sup>*</sup>&quot; 
  shows &quot;b = f 0 &#10233; (&#8707;f. f 0 = a &#8743; (&#8704;i. (f i, f(Suc i)) &#8712; r))&quot;
using a_b
proof (induct rule: converse_rtrancl_induct [consumes 1])
  assume &quot;b = f 0&quot;
  with f show &quot;&#8707;f. f 0 = b &#8743; (&#8704;i. (f i, f (Suc i)) &#8712; r)&quot;
    by blast
next
  fix a z
  assume a_z: &quot;(a, z) &#8712; r&quot; and &quot;(z, b) &#8712; r<span class="hidden">&#8679;</span><sup>*</sup>&quot; 
  assume &quot;b = f 0 &#10233; &#8707;f. f 0 = z &#8743; (&#8704;i. (f i, f (Suc i)) &#8712; r)&quot;
         &quot;b = f 0&quot;
  then obtain f where f0: &quot;f 0 = z&quot; and seq: &quot;&#8704;i. (f i, f (Suc i)) &#8712; r&quot;
    by iprover
  {
    fix i have &quot;((&#955;i. case i of 0 &#8658; a | Suc i &#8658; f i) i, f i) &#8712; r&quot;
      using seq a_z f0
      by (cases i) auto
  }
  then
  show &quot;&#8707;f. f 0 = a &#8743; (&#8704;i. (f i, f (Suc i)) &#8712; r)&quot;
    by - (rule exI [where x=&quot;&#955;i. case i of 0 &#8658; a | Suc i &#8658; f i&quot;],simp)
qed

lemma renumber:
 &quot;&#8704;i. (a,f i) &#8712; r<span class="hidden">&#8679;</span><sup>*</sup> &#8743; (f i,f(Suc i)) &#8712; r 
 &#10233; &#8707;f. f 0 = a &#8743; (&#8704;i. (f i, f(Suc i)) &#8712; r)&quot;
  by (blast dest:renumber&#39;)

lemma lem:
  &quot;&#8704;y. r<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> a y &#10230; P a &#10230; P y 
   &#10233; ((b,a) &#8712; {(y,x). P x &#8743; r x y}<span class="hidden">&#8679;</span><sup>+</sup>) = ((b,a) &#8712; {(y,x). P x &#8743; r<span class="hidden">&#8679;</span><sup>+</sup><span class="hidden">&#8679;</span><sup>+</sup> x y})&quot;
apply(rule iffI)
 apply clarify
 apply(erule trancl_induct)
  apply blast
 apply(blast intro:tranclp_trans)
apply clarify
apply(erule tranclp_induct)
 apply blast
apply(blast intro:trancl_trans)
done

corollary terminates_impl_no_infinite_trans_computation:
 assumes terminates: &quot;&#915;&#8866;c&#8595;s&quot;
 shows &quot;&#172;(&#8707;f. f 0 = (c,s) &#8743; (&#8704;i. &#915;&#8866;f i &#8594;<span class="hidden">&#8679;</span><sup>+</sup> f(Suc i)))&quot;
proof -
  have &quot;wf({(y,x). &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> x &#8743; &#915;&#8866;x &#8594; y}<span class="hidden">&#8679;</span><sup>+</sup>)&quot;
  proof (rule wf_trancl)
    show &quot;wf {(y, x). &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> x &#8743; &#915;&#8866;x &#8594; y}&quot;
    proof (simp only: wf_iff_no_infinite_down_chain,clarify,simp)
      fix f
      assume &quot;&#8704;i. &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> f i &#8743; &#915;&#8866;f i &#8594; f (Suc i)&quot;
      hence &quot;&#8707;f. f (0::nat) = (c,s) &#8743; (&#8704;i. &#915;&#8866;f i &#8594; f (Suc i))&quot;
        by (rule renumber [to_pred])
      moreover from terminates_impl_no_infinite_computation [OF terminates]
      have &quot;&#172; (&#8707;f. f (0::nat) = (c, s) &#8743; (&#8704;i. &#915;&#8866;f i &#8594; f (Suc i)))&quot;
        by (simp add: inf_def)
      ultimately show False
        by simp
    qed
  qed
  hence &quot;&#172; (&#8707;f. &#8704;i. (f (Suc i), f i)
                 &#8712; {(y, x). &#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> x &#8743; &#915;&#8866;x &#8594; y}<span class="hidden">&#8679;</span><sup>+</sup>)&quot;
    by (simp add: wf_iff_no_infinite_down_chain)
  thus ?thesis
  proof (rule contrapos_nn)
    assume &quot;&#8707;f. f (0::nat) = (c, s) &#8743; (&#8704;i. &#915;&#8866;f i &#8594;<span class="hidden">&#8679;</span><sup>+</sup> f (Suc i))&quot;
    then obtain f where
      f0: &quot;f 0 = (c, s)&quot; and
      seq: &quot;&#8704;i. &#915;&#8866;f i &#8594;<span class="hidden">&#8679;</span><sup>+</sup> f (Suc i)&quot;
      by iprover
    show 
      &quot;&#8707;f. &#8704;i. (f (Suc i), f i) &#8712; {(y, x). &#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> x &#8743; &#915;&#8866;x &#8594; y}<span class="hidden">&#8679;</span><sup>+</sup>&quot;
    proof (rule exI [where x=f],rule allI)
      fix i
      show &quot;(f (Suc i), f i) &#8712; {(y, x). &#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> x &#8743; &#915;&#8866;x &#8594; y}<span class="hidden">&#8679;</span><sup>+</sup>&quot;
      proof -   
        {
          fix i have &quot;&#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> f i&quot;
          proof (induct i)
            case 0 show &quot;&#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> f 0&quot;
              by (simp add: f0)
          next
            case (Suc n)
            have &quot;&#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> f n&quot;  by fact
            with seq show &quot;&#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> f (Suc n)&quot;
              by (blast intro: tranclp_into_rtranclp rtranclp_trans)
          qed
        }
        hence &quot;&#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> f i&quot;
          by iprover
        with seq have
          &quot;(f (Suc i), f i) &#8712; {(y, x). &#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> x &#8743; &#915;&#8866;x &#8594;<span class="hidden">&#8679;</span><sup>+</sup> y}&quot;
          by clarsimp
        moreover 
        have &quot;&#8704;y. &#915;&#8866;f i &#8594;<span class="hidden">&#8679;</span><sup>+</sup> y&#10230;&#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> f i&#10230;&#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> y&quot;
          by (blast intro: tranclp_into_rtranclp rtranclp_trans)
        ultimately 
        show ?thesis 
          by (subst lem )
      qed
    qed
  qed
qed

theorem wf_termi_call_steps: &quot;wf (termi_call_steps &#915;)&quot;
proof (simp only: termi_call_steps_def wf_iff_no_infinite_down_chain,
       clarify,simp)
  fix f
  assume inf: &quot;&#8704;i. (&#955;(t, q) (s, p).
                &#915;&#8866;Call p &#8595; Normal s &#8743;
                (&#8707;c. &#915;&#8866; (Call p, Normal s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c, Normal t) &#8743; redex c = Call q))
             (f (Suc i)) (f i)&quot;
  def s&#8801;&quot;&#955;i::nat. fst (f i)&quot; 
  def p&#8801;&quot;&#955;i::nat. snd (f i)::&#39;b&quot;
  from inf
  have inf&#39;: &quot;&#8704;i. &#915;&#8866;Call (p i) &#8595; Normal (s i) &#8743;
               (&#8707;c. &#915;&#8866; (Call (p i), Normal (s i)) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c, Normal (s (i+1))) &#8743; 
                    redex c = Call (p (i+1)))&quot;
    apply -
    apply (rule allI)
    apply (erule_tac x=i in allE)
    apply (auto simp add: s_def p_def)
    done
  show False
  proof -
    from inf&#39;
    have &quot;&#8707;c. &#8704;i. &#915;&#8866;Call (p i) &#8595; Normal (s i) &#8743;
               &#915;&#8866; (Call (p i), Normal (s i)) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c i, Normal (s (i+1))) &#8743; 
                    redex (c i) = Call (p (i+1))&quot;
      apply -
      apply (rule choice)
      by blast
    then obtain c where
      termi_c: &quot;&#8704;i. &#915;&#8866;Call (p i) &#8595; Normal (s i)&quot; and
      steps_c: &quot;&#8704;i. &#915;&#8866; (Call (p i), Normal (s i)) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c i, Normal (s (i+1)))&quot; and
      red_c:   &quot;&#8704;i. redex (c i) = Call (p (i+1))&quot;
      by auto
    def g&#8801;&quot;&#955;i. (seq c (p 0) i,Normal (s i)::(&#39;a,&#39;c) xstate)&quot;
    from red_c [rule_format, of 0]
    have &quot;g 0 = (Call (p 0), Normal (s 0))&quot;
      by (simp add: g_def)
    moreover
    {
      fix i
      have &quot;redex (seq c (p 0) i) = Call (p i)&quot;
        by (induct i) (auto simp add: redex_subst_redex red_c)
      from this [symmetric]
      have &quot;subst_redex (seq c (p 0) i) (Call (p i)) = (seq c (p 0) i)&quot;
        by (simp add: subst_redex_redex)
    } note subst_redex_seq = this
    have &quot;&#8704;i. &#915;&#8866; (g i) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (g (i+1))&quot;
    proof 
      fix i
      from steps_c [rule_format, of i]
      have &quot;&#915;&#8866; (Call (p i), Normal (s i)) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c i, Normal (s (i + 1)))&quot;.
      from steps_redex&#39; [OF this, of &quot;(seq c (p 0) i)&quot;]
      have &quot;&#915;&#8866; (subst_redex (seq c (p 0) i) (Call (p i)), Normal (s i)) &#8594;<span class="hidden">&#8679;</span><sup>+</sup>
                (subst_redex (seq c (p 0) i) (c i), Normal (s (i + 1)))&quot; .
      hence &quot;&#915;&#8866; (seq c (p 0) i, Normal (s i)) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> 
                 (seq c (p 0) (i+1), Normal (s (i + 1)))&quot;
        by (simp add: subst_redex_seq)
      thus &quot;&#915;&#8866; (g i) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (g (i+1))&quot;
        by (simp add: g_def)
    qed
    moreover
    from terminates_impl_no_infinite_trans_computation [OF termi_c [rule_format, of 0]]
    have &quot;&#172; (&#8707;f. f 0 = (Call (p 0), Normal (s 0)) &#8743; (&#8704;i. &#915;&#8866; f i &#8594;<span class="hidden">&#8679;</span><sup>+</sup> f (Suc i)))&quot; .
    ultimately show False
      by auto
  qed
qed


lemma no_infinite_computation_implies_wf: 
  assumes not_inf: &quot;&#172; &#915;&#8866; (c, s) &#8594; &#8230;(&#8734;)&quot;
  shows &quot;wf {(c2,c1). &#915; &#8866; (c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> c1 &#8743; &#915; &#8866; c1 &#8594; c2}&quot;
proof (simp only: wf_iff_no_infinite_down_chain,clarify, simp)
  fix f
  assume &quot;&#8704;i. &#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> f i &#8743; &#915;&#8866;f i &#8594; f (Suc i)&quot;
  hence &quot;&#8707;f. f 0 = (c, s) &#8743; (&#8704;i. &#915;&#8866;f i &#8594; f (Suc i))&quot;
    by (rule renumber [to_pred])
  moreover from not_inf
  have &quot;&#172; (&#8707;f. f 0 = (c, s) &#8743; (&#8704;i. &#915;&#8866;f i &#8594; f (Suc i)))&quot;
    by (simp add: inf_def)
  ultimately show False
    by simp
qed

lemma not_final_Stuck_step: &quot;&#172; final (c,Stuck) &#10233; &#8707;c&#39; s&#39;. &#915;&#8866; (c, Stuck) &#8594; (c&#39;,s&#39;)&quot;
by (induct c) (fastforce intro: step.intros simp add: final_def)+

lemma not_final_Abrupt_step: 
  &quot;&#172; final (c,Abrupt s) &#10233; &#8707;c&#39; s&#39;. &#915;&#8866; (c, Abrupt s) &#8594; (c&#39;,s&#39;)&quot;
by (induct c) (fastforce intro: step.intros simp add: final_def)+

lemma not_final_Fault_step: 
  &quot;&#172; final (c,Fault f) &#10233; &#8707;c&#39; s&#39;. &#915;&#8866; (c, Fault f) &#8594; (c&#39;,s&#39;)&quot;
by (induct c) (fastforce intro: step.intros simp add: final_def)+

lemma not_final_Normal_step: 
  &quot;&#172; final (c,Normal s) &#8743; ((&#8707;b c1. redex c = Await b c1) &#10230; &#915;&#8866;c &#8595; Normal s) &#10233; &#8707;c&#39; s&#39;. &#915;&#8866; (c, Normal s) &#8594; (c&#39;,s&#39;)&quot;
proof (induct c) 
  case Skip thus ?case by (simp add: final_def)
next
  case Basic thus ?case by (meson step.Basic)
next
  case (Spec r)
  thus ?case by (meson step.Spec step.SpecStuck)    
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  thus ?case by (metis SeqSkip SeqThrow final_def fst_conv redex.simps(4) step.Seq terminates_Normal_elim_cases(5))
next
  case (Cond b c1 c2)
  show ?case
    by (cases &quot;s &#8712; b&quot;) (fastforce intro: step.intros)+
next
  case (While b c)
  show ?case
    by (cases &quot;s &#8712; b&quot;) (fastforce intro: step.intros)+
next
  case (Call p)
  show ?case
  by (cases &quot;&#915; p&quot;) (fastforce intro: step.intros)+
next
  case DynCom thus ?case by (fastforce intro: step.intros)
next
  case (Guard f g c)
  show ?case
    by (cases &quot;s &#8712; g&quot;) (fastforce intro: step.intros)+
next
  case Throw
  thus ?case by (fastforce intro: step.intros simp add: final_def)
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  thus ?case
    by (cases &quot;final (c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s)&quot;) (fastforce intro: step.intros elim: terminates_Normal_elim_cases simp add: final_def)+
next
  case (Await b c) 
  then obtain ba c1 where x:&quot;(&#8707;ba c1. redex (Await b c) = Await ba c1)&quot; by simp
  then have &quot;&#915;&#8866;Await b c &#8595; Normal s&quot; using x Await.prems by blast 
  also have &quot;s &#8712; b&quot; by (meson `&#915;&#8866;Await b c &#8595; Normal s` terminates_Normal_elim_cases(12))
  moreover have &quot;&#8707;t. &#915;&#8866;&#10216;c, Normal s&#10217; &#8658; t&quot; by (meson calculation terminates_Normal_elim_cases(12) terminates_implies_exec) 
  ultimately show ?case using AwaitAbrupt  step.Await by fastforce
qed

lemma final_termi:
&quot;final (c,s) &#10233; &#915;&#8866;c&#8595;s&quot;
  by (cases s) (auto simp add: final_def terminates.intros)

lemma split_computation: 
assumes steps: &quot;&#915;&#8866; (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c<span class="hidden">&#8681;</span><sub>f</sub>, s<span class="hidden">&#8681;</span><sub>f</sub>)&quot;
assumes not_final: &quot;&#172; final (c,s)&quot;
assumes final: &quot;final (c<span class="hidden">&#8681;</span><sub>f</sub>,s<span class="hidden">&#8681;</span><sub>f</sub>)&quot;
shows &quot;&#8707;c&#39; s&#39;. &#915;&#8866; (c, s) &#8594; (c&#39;,s&#39;) &#8743; &#915;&#8866; (c&#39;, s&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c<span class="hidden">&#8681;</span><sub>f</sub>, s<span class="hidden">&#8681;</span><sub>f</sub>)&quot;
using steps not_final final
proof (induct rule: converse_rtranclp_induct2 [case_names Refl Trans])
  case Refl thus ?case by simp
next
  case (Trans c s c&#39; s&#39;)
  thus ?case by auto
qed


lemma wf_implies_termi_reach_step_case:
assumes hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (c, Normal s) &#8594; (c&#39;, s&#39;)&#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; and
        hyp1:&quot;(&#8896;b c1. (redex c = Await b c1) &#10233; &#915;&#8866;c1 &#8595; Normal s &#8743; s&#8712;b)&quot;
shows &quot;&#915;&#8866;c &#8595; Normal s&quot;
using hyp hyp1
proof (induct c)
  case Skip show ?case by (fastforce intro: terminates.intros)
next
  case Basic show ?case by (fastforce intro: terminates.intros)
next
  case (Spec r)
  show ?case
    by (cases &quot;&#8707;t. (s,t)&#8712;r&quot;) (fastforce intro: terminates.intros)+
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c&#39;, s&#39;) &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot;
using Seq.prems by blast 
   have hyp&#39;: &quot;(&#8896;b c1. (redex (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = Await b c1) &#10233; &#915;&#8866;c1 &#8595; Normal s &#8743; s&#8712;b)&quot; by fact 
  show ?case 
  proof (rule terminates.Seq)
    {
      fix c&#39; s&#39;
      assume step_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594; (c&#39;, s&#39;)&quot;      
      assume red: &quot;(&#8896;b c1. (redex c<span class="hidden">&#8681;</span><sub>1</sub>  = Await b c1) &#10233; &#915;&#8866;c1 &#8595; Normal s &#8743; s&#8712;b)&quot;
      have &quot;&#915;&#8866;c&#39; &#8595; s&#39;&quot;
      proof -
        from step_c<span class="hidden">&#8681;</span><sub>1</sub>
        have &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;
          by (simp add: step.Seq)          
        from hyp [OF this]
        have &quot;&#915;&#8866;Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot;.
        thus &quot;&#915;&#8866;c&#39;&#8595; s&#39;&quot;
          by cases auto
      qed
    } 
    from Seq.hyps (1) [OF this]
    show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>1</sub> &#8595; Normal s&quot; using terminates_Skip&#39; by (simp add: hyp&#39;) 
  next
    show &quot;&#8704;s&#39;. &#915;&#8866; &#10216;c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s&#10217; &#8658; s&#39; &#10230; &#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot;
    proof (intro allI impI)
      fix s&#39;
      assume exec_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; &#10216;c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s&#10217; &#8658; s&#39;&quot;
      show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot;
      proof (cases &quot;final (c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s)&quot;)
        case True
        hence &quot;c<span class="hidden">&#8681;</span><sub>1</sub>=Skip &#8744; c<span class="hidden">&#8681;</span><sub>1</sub>=Throw&quot;
          by (simp add: final_def)
        thus ?thesis
        proof
          assume Skip: &quot;c<span class="hidden">&#8681;</span><sub>1</sub>=Skip&quot;
          have s1:&quot;&#915;&#8866;(Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8743;&#172; (&#8707;b c1. Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> = Await b c1)&quot;
            by (simp add: step.SeqSkip)          
          from hyp 
          have &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&quot; using local.Skip s1 by blast 
          moreover from exec_c<span class="hidden">&#8681;</span><sub>1</sub> Skip
          have &quot;s&#39;=Normal s&quot;
            by (auto elim: exec_Normal_elim_cases)
          ultimately show ?thesis by simp
        next
          assume Throw: &quot;c<span class="hidden">&#8681;</span><sub>1</sub>=Throw&quot;
          with exec_c<span class="hidden">&#8681;</span><sub>1</sub> have &quot;s&#39;=Abrupt s&quot;
            by (auto elim: exec_Normal_elim_cases)
          thus ?thesis
            by auto
        qed
      next
        case False        
        from exec_impl_steps [OF exec_c<span class="hidden">&#8681;</span><sub>1</sub>]
        obtain c<span class="hidden">&#8681;</span><sub>f</sub> t where 
          steps_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c<span class="hidden">&#8681;</span><sub>f</sub>, t)&quot; and
          fin:&quot;(case s&#39; of
                 Abrupt x &#8658; c<span class="hidden">&#8681;</span><sub>f</sub> = Throw &#8743; t = Normal x
                | _ &#8658; c<span class="hidden">&#8681;</span><sub>f</sub> = Skip &#8743; t = s&#39;)&quot;
          by (fastforce split: xstate.splits)
        with fin have final: &quot;final (c<span class="hidden">&#8681;</span><sub>f</sub>,t)&quot;
          by (cases s&#39;) (auto simp add: final_def)
        from split_computation [OF steps_c<span class="hidden">&#8681;</span><sub>1</sub> False this]
        obtain c&#39;&#39; s&#39;&#39; where
          first: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
          rest: &quot;&#915;&#8866; (c&#39;&#39;, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c<span class="hidden">&#8681;</span><sub>f</sub>, t)&quot; 
          by blast
        from step.Seq [OF first]
        have &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (Seq c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;&#39;)&quot; by auto
        from hyp [OF this]
        have termi_s&#39;&#39;: &quot;&#915;&#8866;Seq c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&#39;&quot;.
        show ?thesis
        proof (cases s&#39;&#39;)
          case (Normal x)
          from termi_s&#39;&#39; [simplified Normal]
          have termi_c<span class="hidden">&#8681;</span><sub>2</sub>: &quot;&#8704;t. &#915;&#8866; &#10216;c&#39;&#39;,Normal x&#10217; &#8658; t &#10230; &#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; t&quot;
            by cases
          show ?thesis
          proof (cases &quot;&#8707;x&#39;. s&#39;=Abrupt x&#39;&quot;)
            case False
            with fin obtain &quot;c<span class="hidden">&#8681;</span><sub>f</sub>=Skip&quot; &quot;t=s&#39;&quot;
              by (cases s&#39;) auto
            from steps_Skip_impl_exec [OF rest [simplified this]] Normal
            have &quot;&#915;&#8866; &#10216;c&#39;&#39;,Normal x&#10217; &#8658; s&#39;&quot;
              by simp
            from termi_c<span class="hidden">&#8681;</span><sub>2</sub> [rule_format, OF this]
            show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; .
          next
            case True
            with fin obtain x&#39; where s&#39;: &quot;s&#39;=Abrupt x&#39;&quot; and &quot;c<span class="hidden">&#8681;</span><sub>f</sub>=Throw&quot; &quot;t=Normal x&#39;&quot;
              by auto
            from steps_Throw_impl_exec [OF rest [simplified this]] Normal 
            have &quot;&#915;&#8866; &#10216;c&#39;&#39;,Normal x&#10217; &#8658; Abrupt x&#39;&quot;
              by simp
            from termi_c<span class="hidden">&#8681;</span><sub>2</sub> [rule_format, OF this] s&#39;
            show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; by simp
           qed
        next
          case (Abrupt x)
          from steps_Abrupt_prop [OF rest this]
          have &quot;t=Abrupt x&quot; by simp
          with fin have &quot;s&#39;=Abrupt x&quot;
            by (cases s&#39;) auto
          thus &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; 
            by auto
        next
          case (Fault f)
          from steps_Fault_prop [OF rest this]
          have &quot;t=Fault f&quot; by simp
          with fin have &quot;s&#39;=Fault f&quot;
            by (cases s&#39;) auto
          thus &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; 
            by auto
        next
          case Stuck
          from steps_Stuck_prop [OF rest this]
          have &quot;t=Stuck&quot; by simp
          with fin have &quot;s&#39;=Stuck&quot;
            by (cases s&#39;) auto
          thus &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; 
            by auto
        qed
      qed
    qed
  qed
next
  case (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c&#39;, s&#39;) &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot;
by (simp add: Cond.prems(1)) 
  show ?case
  proof (cases &quot;s&#8712;b&quot;) 
    case True
    then have &quot;&#915;&#8866; (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &quot;
     by (simp add: step.CondTrue)     
    from hyp [OF this] have &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>1</sub> &#8595; Normal s&quot;.
    with True show ?thesis
      by (auto intro: terminates.intros)
  next
    case False
    then have &quot;&#915;&#8866; (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s)&quot;
      by (simp add: step.CondFalse)
    from hyp [OF this] have &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&quot;.
    with False show ?thesis
      by (auto intro: terminates.intros)
  qed
next
  case (While b c)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (While b c, Normal s) &#8594; (c&#39;, s&#39;)   &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by fact
  show ?case
  proof (cases &quot;s&#8712;b&quot;) 
    case True
    then have &quot;&#915;&#8866; (While b c, Normal s) &#8594; (Seq c (While b c), Normal s)&quot;
      by (simp add: step.WhileTrue)
    from hyp [OF this] have &quot;&#915;&#8866;(Seq c (While b c)) &#8595; Normal s&quot;.
    with True show ?thesis
      by (auto elim: terminates_Normal_elim_cases intro: terminates.intros)
  next
    case False
    thus ?thesis
      by (auto intro: terminates.intros)
  qed
next
  case (Call p)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Call p, Normal s) &#8594; (c&#39;, s&#39;)  &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by (simp add: Call.prems)
  show ?case
  proof (cases &quot;&#915; p&quot;)
    case None
    thus ?thesis
      by (auto intro: terminates.intros)
  next
    case (Some bdy)
    then have &quot;&#915;&#8866; (Call p, Normal s) &#8594; (bdy, Normal s)&quot;
      by (simp add: step.Call)
    from hyp [OF this] have &quot;&#915;&#8866;bdy &#8595; Normal s&quot;.
    with Some show ?thesis
      by (auto intro: terminates.intros)
  qed
next
  case (DynCom c)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (DynCom c, Normal s) &#8594; (c&#39;, s&#39;)  &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by fact
  have &quot;&#915;&#8866; (DynCom c, Normal s) &#8594; (c s, Normal s)&quot;
    by (simp add: step.DynCom)
  from hyp [OF this] have &quot;&#915;&#8866;c s &#8595; Normal s&quot;.
  then show ?case
    by (auto intro: terminates.intros)
next
  case (Guard f g c)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Guard f g c, Normal s) &#8594; (c&#39;, s&#39;)   &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by fact
  show ?case
  proof (cases &quot;s&#8712;g&quot;)
    case True
    then have &quot;&#915;&#8866; (Guard f g c, Normal s) &#8594; (c, Normal s) &quot;
      by (simp add: step.Guard) thm step.Guard
    from hyp [OF this] have &quot;&#915;&#8866;c&#8595; Normal s&quot;.
    with True show ?thesis
      by (auto intro: terminates.intros)
  next
    case False
    thus ?thesis
      by (auto intro: terminates.intros)
  qed
next 
  case Throw show ?case by (auto intro: terminates.intros)
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c&#39;, s&#39;)   &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by fact
  have hyp&#39;: &quot;(&#8896;b c1. (redex (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Await b c1) &#10233; &#915;&#8866;c1 &#8595; Normal s &#8743; s&#8712;b)&quot; by fact
  show ?case
  proof (rule terminates.Catch)
    {
      fix c&#39; s&#39;
      assume step_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594; (c&#39;, s&#39;)&quot;
      assume red: &quot;(&#8896;b c1. (redex c<span class="hidden">&#8681;</span><sub>1</sub>  = Await b c1) &#10233; &#915;&#8866;c1 &#8595; Normal s &#8743; s&#8712;b)&quot;
      have &quot;&#915;&#8866;c&#39; &#8595; s&#39;&quot;
      proof -
        from step_c<span class="hidden">&#8681;</span><sub>1</sub>
        have &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;) &quot;
          by (simp add: step.Catch)
        from hyp [OF this]
        have &quot;&#915;&#8866;Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot;.
        thus &quot;&#915;&#8866;c&#39;&#8595; s&#39;&quot;
          by cases auto
      qed
    } 
    from Catch.hyps (1) [OF this]
    show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>1</sub> &#8595; Normal s&quot; using terminates_Skip&#39; by (simp add: hyp&#39;)
  next  
    show &quot;&#8704;s&#39;. &#915;&#8866; &#10216;c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s&#10217; &#8658; Abrupt s&#39; &#10230; &#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&#39;&quot;
    proof (intro allI impI)
      fix s&#39;
      assume exec_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; &#10216;c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s&#10217; &#8658; Abrupt s&#39;&quot;
      show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&#39;&quot;
      proof (cases &quot;final (c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s)&quot;)
        case True
        with exec_c<span class="hidden">&#8681;</span><sub>1</sub>
        have Throw: &quot;c<span class="hidden">&#8681;</span><sub>1</sub>=Throw&quot;
          by (auto simp add: final_def elim: exec_Normal_elim_cases)
        have s1: &quot;&#915;&#8866;(Catch Throw c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s)&quot;
          by (simp add: step.CatchThrow)
        from hyp 
        have &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&quot; using local.Throw s1 by blast 
        moreover from exec_c<span class="hidden">&#8681;</span><sub>1</sub> Throw
        have &quot;s&#39;=s&quot;
          by (auto elim: exec_Normal_elim_cases)
        ultimately show ?thesis by simp
      next
        case False
        from exec_impl_steps [OF exec_c<span class="hidden">&#8681;</span><sub>1</sub>]
        obtain c<span class="hidden">&#8681;</span><sub>f</sub> t where 
          steps_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Throw, Normal s&#39;)&quot; 
          by (fastforce split: xstate.splits)
        from split_computation [OF steps_c<span class="hidden">&#8681;</span><sub>1</sub> False]
        obtain c&#39;&#39; s&#39;&#39; where
          first: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
          rest: &quot;&#915;&#8866; (c&#39;&#39;, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Throw, Normal s&#39;)&quot; 
          by (auto simp add: final_def)
        from step.Catch [OF first]
        have &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (Catch c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;&#39;)&quot; by auto
        from hyp [OF this] 
        have &quot;&#915;&#8866;Catch c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&#39;&quot;.
        moreover
        from steps_Throw_impl_exec [OF rest]
        have &quot;&#915;&#8866; &#10216;c&#39;&#39;,s&#39;&#39;&#10217; &#8658; Abrupt s&#39;&quot;.
        moreover
        from rest obtain x where &quot;s&#39;&#39;=Normal x&quot;
          by (cases s&#39;&#39;)
             (auto dest: steps_Fault_prop steps_Abrupt_prop steps_Stuck_prop)
        ultimately show ?thesis
          by (fastforce elim: terminates_elim_cases)
      qed
    qed
  qed
next
  case (Await b c) 
  have hyp&#39;:&quot;&#8896;ba c1. redex (Await b c) = Await ba c1 &#10233; &#915;&#8866;c1 &#8595; Normal s &#8743; s &#8712; ba&quot; by fact 
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Await b c, Normal s) &#8594; (c&#39;, s&#39;) &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by (simp add: final_termi step_await_final1)
  have red:&quot;redex (Await b c)  = Await b c&quot; by auto  
  then have &quot;&#8896;b1 c1. (redex (Await b c)  = Await b1 c1) &#10233; b1=b &#8743; c1 = c&quot; by simp
  then have &quot; &#915;&#8866;c &#8595; Normal s &#8743; s &#8712; b&quot; by (simp add: Await.prems(2))
  show ?case
  by (simp add: `&#915;&#8866;c &#8595; Normal s &#8743; s &#8712; b` terminates.AwaitTrue)      
qed


lemma wf_implies_termi_reach_step_case&#39;:
assumes hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (c, Normal s) &#8594; (c&#39;, s&#39;)&#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; and
        hyp1:&quot;~(&#8707;b c1. redex c = Await b c1)&quot;
shows &quot;&#915;&#8866;c &#8595; Normal s&quot;
using hyp hyp1
proof (induct c)
  case Skip show ?case by (fastforce intro: terminates.intros)
next
  case Basic show ?case by (fastforce intro: terminates.intros)
next
  case (Spec r)
  show ?case
    by (cases &quot;&#8707;t. (s,t)&#8712;r&quot;) (fastforce intro: terminates.intros)+
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c&#39;, s&#39;) &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot;
using Seq.prems by blast
  have hyp&#39;: &quot;~(&#8707;b c1. redex (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Await b c1)&quot; by fact
  show ?case 
  proof (rule terminates.Seq)
    {
      fix c&#39; s&#39;
      assume step_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594; (c&#39;, s&#39;)&quot;
      assume red:  &quot;~(&#8707;b c1. redex c<span class="hidden">&#8681;</span><sub>1</sub> = Await b c1)&quot;      
      have &quot;&#915;&#8866;c&#39; &#8595; s&#39;&quot;
      proof -
        from step_c<span class="hidden">&#8681;</span><sub>1</sub>
        have &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;
          by (simp add: step.Seq)          
        from hyp [OF this]
        have &quot;&#915;&#8866;Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot;.
        thus &quot;&#915;&#8866;c&#39;&#8595; s&#39;&quot;
          by cases auto
      qed
    } 
    from Seq.hyps (1) [OF this]
    show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>1</sub> &#8595; Normal s&quot;using hyp&#39; by force 
  next
    show &quot;&#8704;s&#39;. &#915;&#8866; &#10216;c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s&#10217; &#8658; s&#39; &#10230; &#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot;
    proof (intro allI impI)
      fix s&#39;
      assume exec_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; &#10216;c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s&#10217; &#8658; s&#39;&quot;
      show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot;
      proof (cases &quot;final (c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s)&quot;)
        case True
        hence &quot;c<span class="hidden">&#8681;</span><sub>1</sub>=Skip &#8744; c<span class="hidden">&#8681;</span><sub>1</sub>=Throw&quot;
          by (simp add: final_def)
        thus ?thesis
        proof
          assume Skip: &quot;c<span class="hidden">&#8681;</span><sub>1</sub>=Skip&quot;
          have s1:&quot;&#915;&#8866;(Seq Skip c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8743;&#172; (&#8707;b c1. Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> = Await b c1)&quot;
            by (simp add: step.SeqSkip)          
          from hyp 
          have &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&quot; using local.Skip s1 by blast 
          moreover from exec_c<span class="hidden">&#8681;</span><sub>1</sub> Skip
          have &quot;s&#39;=Normal s&quot;
            by (auto elim: exec_Normal_elim_cases)
          ultimately show ?thesis by simp
        next
          assume Throw: &quot;c<span class="hidden">&#8681;</span><sub>1</sub>=Throw&quot;
          with exec_c<span class="hidden">&#8681;</span><sub>1</sub> have &quot;s&#39;=Abrupt s&quot;
            by (auto elim: exec_Normal_elim_cases)
          thus ?thesis
            by auto
        qed
      next
        case False        
        from exec_impl_steps [OF exec_c<span class="hidden">&#8681;</span><sub>1</sub>]
        obtain c<span class="hidden">&#8681;</span><sub>f</sub> t where 
          steps_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c<span class="hidden">&#8681;</span><sub>f</sub>, t)&quot; and
          fin:&quot;(case s&#39; of
                 Abrupt x &#8658; c<span class="hidden">&#8681;</span><sub>f</sub> = Throw &#8743; t = Normal x
                | _ &#8658; c<span class="hidden">&#8681;</span><sub>f</sub> = Skip &#8743; t = s&#39;)&quot;
          by (fastforce split: xstate.splits)
        with fin have final: &quot;final (c<span class="hidden">&#8681;</span><sub>f</sub>,t)&quot;
          by (cases s&#39;) (auto simp add: final_def)
        from split_computation [OF steps_c<span class="hidden">&#8681;</span><sub>1</sub> False this]
        obtain c&#39;&#39; s&#39;&#39; where
          first: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
          rest: &quot;&#915;&#8866; (c&#39;&#39;, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c<span class="hidden">&#8681;</span><sub>f</sub>, t)&quot; 
          by blast
        from step.Seq [OF first]
        have &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (Seq c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;&#39;)&quot; by auto
        from hyp [OF this]
        have termi_s&#39;&#39;: &quot;&#915;&#8866;Seq c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&#39;&quot;.
        show ?thesis
        proof (cases s&#39;&#39;)
          case (Normal x)
          from termi_s&#39;&#39; [simplified Normal]
          have termi_c<span class="hidden">&#8681;</span><sub>2</sub>: &quot;&#8704;t. &#915;&#8866; &#10216;c&#39;&#39;,Normal x&#10217; &#8658; t &#10230; &#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; t&quot;
            by cases
          show ?thesis
          proof (cases &quot;&#8707;x&#39;. s&#39;=Abrupt x&#39;&quot;)
            case False
            with fin obtain &quot;c<span class="hidden">&#8681;</span><sub>f</sub>=Skip&quot; &quot;t=s&#39;&quot;
              by (cases s&#39;) auto
            from steps_Skip_impl_exec [OF rest [simplified this]] Normal
            have &quot;&#915;&#8866; &#10216;c&#39;&#39;,Normal x&#10217; &#8658; s&#39;&quot;
              by simp
            from termi_c<span class="hidden">&#8681;</span><sub>2</sub> [rule_format, OF this]
            show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; .
          next
            case True
            with fin obtain x&#39; where s&#39;: &quot;s&#39;=Abrupt x&#39;&quot; and &quot;c<span class="hidden">&#8681;</span><sub>f</sub>=Throw&quot; &quot;t=Normal x&#39;&quot;
              by auto
            from steps_Throw_impl_exec [OF rest [simplified this]] Normal 
            have &quot;&#915;&#8866; &#10216;c&#39;&#39;,Normal x&#10217; &#8658; Abrupt x&#39;&quot;
              by simp
            from termi_c<span class="hidden">&#8681;</span><sub>2</sub> [rule_format, OF this] s&#39;
            show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; by simp
           qed
        next
          case (Abrupt x)
          from steps_Abrupt_prop [OF rest this]
          have &quot;t=Abrupt x&quot; by simp
          with fin have &quot;s&#39;=Abrupt x&quot;
            by (cases s&#39;) auto
          thus &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; 
            by auto
        next
          case (Fault f)
          from steps_Fault_prop [OF rest this]
          have &quot;t=Fault f&quot; by simp
          with fin have &quot;s&#39;=Fault f&quot;
            by (cases s&#39;) auto
          thus &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; 
            by auto
        next
          case Stuck
          from steps_Stuck_prop [OF rest this]
          have &quot;t=Stuck&quot; by simp
          with fin have &quot;s&#39;=Stuck&quot;
            by (cases s&#39;) auto
          thus &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot; 
            by auto
        qed
      qed
    qed
  qed
next
  case (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c&#39;, s&#39;) &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot;
by (simp add: Cond.prems(1)) 
  show ?case
  proof (cases &quot;s&#8712;b&quot;) 
    case True
    then have &quot;&#915;&#8866; (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &quot;
     by (simp add: step.CondTrue)     
    from hyp [OF this] have &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>1</sub> &#8595; Normal s&quot;.
    with True show ?thesis
      by (auto intro: terminates.intros)
  next
    case False
    then have &quot;&#915;&#8866; (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s)&quot;
      by (simp add: step.CondFalse)
    from hyp [OF this] have &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&quot;.
    with False show ?thesis
      by (auto intro: terminates.intros)
  qed
next
  case (While b c)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (While b c, Normal s) &#8594; (c&#39;, s&#39;)   &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by fact
  show ?case
  proof (cases &quot;s&#8712;b&quot;) 
    case True
    then have &quot;&#915;&#8866; (While b c, Normal s) &#8594; (Seq c (While b c), Normal s)&quot;
      by (simp add: step.WhileTrue)
    from hyp [OF this] have &quot;&#915;&#8866;(Seq c (While b c)) &#8595; Normal s&quot;.
    with True show ?thesis
      by (auto elim: terminates_Normal_elim_cases intro: terminates.intros)
  next
    case False
    thus ?thesis
      by (auto intro: terminates.intros)
  qed
next
  case (Call p)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Call p, Normal s) &#8594; (c&#39;, s&#39;)  &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by (simp add: Call.prems)
  show ?case
  proof (cases &quot;&#915; p&quot;)
    case None
    thus ?thesis
      by (auto intro: terminates.intros)
  next
    case (Some bdy)
    then have &quot;&#915;&#8866; (Call p, Normal s) &#8594; (bdy, Normal s)&quot;
      by (simp add: step.Call)
    from hyp [OF this] have &quot;&#915;&#8866;bdy &#8595; Normal s&quot;.
    with Some show ?thesis
      by (auto intro: terminates.intros)
  qed
next
  case (DynCom c)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (DynCom c, Normal s) &#8594; (c&#39;, s&#39;)  &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by fact
  have &quot;&#915;&#8866; (DynCom c, Normal s) &#8594; (c s, Normal s)&quot;
    by (simp add: step.DynCom)
  from hyp [OF this] have &quot;&#915;&#8866;c s &#8595; Normal s&quot;.
  then show ?case
    by (auto intro: terminates.intros)
next
  case (Guard f g c)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Guard f g c, Normal s) &#8594; (c&#39;, s&#39;)   &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by fact
  show ?case
  proof (cases &quot;s&#8712;g&quot;)
    case True
    then have &quot;&#915;&#8866; (Guard f g c, Normal s) &#8594; (c, Normal s) &quot;
      by (simp add: step.Guard) thm step.Guard
    from hyp [OF this] have &quot;&#915;&#8866;c&#8595; Normal s&quot;.
    with True show ?thesis
      by (auto intro: terminates.intros)
  next
    case False
    thus ?thesis
      by (auto intro: terminates.intros)
  qed
next 
  case Throw show ?case by (auto intro: terminates.intros)
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  have hyp: &quot;&#8896;c&#39; s&#39;. &#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (c&#39;, s&#39;)   &#10233; &#915;&#8866;c&#39; &#8595; s&#39;&quot; by fact
  have hyp&#39;: &quot;~(&#8707;b c1. redex (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Await b c1)&quot; by fact
  show ?case
  proof (rule terminates.Catch)
    {
      fix c&#39; s&#39;
      assume step_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594; (c&#39;, s&#39;)&quot;
      assume red: &quot;~(&#8707;b c1. redex c<span class="hidden">&#8681;</span><sub>1</sub>  = Await b c1)&quot;
      have &quot;&#915;&#8866;c&#39; &#8595; s&#39;&quot;
      proof -
        from step_c<span class="hidden">&#8681;</span><sub>1</sub>
        have &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;) &quot;
          by (simp add: step.Catch)
        from hyp [OF this]
        have &quot;&#915;&#8866;Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&quot;.
        thus &quot;&#915;&#8866;c&#39;&#8595; s&#39;&quot;
          by cases auto
      qed
    } 
    from Catch.hyps (1) [OF this]
    show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>1</sub> &#8595; Normal s&quot; using hyp&#39; by force
  next  
    show &quot;&#8704;s&#39;. &#915;&#8866; &#10216;c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s&#10217; &#8658; Abrupt s&#39; &#10230; &#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&#39;&quot;
    proof (intro allI impI)
      fix s&#39;
      assume exec_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; &#10216;c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s&#10217; &#8658; Abrupt s&#39;&quot;
      show &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&#39;&quot;
      proof (cases &quot;final (c<span class="hidden">&#8681;</span><sub>1</sub>,Normal s)&quot;)
        case True
        with exec_c<span class="hidden">&#8681;</span><sub>1</sub>
        have Throw: &quot;c<span class="hidden">&#8681;</span><sub>1</sub>=Throw&quot;
          by (auto simp add: final_def elim: exec_Normal_elim_cases)
        have s1: &quot;&#915;&#8866;(Catch Throw c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s) &#8594; (c<span class="hidden">&#8681;</span><sub>2</sub>,Normal s)&quot;
          by (simp add: step.CatchThrow)
        from hyp 
        have &quot;&#915;&#8866;c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; Normal s&quot; using local.Throw s1 by blast 
        moreover from exec_c<span class="hidden">&#8681;</span><sub>1</sub> Throw
        have &quot;s&#39;=s&quot;
          by (auto elim: exec_Normal_elim_cases)
        ultimately show ?thesis by simp
      next
        case False
        from exec_impl_steps [OF exec_c<span class="hidden">&#8681;</span><sub>1</sub>]
        obtain c<span class="hidden">&#8681;</span><sub>f</sub> t where 
          steps_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Throw, Normal s&#39;)&quot; 
          by (fastforce split: xstate.splits)
        from split_computation [OF steps_c<span class="hidden">&#8681;</span><sub>1</sub> False]
        obtain c&#39;&#39; s&#39;&#39; where
          first: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, Normal s) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
          rest: &quot;&#915;&#8866; (c&#39;&#39;, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (Throw, Normal s&#39;)&quot; 
          by (auto simp add: final_def)
        from step.Catch [OF first]
        have &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, Normal s) &#8594; (Catch c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;&#39;)&quot; by auto
        from hyp [OF this] 
        have &quot;&#915;&#8866;Catch c&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8595; s&#39;&#39;&quot;.
        moreover
        from steps_Throw_impl_exec [OF rest]
        have &quot;&#915;&#8866; &#10216;c&#39;&#39;,s&#39;&#39;&#10217; &#8658; Abrupt s&#39;&quot;.
        moreover
        from rest obtain x where &quot;s&#39;&#39;=Normal x&quot;
          by (cases s&#39;&#39;)
             (auto dest: steps_Fault_prop steps_Abrupt_prop steps_Stuck_prop)
        ultimately show ?thesis
          by (fastforce elim: terminates_elim_cases)
      qed
    qed
  qed
next
  case (Await b c)       
  show ?case
  using Await.prems(2) by auto   
qed


lemma Await_finish:&quot;&#8896;c2 s2 b c. &#915;&#8866; (Await b c, s1) &#8594; (c2, s2) &#10233; &#915;&#8866;c2 &#8595; s2&quot;
by (metis Abrupt Fault Stuck final_termi step_await_final1 step_preserves_termination xstate.exhaust)

                                                            
lemma wf_implies_termi_reach:
assumes wf: &quot;wf {(cfg2,cfg1). &#915; &#8866; (c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> cfg1 &#8743; &#915; &#8866; cfg1 &#8594; cfg2}&quot;
shows &quot;&#8896;c1 s1. &#10214;&#915; &#8866; (c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> cfg1;  cfg1=(c1,s1)&#10215;&#10233; &#915;&#8866;c1&#8595;s1&quot;
using wf 
proof (induct cfg1,simp)
  fix c1 s1
  assume reach: &quot;&#915;&#8866; (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c1, s1)&quot;
  assume hyp_raw: &quot;&#8896;y c2 s2.
           &#10214;&#915;&#8866; (c1, s1) &#8594; (c2, s2); &#915;&#8866; (c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c2, s2); y = (c2, s2)&#10215;
           &#10233; &#915;&#8866;c2 &#8595; s2&quot;
  have hyp: &quot;&#8896;c2 s2. &#915;&#8866; (c1, s1) &#8594; (c2, s2) &#10233; &#915;&#8866;c2 &#8595; s2&quot;
    apply -
    apply (rule hyp_raw)
    apply   assumption
    using reach 
    apply  simp
    apply (rule refl)
    done
  
  show &quot;&#915;&#8866;c1 &#8595; s1&quot;
  proof (cases s1)  
    case (Normal s1&#39;)             
    with  wf_implies_termi_reach_step_case&#39; [OF hyp [simplified Normal]] 
    show ?thesis
      by auto
  qed (auto intro: terminates.intros)
qed

theorem no_infinite_computation_impl_terminates:
  assumes not_inf: &quot;&#172; &#915;&#8866; (c, s) &#8594; &#8230;(&#8734;)&quot;
  shows &quot;&#915;&#8866;c&#8595;s&quot;
proof -
  from no_infinite_computation_implies_wf [OF not_inf]
  have wf: &quot;wf {(c2, c1). &#915;&#8866;(c, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> c1 &#8743; &#915;&#8866;c1 &#8594; c2}&quot;.
  show ?thesis
    by (rule wf_implies_termi_reach [OF wf]) auto
qed

corollary terminates_iff_no_infinite_computation: 
  &quot;&#915;&#8866;c&#8595;s = (&#172; &#915;&#8866; (c, s) &#8594; &#8230;(&#8734;))&quot;
  apply (rule)
  apply  (erule terminates_impl_no_infinite_computation)
  apply (erule no_infinite_computation_impl_terminates)
  done

(* ************************************************************************* *)
subsection {* Generalised Redexes *} 
(* ************************************************************************* *)

text {*
For an important lemma for the completeness proof of the Hoare-logic for
total correctness we need a generalisation of @{const &quot;redex&quot;} that not only
yield the redex itself but all the enclosing statements as well.
*}

primrec redexes:: &quot;(&#39;s,&#39;p,&#39;f,&#39;e)com &#8658; (&#39;s,&#39;p,&#39;f,&#39;e)com set&quot;
where
&quot;redexes Skip = {Skip}&quot; |
&quot;redexes (Basic f) = {Basic f}&quot; |
&quot;redexes (Spec r) = {Spec r}&quot; |
&quot;redexes (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = {Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>} &#8746; redexes c<span class="hidden">&#8681;</span><sub>1</sub>&quot; |
&quot;redexes (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = {Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>}&quot; |
&quot;redexes (While b c) = {While b c}&quot; |
&quot;redexes (Call p) = {Call p}&quot; |
&quot;redexes (DynCom d) = {DynCom d}&quot; |
&quot;redexes (Guard f b c) = {Guard f b c}&quot; |
&quot;redexes (Throw) = {Throw}&quot; |
&quot;redexes (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = {Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>} &#8746; redexes c<span class="hidden">&#8681;</span><sub>1</sub>&quot; |
&quot;redexes (Await b c) = {Await b c}&quot;

lemma root_in_redexes: &quot;c &#8712; redexes c&quot;
  apply (induct c)
  apply auto
  done

lemma redex_in_redexes: &quot;redex c &#8712; redexes c&quot;
  apply (induct c)
  apply auto
  done

lemma redex_redexes: &quot;&#8896;c&#39;. &#10214;c&#39; &#8712; redexes c; redex c&#39; = c&#39;&#10215; &#10233; redex c = c&#39;&quot; 
  apply (induct c)
  apply auto
  done

lemma step_redexes:
  shows &quot;&#8896;r r&#39;. &#10214;&#915;&#8866;(r,s) &#8594; (r&#39;,s&#39;); r &#8712; redexes c&#10215; 
  &#10233; &#8707;c&#39;. &#915;&#8866;(c,s) &#8594; (c&#39;,s&#39;) &#8743; r&#39; &#8712; redexes c&#39;&quot;
proof (induct c)
  case Skip thus ?case by (fastforce intro: step.intros elim: step_elim_cases)
next
  case Basic thus ?case by (fastforce intro: step.intros elim: step_elim_cases)
next
  case Spec thus ?case by (fastforce intro: step.intros elim: step_elim_cases)
next
  case (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  have &quot;r &#8712; redexes (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)&quot; by fact
  hence r: &quot;r = Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> &#8744; r &#8712; redexes c<span class="hidden">&#8681;</span><sub>1</sub>&quot;
    by simp
  have step_r: &quot;&#915;&#8866; (r, s) &#8594; (r&#39;, s&#39;)&quot; by fact
  from r show ?case
  proof 
    assume &quot;r = Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>&quot;
    with step_r
    show ?case
      by (auto simp add: root_in_redexes)
  next
    assume r: &quot;r &#8712; redexes c<span class="hidden">&#8681;</span><sub>1</sub>&quot;
    from Seq.hyps (1) [OF step_r this] 
    obtain c&#39; where 
      step_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c&#39;, s&#39;)&quot; and
      r&#39;: &quot;r&#39; &#8712; redexes c&#39;&quot;
      by blast
    from step.Seq [OF step_c<span class="hidden">&#8681;</span><sub>1</sub>]
    have &quot;&#915;&#8866; (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, s) &#8594; (Seq c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;.
    with r&#39;
    show ?case
      by auto
  qed
next
  case Cond 
  thus ?case 
    by (fastforce intro: step.intros elim: step_elim_cases simp add: root_in_redexes)
next
  case While 
  thus ?case 
    by (fastforce intro: step.intros elim: step_elim_cases simp add: root_in_redexes)
next
  case Call thus ?case 
    by (fastforce intro: step.intros elim: step_elim_cases simp add: root_in_redexes)
next
  case DynCom thus ?case 
    by (fastforce intro: step.intros elim: step_elim_cases simp add: root_in_redexes)
next
  case Guard thus ?case 
    by (fastforce intro: step.intros elim: step_elim_cases simp add: root_in_redexes)
next
  case Throw thus ?case 
    by (fastforce intro: step.intros elim: step_elim_cases simp add: root_in_redexes)
next
  case (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)
  have &quot;r &#8712; redexes (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)&quot; by fact
  hence r: &quot;r = Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> &#8744; r &#8712; redexes c<span class="hidden">&#8681;</span><sub>1</sub>&quot;
    by simp
  have step_r: &quot;&#915;&#8866; (r, s) &#8594; (r&#39;, s&#39;)&quot; by fact
  from r show ?case
  proof 
    assume &quot;r = Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>&quot;
    with step_r
    show ?case
      by (auto simp add: root_in_redexes)
  next
    assume r: &quot;r &#8712; redexes c<span class="hidden">&#8681;</span><sub>1</sub>&quot;
    from Catch.hyps (1) [OF step_r this] 
    obtain c&#39; where 
      step_c<span class="hidden">&#8681;</span><sub>1</sub>: &quot;&#915;&#8866; (c<span class="hidden">&#8681;</span><sub>1</sub>, s) &#8594; (c&#39;, s&#39;)&quot; and
      r&#39;: &quot;r&#39; &#8712; redexes c&#39;&quot;
      by blast
    from step.Catch [OF step_c<span class="hidden">&#8681;</span><sub>1</sub>]
    have &quot;&#915;&#8866; (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>, s) &#8594; (Catch c&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;.
    with r&#39;
    show ?case
      by auto
  qed
next case (Await b c)  
     thus ?case 
     by (fastforce intro: step.intros elim: step_elim_cases simp add: root_in_redexes)
qed 

lemma steps_redexes:
  assumes steps: &quot;&#915;&#8866; (r, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (r&#39;, s&#39;)&quot;
  shows &quot;&#8896;c. r &#8712; redexes c &#10233; &#8707;c&#39;. &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;,s&#39;) &#8743; r&#39; &#8712; redexes c&#39;&quot;
using steps 
proof (induct rule: converse_rtranclp_induct2 [case_names Refl Trans])
  case Refl
  then
  show &quot;&#8707;c&#39;. &#915;&#8866; (c, s&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;, s&#39;) &#8743; r&#39; &#8712; redexes c&#39;&quot;
    by auto
next
  case (Trans r s r&#39;&#39; s&#39;&#39;)
  have &quot;&#915;&#8866; (r, s) &#8594; (r&#39;&#39;, s&#39;&#39;)&quot; &quot;r &#8712; redexes c&quot; by fact+
  from step_redexes [OF this]
  obtain c&#39; where
    step: &quot;&#915;&#8866; (c, s) &#8594; (c&#39;, s&#39;&#39;)&quot; and
    r&#39;&#39;: &quot;r&#39;&#39; &#8712; redexes c&#39;&quot;
    by blast
  note step
  also
  from Trans.hyps (3) [OF r&#39;&#39;]
  obtain c&#39;&#39; where
    steps: &quot;&#915;&#8866; (c&#39;, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;&#39;, s&#39;)&quot; and
    r&#39;: &quot;r&#39; &#8712; redexes c&#39;&#39;&quot;
    by blast
  note steps
  finally
  show ?case
    using r&#39;
    by blast
qed



lemma steps_redexes&#39;:
  assumes steps: &quot;&#915;&#8866; (r, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (r&#39;, s&#39;)&quot;
  shows &quot;&#8896;c. r &#8712; redexes c &#10233; &#8707;c&#39;. &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c&#39;,s&#39;) &#8743; r&#39; &#8712; redexes c&#39;&quot;
using steps 
proof (induct rule: tranclp_induct2 [consumes 1, case_names Step Trans])
  case (Step r&#39; s&#39; c&#39;) 
  have &quot;&#915;&#8866; (r, s) &#8594; (r&#39;, s&#39;)&quot; &quot;r &#8712; redexes c&#39;&quot; by fact+
  from step_redexes [OF this]
  show ?case
    by (blast intro: r_into_trancl)
next
  case (Trans r&#39; s&#39; r&#39;&#39; s&#39;&#39;)
  from Trans obtain c&#39; where
    steps: &quot;&#915;&#8866; (c, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c&#39;, s&#39;)&quot; and
    r&#39;: &quot;r&#39; &#8712; redexes c&#39;&quot;
    by blast
  note steps
  moreover
  have &quot;&#915;&#8866; (r&#39;, s&#39;) &#8594; (r&#39;&#39;, s&#39;&#39;)&quot; by fact
  from step_redexes [OF this r&#39;] obtain c&#39;&#39; where
    step: &quot;&#915;&#8866; (c&#39;, s&#39;) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
    r&#39;&#39;: &quot;r&#39;&#39; &#8712; redexes c&#39;&#39;&quot;
    by blast
  note step
  finally show ?case
    using r&#39;&#39; by blast
qed

lemma step_redexes_Seq:
  assumes step: &quot;&#915;&#8866;(r,s) &#8594; (r&#39;,s&#39;)&quot;
  assumes Seq: &quot;Seq r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&quot;
  shows &quot;&#8707;c&#39;. &#915;&#8866;(c,s) &#8594; (c&#39;,s&#39;) &#8743; Seq r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
proof -
  from step.Seq [OF step]
  have &quot;&#915;&#8866; (Seq r c<span class="hidden">&#8681;</span><sub>2</sub>, s) &#8594; (Seq r&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;.
  from step_redexes [OF this Seq] 
  show ?thesis .
qed

lemma steps_redexes_Seq:
  assumes steps: &quot;&#915;&#8866; (r, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (r&#39;, s&#39;)&quot;
  shows &quot;&#8896;c. Seq r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c &#10233; 
              &#8707;c&#39;. &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;,s&#39;) &#8743; Seq r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
using steps 
proof (induct rule: converse_rtranclp_induct2 [case_names Refl Trans])
  case Refl
  then show ?case
    by (auto)

next
  case (Trans r s r&#39;&#39; s&#39;&#39;)
  have &quot;&#915;&#8866; (r, s) &#8594; (r&#39;&#39;, s&#39;&#39;)&quot; &quot;Seq r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&quot; by fact+
  from step_redexes_Seq [OF this]
  obtain c&#39; where
    step: &quot;&#915;&#8866; (c, s) &#8594; (c&#39;, s&#39;&#39;)&quot; and
    r&#39;&#39;: &quot;Seq r&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
    by blast
  note step
  also
  from Trans.hyps (3) [OF r&#39;&#39;]
  obtain c&#39;&#39; where
    steps: &quot;&#915;&#8866; (c&#39;, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;&#39;, s&#39;)&quot; and
    r&#39;: &quot;Seq r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&#39;&quot;
    by blast
  note steps
  finally
  show ?case
    using r&#39;
    by blast
qed

lemma steps_redexes_Seq&#39;:
  assumes steps: &quot;&#915;&#8866; (r, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (r&#39;, s&#39;)&quot;
  shows &quot;&#8896;c. Seq r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c 
             &#10233; &#8707;c&#39;. &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c&#39;,s&#39;) &#8743; Seq r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
using steps 
proof (induct rule: tranclp_induct2 [consumes 1, case_names Step Trans])
  case (Step r&#39; s&#39; c&#39;) 
  have &quot;&#915;&#8866; (r, s) &#8594; (r&#39;, s&#39;)&quot; &quot;Seq r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot; by fact+
  from step_redexes_Seq [OF this]
  show ?case
    by (blast intro: r_into_trancl)
next
  case (Trans r&#39; s&#39; r&#39;&#39; s&#39;&#39;)
  from Trans obtain c&#39; where
    steps: &quot;&#915;&#8866; (c, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c&#39;, s&#39;)&quot; and
    r&#39;: &quot;Seq r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
    by blast
  note steps
  moreover
  have &quot;&#915;&#8866; (r&#39;, s&#39;) &#8594; (r&#39;&#39;, s&#39;&#39;)&quot; by fact
  from step_redexes_Seq [OF this r&#39;] obtain c&#39;&#39; where
    step: &quot;&#915;&#8866; (c&#39;, s&#39;) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
    r&#39;&#39;: &quot;Seq r&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&#39;&quot;
    by blast
  note step
  finally show ?case
    using r&#39;&#39; by blast
qed

lemma step_redexes_Catch:
  assumes step: &quot;&#915;&#8866;(r,s) &#8594; (r&#39;,s&#39;)&quot;
  assumes Catch: &quot;Catch r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&quot;
  shows &quot;&#8707;c&#39;. &#915;&#8866;(c,s) &#8594; (c&#39;,s&#39;) &#8743; Catch r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
proof -
  from step.Catch [OF step]
  have &quot;&#915;&#8866; (Catch r c<span class="hidden">&#8681;</span><sub>2</sub>, s) &#8594; (Catch r&#39; c<span class="hidden">&#8681;</span><sub>2</sub>, s&#39;)&quot;.
  from step_redexes [OF this Catch] 
  show ?thesis .
qed

lemma steps_redexes_Catch:
  assumes steps: &quot;&#915;&#8866; (r, s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (r&#39;, s&#39;)&quot;
  shows &quot;&#8896;c. Catch r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c &#10233; 
              &#8707;c&#39;. &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;,s&#39;) &#8743; Catch r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
using steps 
proof (induct rule: converse_rtranclp_induct2 [case_names Refl Trans])
  case Refl
  then show ?case
    by (auto)

next
  case (Trans r s r&#39;&#39; s&#39;&#39;)
  have &quot;&#915;&#8866; (r, s) &#8594; (r&#39;&#39;, s&#39;&#39;)&quot; &quot;Catch r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&quot; by fact+
  from step_redexes_Catch [OF this]
  obtain c&#39; where
    step: &quot;&#915;&#8866; (c, s) &#8594; (c&#39;, s&#39;&#39;)&quot; and
    r&#39;&#39;: &quot;Catch r&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
    by blast
  note step
  also
  from Trans.hyps (3) [OF r&#39;&#39;]
  obtain c&#39;&#39; where
    steps: &quot;&#915;&#8866; (c&#39;, s&#39;&#39;) &#8594;<span class="hidden">&#8679;</span><sup>*</sup> (c&#39;&#39;, s&#39;)&quot; and
    r&#39;: &quot;Catch r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&#39;&quot;
    by blast
  note steps
  finally
  show ?case
    using r&#39;
    by blast
qed

lemma steps_redexes_Catch&#39;:
  assumes steps: &quot;&#915;&#8866; (r, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (r&#39;, s&#39;)&quot;
  shows &quot;&#8896;c. Catch r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c 
             &#10233; &#8707;c&#39;. &#915;&#8866;(c,s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c&#39;,s&#39;) &#8743; Catch r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
using steps 
proof (induct rule: tranclp_induct2 [consumes 1, case_names Step Trans])
  case (Step r&#39; s&#39; c&#39;) 
  have &quot;&#915;&#8866; (r, s) &#8594; (r&#39;, s&#39;)&quot; &quot;Catch r c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot; by fact+
  from step_redexes_Catch [OF this]
  show ?case
    by (blast intro: r_into_trancl)
next
  case (Trans r&#39; s&#39; r&#39;&#39; s&#39;&#39;)
  from Trans obtain c&#39; where
    steps: &quot;&#915;&#8866; (c, s) &#8594;<span class="hidden">&#8679;</span><sup>+</sup> (c&#39;, s&#39;)&quot; and
    r&#39;: &quot;Catch r&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&quot;
    by blast
  note steps
  moreover
  have &quot;&#915;&#8866; (r&#39;, s&#39;) &#8594; (r&#39;&#39;, s&#39;&#39;)&quot; by fact
  from step_redexes_Catch [OF this r&#39;] obtain c&#39;&#39; where
    step: &quot;&#915;&#8866; (c&#39;, s&#39;) &#8594; (c&#39;&#39;, s&#39;&#39;)&quot; and
    r&#39;&#39;: &quot;Catch r&#39;&#39; c<span class="hidden">&#8681;</span><sub>2</sub> &#8712; redexes c&#39;&#39;&quot;
    by blast
  note step
  finally show ?case
    using r&#39;&#39; by blast
qed

lemma redexes_subset:&quot;&#8896;c&#39;. c&#39; &#8712; redexes c &#10233; redexes c&#39; &#8838; redexes c&quot;
  by (induct c) auto

lemma redexes_preserves_termination:
  assumes termi: &quot;&#915;&#8866;c&#8595;s&quot;
  shows &quot;&#8896;c&#39;. c&#39; &#8712; redexes c &#10233; &#915;&#8866;c&#39;&#8595;s&quot;  
using termi
by induct (auto intro: terminates.intros)

*)</span></span></span></span></span><span>
</span><span class="keyword2"><span class="keyword">end</span></span></pre>

</div>
</body>
</html>
