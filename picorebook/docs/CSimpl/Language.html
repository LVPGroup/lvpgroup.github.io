<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory Language (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory Language</h1>

<span class="command">theory</span> <span class="name">Language</span><br/>
<span class="keyword">imports</span> <a href="Old_Recdef.html"><span class="name">Old_Recdef</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
    Author:      Norbert Schirmer
    Maintainer:  Norbert Schirmer, norbert.schirmer at web de
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      Language.thy
    Author:     Norbert Schirmer, TU Muenchen

Copyright (C) 2004-2008 Norbert Schirmer 
Some rights reserved, TU Muenchen

This library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The Simpl Syntax *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>Language</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;HOL-Library.Old_Recdef&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* The Core Language *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* We use a shallow embedding of boolean expressions as well as assertions
as sets of states. 
*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;s</span><span> </span><span>bexp</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">type_synonym</span></span><span> </span><span class="tfree">&#39;s</span><span> </span><span>assn</span><span> </span><span class="delimiter">=</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s set&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">datatype</span></span><span> </span><span class="delimiter">(</span><span>dead</span><span> </span><span class="tfree">&#39;s</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;p</span><span class="delimiter">,</span><span> </span><span class="tfree">&#39;f</span><span class="delimiter">)</span><span> </span><span>com</span><span> </span><span class="delimiter">=</span><span>
</span><span>    </span><span>Skip</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Basic</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; &#39;s&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Spec</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#215; &#39;s) set&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Seq</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s ,&#39;p, &#39;f) com&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p, &#39;f) com&quot;</span></span></span><span>    
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Cond</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>While</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Call</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;p&quot;</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>DynCom</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Guard</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> 
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Throw</span><span>
</span><span>  </span><span class="delimiter">|</span><span> </span><span>Catch</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>set_fun</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;a set &#8658; &#39;a &#8658; bool&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_<span class="hidden">&#8681;</span><sub>f</sub>&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;set_fun s &#8801; &#955;v. v&#8712;s&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> </span><span class="delimiter">(</span><span>input</span><span class="delimiter">)</span><span>
</span><span>  </span><span>fun_set</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; bool) &#8658; &#39;a set&quot;</span></span></span><span>  </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_<span class="hidden">&#8681;</span><sub>s</sub>&quot;</span></span></span><span class="delimiter">)</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;fun_set f &#8801; {&#963;. f &#963;}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Derived Language Constructs *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>raise</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;s) &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;raise f = Seq (Basic f) Throw&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>condCatch</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; &#39;s bexp &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;condCatch c<span class="hidden">&#8681;</span><sub>1</sub> b c<span class="hidden">&#8681;</span><sub>2</sub> = Catch c<span class="hidden">&#8681;</span><sub>1</sub> (Cond b c<span class="hidden">&#8681;</span><sub>2</sub> Throw)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bind</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;v) &#8658; (&#39;v &#8658; (&#39;s,&#39;p,&#39;f) com) &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bind e c = DynCom (&#955;s. c (e s))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>bseq</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;bseq = Seq&quot;</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>block</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;[&#39;s&#8658;&#39;s,(&#39;s,&#39;p,&#39;f) com,&#39;s&#8658;&#39;s&#8658;&#39;s,&#39;s&#8658;&#39;s&#8658;(&#39;s,&#39;p,&#39;f) com]&#8658;(&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;block init bdy return c =
    DynCom (&#955;s. (Seq (Catch (Seq (Basic init) bdy) (Seq (Basic (return s)) Throw)) 
                            (DynCom (&#955;t. Seq (Basic (return s)) (c s t))))
                        )&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>call</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s&#8658;&#39;s) &#8658; &#39;p &#8658; (&#39;s &#8658; &#39;s &#8658; &#39;s)&#8658;(&#39;s&#8658;&#39;s&#8658;(&#39;s,&#39;p,&#39;f) com)&#8658;(&#39;s,&#39;p,&#39;f)com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;call init p return c = block init (Call p) return c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>dynCall</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;s) &#8658; (&#39;s &#8658; &#39;p) &#8658; 
             (&#39;s &#8658; &#39;s &#8658; &#39;s) &#8658; (&#39;s &#8658; &#39;s &#8658; (&#39;s,&#39;p,&#39;f) com) &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;dynCall init p return c = DynCom (&#955;s. call init (p s) return c)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>fcall</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s&#8658;&#39;s) &#8658; &#39;p &#8658; (&#39;s &#8658; &#39;s &#8658; &#39;s)&#8658;(&#39;s &#8658; &#39;v) &#8658; (&#39;v&#8658;(&#39;s,&#39;p,&#39;f) com)
            &#8658;(&#39;s,&#39;p,&#39;f)com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;fcall init p return result c = call init p return (&#955;s t. c (result t))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>lem</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;x &#8658; (&#39;s,&#39;p,&#39;f)com &#8658;(&#39;s,&#39;p,&#39;f)com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;lem x c = c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>switch</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; &#39;v) &#8658; (&#39;v set &#215; (&#39;s,&#39;p,&#39;f) com) list &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;switch v [] = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;switch v (Vc#vs) = Cond {s. v s &#8712; fst Vc} (snd Vc) (switch v vs)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>guaranteeStrip</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f &#8658; &#39;s set &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;guaranteeStrip f g c = Guard f g c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>guaranteeStripPair</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f &#8658; &#39;s set &#8658; (&#39;f &#215; &#39;s set)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;guaranteeStripPair f g = (f,g)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;f &#215; &#39;s set ) list &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;guards [] c = c&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;guards (g#gs) c = Guard (fst g) (snd g) (guards gs c)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>while</span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;f &#215; &#39;s set) list &#8658; &#39;s bexp &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s, &#39;p, &#39;f) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;while gs b c = guards gs (While b (Seq c (guards gs Skip)))&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>whileAnno</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp &#8658; &#39;s assn &#8658; (&#39;s &#215; &#39;s) assn &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;whileAnno b I V c = While b c&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>whileAnnoG</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;f &#215; &#39;s set) list &#8658; &#39;s bexp &#8658; &#39;s assn &#8658; (&#39;s &#215; &#39;s) assn &#8658; 
     (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;whileAnnoG gs b I V c = while gs b c&quot;</span></span></span><span>
</span><span> 
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>specAnno</span><span class="delimiter">::</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;a &#8658; &#39;s assn) &#8658; (&#39;a &#8658; (&#39;s,&#39;p,&#39;f) com) &#8658; 
                         (&#39;a &#8658; &#39;s assn) &#8658; (&#39;a &#8658; &#39;s assn) &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;specAnno P c Q A = (c undefined)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>whileAnnoFix</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;s bexp &#8658; (&#39;a &#8658; &#39;s assn) &#8658; (&#39;a &#8658; (&#39;s &#215; &#39;s) assn) &#8658; (&#39;a &#8658; (&#39;s,&#39;p,&#39;f) com) &#8658; 
     (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;whileAnnoFix b I V c = While b (c undefined)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span>
</span><span>  </span><span>whileAnnoGFix</span><span class="delimiter">::</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;f &#215; &#39;s set) list &#8658; &#39;s bexp &#8658; (&#39;a &#8658; &#39;s assn) &#8658; (&#39;a &#8658; (&#39;s &#215; &#39;s) assn) &#8658; 
     (&#39;a &#8658; (&#39;s,&#39;p,&#39;f) com) &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;whileAnnoGFix gs b I V c = while gs b (c undefined)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>if_rel</span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s &#8658; bool) &#8658; (&#39;s &#8658; &#39;s) &#8658; (&#39;s &#8658; &#39;s) &#8658; (&#39;s &#8658; &#39;s) &#8658; (&#39;s &#215; &#39;s) set&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;if_rel b f g h = {(s,t). if b s then t = f s else t = g s &#8744; t = h s}&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>fst_guaranteeStripPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;fst (guaranteeStripPair f g) = f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStripPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>snd_guaranteeStripPair</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;snd (guaranteeStripPair f g) = g&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStripPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Operations on Simpl-Syntax *}</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Normalisation of Sequential Composition: @{text &quot;sequence&quot;}, @{text &quot;flatten&quot;} and @{text &quot;normalize&quot;} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>flatten</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com list&quot;</span></span></span><span> 
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten Skip = [Skip]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Basic f) = [Basic f]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Spec r) = [Spec r]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = flatten c<span class="hidden">&#8681;</span><sub>1</sub> @ flatten c<span class="hidden">&#8681;</span><sub>2</sub>&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = [Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (While b c) = [While b c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Call p) = [Call p]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (DynCom c) = [DynCom c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Guard f g c) = [Guard f g c]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten Throw = [Throw]&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;flatten (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = [Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>]&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>sequence</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com) &#8658; 
                      (&#39;s,&#39;p,&#39;f) com list &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequence seq [] = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;sequence seq (c#cs) = (case cs of [] &#8658; c
                        | _ &#8658; seq c (sequence seq cs))&quot;</span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>normalize</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Basic f) = Basic f&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Spec r) = Spec r&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = sequence Seq
                            ((flatten (normalize c<span class="hidden">&#8681;</span><sub>1</sub>)) @ (flatten (normalize c<span class="hidden">&#8681;</span><sub>2</sub>)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (normalize c<span class="hidden">&#8681;</span><sub>1</sub>) (normalize c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (While b c) = While b (normalize c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (DynCom c) = DynCom (&#955;s. (normalize (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Guard f g c) = Guard f g (normalize c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;normalize (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (normalize c<span class="hidden">&#8681;</span><sub>1</sub>) (normalize c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten c &#8800; []&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span>simp_all</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_single</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;c &#8712; set (flatten c&#39;). flatten c = [c]&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>           </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>          </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>         </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>        </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>        </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>       </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>      </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>     </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span class="delimiter">(</span><span>no_asm_use</span><span class="delimiter">)</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_sequence_id</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;cs&#8800;[];&#8704;c &#8712; set cs. flatten c = [c]&#10215; &#10233; flatten (sequence Seq cs) = cs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>cs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_app</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (sequence Seq (flatten c1 @ flatten c2)) = flatten c1 @ flatten c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>flatten_sequence_id</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>flatten_single</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span>  
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_sequence_flatten</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (sequence Seq (flatten c)) = flatten c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_app</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>sequence_flatten_normalize</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;sequence Seq (flatten (normalize c)) = normalize c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span>  </span><span>flatten_app</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_normalize</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;x xs. flatten (normalize c) = x#xs 
       &#10233; (case xs of [] &#8658; normalize c = x 
              | (x&#39;#xs&#39;) &#8658; normalize c= Seq x (sequence Seq xs))&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Seq</span><span> </span><span>c1</span><span> </span><span>c2</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize (Seq c1 c2)) = x # xs&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>fact</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (sequence Seq (flatten (normalize c1) @ flatten (normalize c2))) = 
          x#xs&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span>x_xs</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize c1) @ flatten (normalize c2) = x # xs&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_app</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?case</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize c1)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>flatten_nonEmpty</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">case</span></span><span> </span><span class="delimiter">(</span><span>Cons</span><span> </span><span>x1</span><span> </span><span>xs1</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>x_xs</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> 
</span><span>      </span><span>x_x1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;x=x1&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>xs_rest</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;xs=xs1@flatten (normalize c2)&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>xs1</span><span class="delimiter">)</span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Seq.hyps</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons_x1_xs1</span><span class="delimiter">]</span><span> </span><span>Nil</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize c1 = x1&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span>Nil</span><span> </span><span>x_x1</span><span> </span><span>xs_rest</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize c2)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>      </span><span class="keyword3"><span class="command">case</span></span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Seq.hyps</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>Cons_x1_xs1</span><span class="delimiter">]</span><span> </span><span>Cons</span><span>
</span><span>      </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize c1 = Seq x1 (sequence Seq xs1)&quot;</span></span></span><span>
</span><span>        </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>      </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>Cons_x1_xs1</span><span> </span><span>Nil</span><span> </span><span>x_x1</span><span> </span><span>xs_rest</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize c2)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>list.splits</span><span class="delimiter">)</span><span>
</span><span>        </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_raise</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (raise f) = [Basic f, Throw]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (condCatch c1 b c2) = [condCatch c1 b c2]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (bind e c) = [bind e c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (bseq c1 c2) = flatten c1 @ flatten c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (block init bdy return result) = [block init bdy return result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (call init p return result) = [call init p return result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (dynCall init p return result) = [dynCall init p return result]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (fcall init p return result c) = [fcall init p return result c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (switch v Vcs) = [switch v Vcs]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>Vcs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (guaranteeStrip f g c) = [guaranteeStrip f g c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (while gs b c) = [while gs b c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (whileAnno b I V c) = [whileAnno b I V c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (whileAnnoG gs b I V c) = [whileAnnoG gs b I V c]&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>flatten_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (specAnno P c Q A) = flatten (c undefined)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>flatten_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>flatten.simps</span><span> </span><span>flatten_raise</span><span> </span><span>flatten_condCatch</span><span> </span><span>flatten_bind</span><span>
</span><span>  </span><span>flatten_block</span><span> </span><span>flatten_call</span><span> </span><span>flatten_dynCall</span><span> </span><span>flatten_fcall</span><span> </span><span>flatten_switch</span><span>
</span><span>  </span><span>flatten_guaranteeStrip</span><span>
</span><span>  </span><span>flatten_while</span><span> </span><span>flatten_whileAnno</span><span> </span><span>flatten_whileAnnoG</span><span> </span><span>flatten_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_raise</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (raise f) = raise f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (condCatch c1 b c2) = condCatch (normalize c1) b (normalize c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (bind e c) = bind e (&#955;v. normalize (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (bseq c1 c2) = sequence bseq
                            ((flatten (normalize c1)) @ (flatten (normalize c2)))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (block init bdy return c) = 
                         block init (normalize bdy) return (&#955;s t. normalize (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize bdy)&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>drule</span><span> </span><span>flatten_normalize</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>list</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize (c s sa))&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>flatten_nonEmpty</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>thin_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;flatten (normalize bdy) = P&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">for</span></span><span> </span><span>P</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span>flatten_normalize</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>lista</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (call init p return c) = call init p return (&#955;i t. normalize (c i t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (dynCall init p return c) = 
    dynCall init p return (&#955;s t. normalize (c s t))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (fcall init p return result c) = 
    fcall init p return result (&#955;v. normalize (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (switch v Vcs) = switch v (map (&#955;(V,c). (V,normalize c)) Vcs)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Vcs</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (guaranteeStrip f g c) = guaranteeStrip f g (normalize c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_guards</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (guards gs c) = guards gs (normalize c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Sequencial composition with guards in the body is not preserved by
        normalize *}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (while gs b c) = guards gs
      (While b (sequence Seq (flatten (normalize c) @ flatten (guards gs Skip))))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (whileAnno b I V c) = whileAnno b I V (normalize c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (whileAnnoG gs b I V c) = guards gs
      (While b (sequence Seq (flatten (normalize c) @ flatten (guards gs Skip))))&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>normalize_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;normalize (specAnno P c Q A) = specAnno P (&#955;s. normalize (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>normalize_simps</span><span> </span><span class="delimiter">=</span><span> 
</span><span>  </span><span>normalize.simps</span><span> </span><span>normalize_raise</span><span> </span><span>normalize_condCatch</span><span> </span><span>normalize_bind</span><span>
</span><span>  </span><span>normalize_block</span><span> </span><span>normalize_call</span><span> </span><span>normalize_dynCall</span><span> </span><span>normalize_fcall</span><span> </span><span>normalize_switch</span><span>
</span><span>  </span><span>normalize_guaranteeStrip</span><span> </span><span>normalize_guards</span><span> 
</span><span>  </span><span>normalize_while</span><span> </span><span>normalize_whileAnno</span><span> </span><span>normalize_whileAnnoG</span><span> </span><span>normalize_specAnno</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Stripping Guards: @{text &quot;strip_guards&quot;} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>strip_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f set &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Basic f) = Basic f&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Spec r) = Spec r&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (Seq (strip_guards F c<span class="hidden">&#8681;</span><sub>1</sub>) (strip_guards F c<span class="hidden">&#8681;</span><sub>2</sub>))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (strip_guards F c<span class="hidden">&#8681;</span><sub>1</sub>) (strip_guards F c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (While b c) = While b (strip_guards F c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (DynCom c) = DynCom (&#955;s. (strip_guards F (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Guard f g c) = (if f &#8712; F then strip_guards F c
                                  else Guard f g (strip_guards F c))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (strip_guards F c<span class="hidden">&#8681;</span><sub>1</sub>) (strip_guards F c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>strip</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f set &#8658; 
                   (&#39;p &#8658; (&#39;s,&#39;p,&#39;f) com option) &#8658; (&#39;p &#8658; (&#39;s,&#39;p,&#39;f) com option)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip F &#915; = (&#955;p. map_option (strip_guards F) (&#915; p))&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_simp</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(strip F &#915;) p = map_option (strip_guards F) (&#915; p)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>strip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dom_strip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dom (strip F &#915;) = dom &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (strip_guards F c) = strip_guards F c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_idem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip F (strip F &#915;) = strip F &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; x&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>strip_guards_idem</span><span> </span><span>strip_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_raise</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (raise f) = raise f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (condCatch c1 b c2) = 
    condCatch (strip_guards F c1) b (strip_guards F c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (bind e c) = bind e (&#955;v. strip_guards F (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (bseq c1 c2) = bseq (strip_guards F c1) (strip_guards F c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (block init bdy return c) =
    block init (strip_guards F bdy) return (&#955;s t. strip_guards F (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (call init p return c) =
     call init p return (&#955;s t. strip_guards F (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (dynCall init p return c) =
     dynCall init p return (&#955;s t. strip_guards F (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (fcall init p return result c) =
     fcall init p return result (&#955;v. strip_guards F (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (switch v Vc) =
    switch v (map (&#955;(V,c). (V,strip_guards F c)) Vc)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Vc</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (guaranteeStrip f g c) = 
    (if f &#8712; F then strip_guards F c 
     else guaranteeStrip f g (strip_guards F c))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>guaranteeStripPair_split_conv</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;case_prod c (guaranteeStripPair f g) = c f g&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStripPair_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_guards</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (guards gs c) =
        guards (filter (&#955;(f,g). f &#8713; F) gs) (strip_guards F c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (while gs b  c) = 
     while (filter (&#955;(f,g). f &#8713; F) gs) b (strip_guards F c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (whileAnno b I V c) = whileAnno b I V (strip_guards F c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span>  </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (whileAnnoG gs b I V c) = 
     whileAnnoG (filter (&#955;(f,g). f &#8713; F) gs) b I V (strip_guards F c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>strip_guards_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;strip_guards F (specAnno P c Q A) = 
    specAnno P (&#955;s. strip_guards F (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>strip_guards_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>strip_guards.simps</span><span> </span><span>strip_guards_raise</span><span> 
</span><span>  </span><span>strip_guards_condCatch</span><span> </span><span>strip_guards_bind</span><span> </span><span>strip_guards_bseq</span><span> </span><span>strip_guards_block</span><span>
</span><span>  </span><span>strip_guards_dynCall</span><span> </span><span>strip_guards_fcall</span><span> </span><span>strip_guards_switch</span><span> 
</span><span>  </span><span>strip_guards_guaranteeStrip</span><span> </span><span>guaranteeStripPair_split_conv</span><span> </span><span>strip_guards_guards</span><span>
</span><span>  </span><span>strip_guards_while</span><span> </span><span>strip_guards_whileAnno</span><span> </span><span>strip_guards_whileAnnoG</span><span>
</span><span>  </span><span>strip_guards_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Marking Guards: @{text &quot;mark_guards&quot;} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>mark_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#39;f &#8658; (&#39;s,&#39;p,&#39;g) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Basic g) = Basic g&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Spec r) = Spec r&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (Seq (mark_guards f c<span class="hidden">&#8681;</span><sub>1</sub>) (mark_guards f c<span class="hidden">&#8681;</span><sub>2</sub>))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (mark_guards f c<span class="hidden">&#8681;</span><sub>1</sub>) (mark_guards f c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (While b c) = While b (mark_guards f c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (DynCom c) = DynCom (&#955;s. (mark_guards f (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Guard f&#39; g c) = Guard f g (mark_guards f c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (mark_guards f c<span class="hidden">&#8681;</span><sub>1</sub>) (mark_guards f c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_raise</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (raise g) = raise g&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (condCatch c1 b c2) = 
    condCatch (mark_guards f c1) b (mark_guards f c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (bind e c) = bind e (&#955;v. mark_guards f (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (bseq c1 c2) = bseq (mark_guards f c1) (mark_guards f c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (block init bdy return c) =
    block init (mark_guards f bdy) return (&#955;s t. mark_guards f (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (call init p return c) =
     call init p return (&#955;s t. mark_guards f (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (dynCall init p return c) =
     dynCall init p return (&#955;s t. mark_guards f (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (fcall init p return result c) =
     fcall init p return result (&#955;v. mark_guards f (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (switch v vs) = 
     switch v (map (&#955;(V,c). (V,mark_guards f c)) vs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>vs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (guaranteeStrip f&#39; g c) = guaranteeStrip f g (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_guards</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (guards gs c) = guards (map (&#955;(f&#39;,g). (f,g)) gs) (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>gs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_while</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (while gs b c) = 
    while (map (&#955;(f&#39;,g). (f,g)) gs) b (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>while_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (whileAnno b I V c) = whileAnno b I V (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_whileAnnoG</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (whileAnnoG gs b I V c) = 
    whileAnnoG (map (&#955;(f&#39;,g). (f,g)) gs) b I V (mark_guards f c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span> </span><span>whileAnnoG_def</span><span> </span><span>while_def</span><span class="delimiter">)</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>mark_guards_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;mark_guards f (specAnno P c Q A) = 
    specAnno P (&#955;s. mark_guards f (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>mark_guards_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>mark_guards.simps</span><span> </span><span>mark_guards_raise</span><span> 
</span><span>  </span><span>mark_guards_condCatch</span><span> </span><span>mark_guards_bind</span><span> </span><span>mark_guards_bseq</span><span> </span><span>mark_guards_block</span><span>
</span><span>  </span><span>mark_guards_dynCall</span><span> </span><span>mark_guards_fcall</span><span> </span><span>mark_guards_switch</span><span> 
</span><span>  </span><span>mark_guards_guaranteeStrip</span><span> </span><span>guaranteeStripPair_split_conv</span><span> </span><span>mark_guards_guards</span><span>
</span><span>  </span><span>mark_guards_while</span><span> </span><span>mark_guards_whileAnno</span><span> </span><span>mark_guards_whileAnnoG</span><span>
</span><span>  </span><span>mark_guards_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">definition</span></span><span> </span><span>is_Guard</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; bool&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard c = (case c of Guard f g c&#39; &#8658; True | _ &#8658; False)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Guard_basic_simps</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard Skip = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Basic f) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Spec r) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Seq c1 c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Cond b c1 c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (While b c) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Call p) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (DynCom C) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Guard F g c) = True&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Throw) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (Catch c1 c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (raise f) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (condCatch c1 b c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (bind e cv) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (bseq c1 c2) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (block init bdy return cont) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (call init p return cont) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (dynCall init P return cont) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (fcall init p return result cont&#39;) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (whileAnno b I V c) = False&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (guaranteeStrip F g c) = True&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>raise_def</span><span> </span><span>condCatch_def</span><span> </span><span>bind_def</span><span> </span><span>bseq_def</span><span>
</span><span>          </span><span>block_def</span><span> </span><span>call_def</span><span> </span><span>dynCall_def</span><span> </span><span>fcall_def</span><span> </span><span>whileAnno_def</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>is_Guard_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;is_Guard (switch v Vc) = False&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>Vc</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>is_Guard_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>is_Guard_basic_simps</span><span> </span><span>is_Guard_switch</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>dest_Guard</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; (&#39;f &#215; &#39;s set &#215; (&#39;s,&#39;p,&#39;f) com)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dest_Guard (Guard f g c) = (f,g,c)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>dest_Guard_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;dest_Guard (guaranteeStrip f g c) = (f,g,c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>dest_Guard_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>dest_Guard.simps</span><span> </span><span>dest_Guard_guaranteeStrip</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Merging Guards: @{text merge_guards}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>merge_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards Skip = Skip&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Basic g) = Basic g&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Spec r) = Spec r&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (Seq (merge_guards c<span class="hidden">&#8681;</span><sub>1</sub>) (merge_guards c<span class="hidden">&#8681;</span><sub>2</sub>))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Cond b (merge_guards c<span class="hidden">&#8681;</span><sub>1</sub>) (merge_guards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (While b c) = While b (merge_guards c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Call p) = Call p&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (DynCom c) = DynCom (&#955;s. (merge_guards (c s)))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*&quot;merge_guards (Guard f g c) = 
    (case (merge_guards c) of
      Guard f&#39; g&#39; c&#39; &#8658; if f=f&#39; then Guard f (g &#8745; g&#39;) c&#39; 
                        else Guard f g (Guard f&#39; g&#39; c&#39;)
     | _ &#8658;  Guard f g (merge_guards c))&quot;*)</span></span></span></span></span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* the following version works better with derived language constructs *)</span></span></span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Guard f g c) = 
    (let c&#39; = (merge_guards c)
     in if is_Guard c&#39; 
        then let (f&#39;,g&#39;,c&#39;&#39;) = dest_Guard c&#39; 
             in if f=f&#39; then Guard f (g &#8745; g&#39;) c&#39;&#39; 
                        else Guard f g (Guard f&#39; g&#39; c&#39;&#39;)
        else Guard f g c&#39;)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards Throw = Throw&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = Catch (merge_guards c<span class="hidden">&#8681;</span><sub>1</sub>) (merge_guards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Skip &#10233; c = Skip&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Basic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Basic f &#10233; c = Basic f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Spec r &#10233; c = Spec r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Seq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Seq c1 c2 &#10233; 
    &#8707;c1&#39; c2&#39;. c = Seq c1&#39; c2&#39; &#8743; merge_guards c1&#39; = c1 &#8743; merge_guards c2&#39; = c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Cond</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Cond b c1 c2 &#10233; 
    &#8707;c1&#39; c2&#39;. c = Cond b c1&#39; c2&#39; &#8743; merge_guards c1&#39; = c1 &#8743; merge_guards c2&#39; = c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_While</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = While b c&#39; &#10233; 
    &#8707;c&#39;&#39;. c = While b c&#39;&#39;  &#8743; merge_guards c&#39;&#39; = c&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Call</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Call p &#10233; c = Call p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_DynCom</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = DynCom c&#39; &#10233; 
    &#8707;c&#39;&#39;. c = DynCom c&#39;&#39;  &#8743; (&#955;s. (merge_guards (c&#39;&#39; s))) = c&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Throw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Throw &#10233; c = Throw&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Catch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Catch c1 c2 &#10233; 
    &#8707;c1&#39; c2&#39;. c = Catch c1&#39; c2&#39; &#8743; merge_guards c1&#39; = c1 &#8743; merge_guards c2&#39; = c2&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_res_Guard</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = Guard f g c&#39; &#10233; &#8707;c&#39;&#39; f&#39; g&#39;. c = Guard f&#39; g&#39; c&#39;&#39;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>com.splits</span><span> </span><span>if_split_asm</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>is_Guard_def</span><span> </span><span>Let_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_guards_res_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_guards_res_Skip</span><span> </span><span>merge_guards_res_Basic</span><span> 
</span><span> </span><span>merge_guards_res_Spec</span><span> </span><span>merge_guards_res_Seq</span><span> </span><span>merge_guards_res_Cond</span><span> 
</span><span> </span><span>merge_guards_res_While</span><span> </span><span>merge_guards_res_Call</span><span>
</span><span> </span><span>merge_guards_res_DynCom</span><span> </span><span>merge_guards_res_Throw</span><span> </span><span>merge_guards_res_Catch</span><span> 
</span><span> </span><span>merge_guards_res_Guard</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_raise</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (raise g) = raise g&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_condCatch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (condCatch c1 b c2) = 
    condCatch (merge_guards c1) b (merge_guards c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_bind</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (bind e c) = bind e (&#955;v. merge_guards (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_bseq</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (bseq c1 c2) = bseq (merge_guards c1) (merge_guards c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_block</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (block init bdy return c) =
    block init (merge_guards bdy) return (&#955;s t. merge_guards (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_call</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (call init p return c) =
     call init p return (&#955;s t. merge_guards (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_dynCall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (dynCall init p return c) =
     dynCall init p return (&#955;s t. merge_guards (c s t))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>dynCall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_fcall</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (fcall init p return result c) =
     fcall init p return result (&#955;v. merge_guards (c v))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_switch</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (switch v vs) = 
     switch v (map (&#955;(V,c). (V,merge_guards c)) vs)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>vs</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_guaranteeStrip</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (guaranteeStrip f g c) = 
    (let c&#39; = (merge_guards c)
     in if is_Guard c&#39; 
        then let (f&#39;,g&#39;,c&#39;) = dest_Guard c&#39; 
             in if f=f&#39; then Guard f (g &#8745; g&#39;) c&#39; 
                        else Guard f g (Guard f&#39; g&#39; c&#39;)
        else Guard f g c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_whileAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (whileAnno b I V c) = whileAnno b I V (merge_guards c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>merge_guards_specAnno</span><span> </span><span class="delimiter">[</span><span>simp</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards (specAnno P c Q A) = 
    specAnno P (&#955;s. merge_guards (c undefined)) Q A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* @{term &quot;merge_guards&quot;} for guard-lists as in @{const guards}, @{const while}
 and @{const whileAnnoG} may have funny effects since the guard-list has to
 be merged with the body statement too.*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>merge_guards_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>merge_guards.simps</span><span> </span><span>merge_guards_raise</span><span> 
</span><span>  </span><span>merge_guards_condCatch</span><span> </span><span>merge_guards_bind</span><span> </span><span>merge_guards_bseq</span><span> </span><span>merge_guards_block</span><span>
</span><span>  </span><span>merge_guards_dynCall</span><span> </span><span>merge_guards_fcall</span><span> </span><span>merge_guards_switch</span><span> 
</span><span>  </span><span>merge_guards_guaranteeStrip</span><span> </span><span>merge_guards_whileAnno</span><span> </span><span>merge_guards_specAnno</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>noguards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards Skip = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Basic f) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Spec r ) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (noguards c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noguards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (noguards c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noguards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (While b c) = (noguards c)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Call p) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (DynCom c) = (&#8704;s. noguards (c s))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Guard f g c) = False&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards Throw = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;noguards (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (noguards c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; noguards c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>noguards_strip_guards</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;noguards (strip_guards UNIV c)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">primrec</span></span><span> </span><span>nothrows</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; bool&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows Skip = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Basic f) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Spec r) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>)  = (nothrows c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; nothrows c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (nothrows c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; nothrows c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (While b c) = nothrows c&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Call p) = True&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (DynCom c) = (&#8704;s. nothrows (c s))&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Guard f g c) = nothrows c&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows Throw = False&quot;</span></span></span><span> </span><span class="delimiter">|</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;nothrows (Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) = (nothrows c<span class="hidden">&#8681;</span><sub>1</sub> &#8743; nothrows c<span class="hidden">&#8681;</span><sub>2</sub>)&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Intersecting Guards: @{text &quot;c<span class="hidden">&#8681;</span><sub>1</sub> &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c<span class="hidden">&#8681;</span><sub>2</sub>&quot;}*}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_set</span></span><span> </span><span>com_rel</span><span> </span><span class="delimiter">::</span><span class="string"><span class="delete"><span class="delete">&quot;((&#39;s,&#39;p,&#39;f) com &#215; (&#39;s,&#39;p,&#39;f) com) set&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(c1, Seq c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2, Seq c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c1, Cond b c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2, Cond b c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, While b c) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c x, DynCom c) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Guard f g c) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c1, Catch c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span class="delimiter">|</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c2, Catch c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">inductive_cases</span></span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Skip) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Basic f) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Spec r) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Seq c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Cond b c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, While b c1) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Call p) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, DynCom c1) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Guard f g c1) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Throw) &#8712; com_rel&quot;</span></span></span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(c, Catch c1 c2) &#8712; com_rel&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>wf_com_rel</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf com_rel&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wfUNIVI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>           </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>          </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>         </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>        </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>
</span><span>               </span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>       </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>
</span><span>              </span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>      </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>     </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>mp</span><span class="delimiter">,</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span> </span><span>impI</span><span class="delimiter">)</span><span class="delimiter">+</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>com_rel_elim_cases</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>inter_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#215; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com option&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span> 
</span><span>  </span><span>inter_guards_syntax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com option&quot;</span></span></span><span>
</span><span>           </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8745;<span class="hidden">&#8681;</span><sub>g</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>20</span><span class="delimiter">,</span><span>20</span><span class="delimiter">]</span><span> </span><span>19</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8745;<span class="hidden">&#8681;</span><sub>g</sub> d == inter_guards (c,d)&quot;</span></span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">recdef</span></span><span> </span><span>inter_guards</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_image com_rel fst&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;(Skip &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Skip) = Some Skip&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Basic f1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Basic f2) = (if (f1=f2) then Some (Basic f1) else None)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Spec r1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Spec r2) = (if (r1=r2) then Some (Spec r1) else None)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq a1 a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Seq b1 b2) = 
   (case (a1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> b1) of
      None &#8658; None
    | Some c1 &#8658; (case (a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> b2) of
                    None &#8658; None
                  | Some c2 &#8658; Some (Seq c1 c2)))&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Cond cnd1 t1 e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Cond cnd2 t2 e2) = 
   (if (cnd1=cnd2) 
    then (case (t1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> t2) of 
            None &#8658; None
          | Some t &#8658; (case (e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> e2) of
                         None &#8658; None
                       | Some e &#8658; Some (Cond cnd1 t e)))
    else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(While cnd1 c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> While cnd2 c2) = 
    (if (cnd1=cnd2 )
     then (case (c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) of
             None &#8658; None
           | Some c &#8658; Some (While cnd1 c))
     else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Call p1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Call p2) = 
   (if p1 = p2
    then Some (Call p1)
    else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(DynCom P1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> DynCom P2) = 
   (if (&#8704;s. ((P1 s) &#8745;<span class="hidden">&#8681;</span><sub>g</sub> (P2 s)) &#8800; None)
   then Some (DynCom (&#955;s.  the ((P1 s) &#8745;<span class="hidden">&#8681;</span><sub>g</sub> (P2 s))))
   else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Guard m1 g1 c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Guard m2 g2 c2) = 
   (if m1=m2 then
       (case (c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) of
          None &#8658; None
        | Some c &#8658; Some (Guard m1 (g1 &#8745; g2) c))
    else None)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Throw &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Throw) = Some Throw&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch a1 a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> Catch b1 b2) = 
   (case (a1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> b1) of
      None &#8658; None
    | Some c1 &#8658; (case (a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> b2) of
                    None &#8658; None
                  | Some c2 &#8658; Some (Catch c1 c2)))&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;(c &#8745;<span class="hidden">&#8681;</span><sub>g</sub> d) = None&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">hints</span></span><span> </span><span>cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>option.case_cong</span><span> </span><span>if_cong</span><span>  
</span><span>       </span><span>recdef_wf</span><span class="delimiter">:</span><span> </span><span>wf_com_rel</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>com_rel.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_strip_eq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;c. (c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c  &#10233; 
    (strip_guards UNIV c = strip_guards UNIV c1) &#8743; 
    (strip_guards UNIV c = strip_guards UNIV c2)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c1</span><span> </span><span>c2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>inter_guards.induct</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>8</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>hypsubst</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">,</span><span> </span><span>erule</span><span> </span><span>exE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_sym</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;c. (c1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c &#10233; (c2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c1) = Some c&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c1</span><span> </span><span>c2</span><span> </span><span>rule</span><span class="delimiter">:</span><span> </span><span>inter_guards.induct</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>7</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>not_None_eq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conjI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ext</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>s</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span class="delimiter">+</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(Skip &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c = (c2=Skip &#8743; c=Skip)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Basic</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((Basic f) &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c = (c2=Basic f &#8743; c=Basic f)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Spec</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;((Spec r) &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c = (c2=Spec r &#8743; c=Spec r)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Seq</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Seq a1 a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c = 
     (&#8707;b1 b2 d1 d2. c2=Seq b1 b2 &#8743; (a1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> b1) = Some d1 &#8743; 
        (a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> b2) = Some d2 &#8743; c=Seq d1 d2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Cond</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Cond cnd t1 e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c =
     (&#8707;t2 e2 t e. c2=Cond cnd t2 e2 &#8743; (t1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> t2) = Some t &#8743; 
        (e1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> e2) = Some e &#8743; c=Cond cnd t e)&quot;</span></span></span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_While</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(While cnd bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c =
     (&#8707;bdy2 bdy. c2 =While cnd bdy2 &#8743; (bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> bdy2) = Some bdy &#8743;
       c=While cnd bdy)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Call</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Call p &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c =
     (c2=Call p &#8743; c=Call p)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_DynCom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(DynCom f1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c =
     (&#8707;f2. c2=DynCom f2 &#8743; (&#8704;s. ((f1 s) &#8745;<span class="hidden">&#8681;</span><sub>g</sub> (f2 s)) &#8800; None) &#8743;
      c=DynCom (&#955;s. the ((f1 s) &#8745;<span class="hidden">&#8681;</span><sub>g</sub> (f2 s))))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Guard</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Guard f g1 bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c =
     (&#8707;g2 bdy2 bdy. c2=Guard f g2 bdy2 &#8743; (bdy1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> bdy2) = Some bdy &#8743;
       c=Guard f (g1 &#8745; g2) bdy)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Throw</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Throw &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c = (c2=Throw &#8743; c=Throw)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>inter_guards_Catch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(Catch a1 a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> c2) = Some c = 
     (&#8707;b1 b2 d1 d2. c2=Catch b1 b2 &#8743; (a1 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> b1) = Some d1 &#8743; 
        (a2 &#8745;<span class="hidden">&#8681;</span><sub>g</sub> b2) = Some d2 &#8743; c=Catch d1 d2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c2</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>option.splits</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>inter_guards_simps</span><span> </span><span class="delimiter">=</span><span> </span><span>inter_guards_Skip</span><span> </span><span>inter_guards_Basic</span><span> </span><span>inter_guards_Spec</span><span>
</span><span>  </span><span>inter_guards_Seq</span><span> </span><span>inter_guards_Cond</span><span> </span><span>inter_guards_While</span><span> </span><span>inter_guards_Call</span><span>
</span><span>  </span><span>inter_guards_DynCom</span><span> </span><span>inter_guards_Guard</span><span> </span><span>inter_guards_Throw</span><span> 
</span><span>  </span><span>inter_guards_Catch</span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Subset on Guards: @{text &quot;c<span class="hidden">&#8681;</span><sub>1</sub> &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c<span class="hidden">&#8681;</span><sub>2</sub>&quot;} *}</span></span></span></span></span><span> 
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">consts</span></span><span> </span><span>subseteq_guards</span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#215; (&#39;s,&#39;p,&#39;f) com &#8658; bool&quot;</span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">abbreviation</span></span><span>
</span><span>  </span><span>subseteq_guards_syntax</span><span> </span><span class="delimiter">::</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;(&#39;s,&#39;p,&#39;f) com &#8658; (&#39;s,&#39;p,&#39;f) com &#8658; bool&quot;</span></span></span><span>
</span><span>           </span><span class="delimiter">(</span><span class="string"><span class="delete"><span class="delete">&quot;_ &#8838;<span class="hidden">&#8681;</span><sub>g</sub> _&quot;</span></span></span><span> </span><span class="delimiter">[</span><span>20</span><span class="delimiter">,</span><span>20</span><span class="delimiter">]</span><span> </span><span>19</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> d == subseteq_guards (c,d)&quot;</span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">recdef</span></span><span> </span><span>subseteq_guards</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;inv_image com_rel snd&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;(Skip &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Skip) = True&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Basic f1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Basic f2) = (f1=f2)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Spec r1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Spec r2) = (r1=r2)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Seq a1 a2 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Seq b1 b2) = ((a1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> b1) &#8743; (a2 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> b2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Cond cnd1 t1 e1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Cond cnd2 t2 e2) = ((cnd1=cnd2) &#8743; (t1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> t2) &#8743; (e1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> e2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(While cnd1 c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> While cnd2 c2) = ((cnd1=cnd2) &#8743; (c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Call p1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Call p2) = (p1 = p2)&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(DynCom P1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> DynCom P2) = (&#8704;s. ((P1 s) &#8838;<span class="hidden">&#8681;</span><sub>g</sub> (P2 s)))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Guard m1 g1 c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Guard m2 g2 c2) = 
    ((m1=m2 &#8743; g1=g2 &#8743; (c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c2)) &#8744; (Guard m1 g1 c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c2))&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Guard m2 g2 c2) = (c1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c2)&quot;</span></span></span><span>
</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Throw &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Throw) = True&quot;</span></span></span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;(Catch a1 a2 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Catch b1 b2) = ((a1 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> b1) &#8743; (a2 &#8838;<span class="hidden">&#8681;</span><sub>g</sub> b2))&quot;</span></span></span><span> 
</span><span class="string"><span class="delete"><span class="delete">&quot;(c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> d) = False&quot;</span></span></span><span>
</span><span>
</span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">hints</span></span><span> </span><span>cong</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_cong</span><span>  
</span><span>       </span><span>recdef_wf</span><span class="delimiter">:</span><span> </span><span>wf_com_rel</span><span> </span><span>simp</span><span class="delimiter">:</span><span> </span><span>com_rel.intros</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Skip</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Skip &#10233; c = Skip&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Basic</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Basic f &#10233; c = Basic f&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Spec</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Spec r &#10233; c = Spec r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Seq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Seq c1 c2 &#10233; &#8707;c1&#39; c2&#39;. c=Seq c1&#39; c2&#39; &#8743; (c1&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c1) &#8743; (c2&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Cond</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Cond b c1 c2 &#10233; &#8707;c1&#39; c2&#39;. c=Cond b c1&#39; c2&#39; &#8743; (c1&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c1) &#8743; (c2&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_While</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> While b c&#39; &#10233; &#8707;c&#39;&#39;. c=While b c&#39;&#39; &#8743; (c&#39;&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Call</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Call p &#10233; c = Call p&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_DynCom</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> DynCom C &#10233; &#8707;C&#39;. c=DynCom C&#39; &#8743; (&#8704;s. C&#39; s &#8838;<span class="hidden">&#8681;</span><sub>g</sub> C s)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Guard</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Guard f g c&#39;  &#10233; 
     (c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c&#39;) &#8744; (&#8707;c&#39;&#39;. c=Guard f g c&#39;&#39; &#8743; (c&#39;&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c&#39;))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>split</span><span class="delimiter">:</span><span> </span><span>if_split_asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Throw</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Throw &#10233; c = Throw&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Catch</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> Catch c1 c2 &#10233; &#8707;c1&#39; c2&#39;. c=Catch c1&#39; c2&#39; &#8743; (c1&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c1) &#8743; (c2&#39; &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c2)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>subseteq_guardsD</span><span> </span><span class="delimiter">=</span><span> </span><span>subseteq_guards_Skip</span><span> </span><span>subseteq_guards_Basic</span><span>
</span><span> </span><span>subseteq_guards_Spec</span><span> </span><span>subseteq_guards_Seq</span><span> </span><span>subseteq_guards_Cond</span><span> </span><span>subseteq_guards_While</span><span>
</span><span> </span><span>subseteq_guards_Call</span><span> </span><span>subseteq_guards_DynCom</span><span> </span><span>subseteq_guards_Guard</span><span>
</span><span> </span><span>subseteq_guards_Throw</span><span> </span><span>subseteq_guards_Catch</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_Guard&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;Guard f b c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> d &#10233; &#8707;f&#39; b&#39; c&#39;. d=Guard f&#39; b&#39; c&#39;&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>cases</span><span> </span><span>d</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>subseteq_guards_refl</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c &#8838;<span class="hidden">&#8681;</span><sub>g</sub> c&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>induct</span><span> </span><span>c</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* Antisymmetry and transitivity should hold as well&#8230; *)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span></pre>

</div>
</body>
</html>
