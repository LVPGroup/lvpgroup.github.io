<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<title>Theory HoareTotal (Isabelle2019: June 2019)</title>
<link media="all" rel="stylesheet" type="text/css" href="isabelle.css"/>
</head>

<body>
<div class="head"><h1>Theory HoareTotal</h1>

<span class="command">theory</span> <span class="name">HoareTotal</span><br/>
<span class="keyword">imports</span> <a href="HoareTotalProps.html"><span class="name">HoareTotalProps</span></a><br/>

</div>
<div class="source">
<pre class="source"><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*
    Author:      Norbert Schirmer
    Maintainer:  Norbert Schirmer, norbert.schirmer at web de
    License:     LGPL
*)</span></span></span></span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(*  Title:      HoareTotal.thy
    Author:     Norbert Schirmer, TU Muenchen

Copyright (C) 2004-2008 Norbert Schirmer 
Some rights reserved, TU Muenchen

This library is free software; you can redistribute it and/or modify
it under the terms of the GNU Lesser General Public License as
published by the Free Software Foundation; either version 2.1 of the
License, or (at your option) any later version.

This library is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU
Lesser General Public License for more details.

You should have received a copy of the GNU Lesser General Public
License along with this library; if not, write to the Free Software
Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA 02111-1307
USA
*)</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">section</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Derived Hoare Rules for Total Correctness *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">theory</span></span><span> </span><span>HoareTotal</span><span> </span><span class="keyword2"><span class="keyword">imports</span></span><span> </span><span>HoareTotalProps</span><span> </span><span class="keyword2"><span class="keyword">begin</span></span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conseq_no_aux</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P&#39; c Q&#39;,A&#39;;
    &#8704;s. s &#8712; P &#10230; (s&#8712;P&#39; &#8743; (Q&#39; &#8838; Q)&#8743; (A&#39; &#8838; A))&#10215;
  &#10233;
  &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseq</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. P&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. Q&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. A&#39;&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* If for example a specification for a &quot;procedure pointer&quot; parameter 
is in the precondition we can extract it with this rule *}</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conseq_exploit_pre</span><span class="delimiter">:</span><span>
</span><span>             </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#8704;s &#8712; P. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s} &#8745; P) c Q,A&#10215;
              &#10233;
              &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Conseq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarify</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{s} &#8745; P&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>conseq</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#8704;Z. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) c (Q&#39; Z),(A&#39; Z);
              &#8704;s. s &#8712; P &#10230; (&#8707; Z. s&#8712;P&#39; Z &#8743; (Q&#39; Z &#8838; Q)&#8743; (A&#39; Z &#8838; A))&#10215;
              &#10233;
              &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Conseq&#39;</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Lem</span><span class="delimiter">:</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#8704;Z. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) c (Q&#39; Z),(A&#39; Z);
            P &#8838; {s. &#8707; Z. s&#8712;P&#39; Z &#8743; (Q&#39; Z &#8838; Q) &#8743; (A&#39; Z &#8838; A)}&#10215;
              &#10233;
              &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (lem x c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>lem_def</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conseq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LemAnno</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>conseq</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;Z. s&#8712;P&#39; Z &#8743; 
                     (&#8704;t. t &#8712; Q&#39; Z &#10230; t &#8712; Q) &#8743; (&#8704;t. t &#8712; A&#39; Z &#10230; t &#8712; A)}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) c (Q&#39; Z),(A&#39; Z)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (lem x c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Lem</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>lem</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conseq</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>LemAnnoNoAbrupt</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>conseq</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838;  {s. &#8707;Z. s&#8712;P&#39; Z &#8743; (&#8704;t. t &#8712; Q&#39; Z &#10230; t &#8712; Q)}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>lem</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) c (Q&#39; Z),{}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (lem x c) Q,{}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Lem</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>lem</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>conseq</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TrivPost</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) c (Q&#39; Z),(A&#39; Z)
                 &#10233;
                 &#8704;Z. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) c UNIV,UNIV&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conseq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>TrivPostNoAbr</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) c (Q&#39; Z),{}
                 &#10233;
                 &#8704;Z. &#915;,&#920; &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) c UNIV,{}&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conseq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DynComConseq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;P&#39; Q&#39; A&#39;.  &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F <span class="hidden">&#8665;</span></sub>P&#39; (c s) Q&#39;,A&#39; &#8743; P &#8838; P&#39; &#8743; Q&#39; &#8838; Q &#8743; A&#39; &#8838; A}&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F <span class="hidden">&#8665;</span></sub>P DynCom c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>assms</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.DynCom</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Conseq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SpecAnno</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>consequence</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. (&#8707; Z. s&#8712;P&#39; Z &#8743; (Q&#39; Z &#8838; Q) &#8743; (A&#39; Z &#8838; A))}&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) (c Z) (Q&#39; Z),(A&#39; Z)&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy_constant</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. c Z = c undefined&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (specAnno P&#39; c Q&#39; A&#39;) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>spec</span><span> </span><span>bdy_constant</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) (c undefined) (Q&#39; Z),(A&#39; Z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>Z</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>Z</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>consequence</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>specAnno_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conseq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SpecAnno&#39;</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; {s.  &#8707; Z. s&#8712;P&#39; Z &#8743; 
            (&#8704;t. t &#8712; Q&#39; Z &#10230;  t &#8712; Q) &#8743; (&#8704;t. t &#8712; A&#39; Z &#10230; t &#8712;  A)};
   &#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) (c Z) (Q&#39; Z),(A&#39; Z);
   &#8704;Z. c Z = c undefined
  &#10215; &#10233;
    &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (specAnno P&#39; c Q&#39; A&#39;) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>only</span><span class="delimiter">:</span><span> </span><span>subset_iff</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>sym</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>SpecAnno</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>assumption</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SpecAnnoNoAbrupt</span><span class="delimiter">:</span><span> 
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; {s.  &#8707; Z. s&#8712;P&#39; Z &#8743; 
            (&#8704;t. t &#8712; Q&#39; Z &#10230;  t &#8712; Q)};
   &#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) (c Z) (Q&#39; Z),{};
   &#8704;Z. c Z = c undefined
  &#10215; &#10233;
    &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (specAnno P&#39; c Q&#39; (&#955;s. {})) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SpecAnno&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Skip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; Q &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Skip Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Skip</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conseqPre</span><span class="delimiter">]</span><span class="delimiter">,</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Basic</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. (f s) &#8712; Q} &#10233;  &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Basic f) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Basic</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conseqPre</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BasicCond</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; {s. (b s &#10230; f s&#8712;Q) &#8743; (&#172; b s &#10230; g s&#8712;Q)}&#10215; &#10233;
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Basic (&#955;s. if b s then f s else g s) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. (&#8704;t. (s,t) &#8712; r &#10230; t &#8712; Q) &#8743; (&#8707;t. (s,t) &#8712; r)} 
            &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Spec r) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Spec</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conseqPre</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SpecIf</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; {s. (b s &#10230; f s &#8712; Q) &#8743; (&#172; b s &#10230; g s &#8712; Q &#8743; h s &#8712; Q)}&#10215; &#10233;
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Spec (if_rel b f g h) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Spec</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>if_rel_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Seq</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c<span class="hidden">&#8681;</span><sub>1</sub> R,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Seq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>SeqSwap</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c2 Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c1 R,A&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Seq c1 c2 Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BSeq</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c<span class="hidden">&#8681;</span><sub>1</sub> R,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (bseq c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>bseq_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Seq</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cond</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. (s&#8712;b &#10230; s&#8712;P<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; (s&#8713;b &#10230; s&#8712;P<span class="hidden">&#8681;</span><sub>2</sub>)}&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>1</sub> Q,A&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P<span class="hidden">&#8681;</span><sub>2</sub> c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Cond</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conseqPre</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>deriv_c1</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. (s &#8712; b &#10230; s &#8712; P<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; (s &#8713; b &#10230; s &#8712; P<span class="hidden">&#8681;</span><sub>2</sub>)} &#8745; b) c<span class="hidden">&#8681;</span><sub>1</sub> Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">next</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>deriv_c2</span><span> 
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. (s &#8712; b &#10230; s &#8712; P<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; (s &#8713; b &#10230; s &#8712; P<span class="hidden">&#8681;</span><sub>2</sub>)} &#8745; - b) c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>wp</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CondSwap</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P1 c1 Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P2 c2 Q,A; 
    P &#8838; {s. (s&#8712;b &#10230; s&#8712;P1) &#8743; (s&#8713;b &#10230; s&#8712;P2)}&#10215;
   &#10233; 
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Cond b c1 c2) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Cond</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Cond&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; {s. (b &#8838; P1) &#8743; (- b &#8838; P2)};&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P1 c1 Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P2 c2 Q,A&#10215;
   &#10233; 
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Cond b c1 c2) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CondSwap</span><span class="delimiter">)</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CondInv</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; Q&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q &#8838; {s. (s&#8712;b &#10230; s&#8712;P<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; (s&#8713;b &#10230; s&#8712;P<span class="hidden">&#8681;</span><sub>2</sub>)}&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>1</sub> Q,A&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P<span class="hidden">&#8681;</span><sub>2</sub> c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wp</span><span> </span><span>inv</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. (s&#8712;b &#10230; s&#8712;P<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; (s&#8713;b &#10230; s&#8712;P<span class="hidden">&#8681;</span><sub>2</sub>)}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>Cond</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>deriv_c1</span><span> </span><span>deriv_c2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CondInv&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wp</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; I&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>inv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8838; {s. (s&#8712;b &#10230; s&#8712;P<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; (s&#8713;b &#10230; s&#8712;P<span class="hidden">&#8681;</span><sub>2</sub>)}&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wp&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8838; Q&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_c1</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>1</sub> I,A&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_c2</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P<span class="hidden">&#8681;</span><sub>2</sub> c<span class="hidden">&#8681;</span><sub>2</sub> I,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>CondInv</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>wp</span><span> </span><span>inv</span><span> </span><span>deriv_c1</span><span> </span><span>deriv_c2</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Cond b c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub>) I,A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conseqPost</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span> </span><span>wp&#39;</span><span> </span><span>subset_refl</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>switchNil</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; Q &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F <span class="hidden">&#8665;</span></sub>P (switch v []) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Skip</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>switchCons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; {s. (v s &#8712; V &#10230; s &#8712; P<span class="hidden">&#8681;</span><sub>1</sub>) &#8743; (v s &#8713; V &#10230; s &#8712; P<span class="hidden">&#8681;</span><sub>2</sub>)}; 
        &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F <span class="hidden">&#8665;</span></sub>P<span class="hidden">&#8681;</span><sub>1</sub> c Q,A;
        &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F <span class="hidden">&#8665;</span></sub>P<span class="hidden">&#8681;</span><sub>2</sub> (switch v vs) Q,A&#10215;
&#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F <span class="hidden">&#8665;</span></sub>P (switch v ((V,c)#vs)) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>Cond</span><span class="delimiter">)</span><span>
</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Guard</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; g &#8745; R; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Guard f g c Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.Guard</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conseqPre</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>R</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuardSwap</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A; P &#8838; g &#8745; R&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Guard f g c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Guard</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Guarantee</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; {s. s &#8712; g &#10230; s &#8712; R}; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A; f &#8712; F&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Guard f g c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Guarantee</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conseqPre</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span>_</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;{s. s &#8712; g &#10230; s &#8712; R}&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span>assumption</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuaranteeSwap</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A; P &#8838; {s. s &#8712; g &#10230; s &#8712; R}; f &#8712; F&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Guard f g c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Guarantee</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuardStrip</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; R; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A; f &#8712; F&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Guard f g c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Guarantee</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conseqPre</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuardStripSwap</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A; P &#8838; R; f &#8712; F&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Guard f g c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>GuardStrip</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuaranteeStrip</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; R; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A; f &#8712; F&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (guaranteeStrip f g c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>GuardStrip</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuaranteeStripSwap</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A; P &#8838; R; f &#8712; F&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (guaranteeStrip f g c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>GuardStrip</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuaranteeAsGuard</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;P &#8838; g &#8745; R; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P guaranteeStrip f g c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Guard</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuaranteeAsGuardSwap</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c Q,A; P &#8838; g &#8745; R&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P guaranteeStrip f g c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>GuaranteeAsGuard</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuardsNil</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A &#10233; 
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (guards [] c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuardsCons</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Guard f g (guards gs c) Q,A &#10233; 
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (guards ((f,g)#gs) c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>GuardsConsGuaranteeStrip</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P guaranteeStrip f g (guards gs c) Q,A &#10233; 
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (guards (guaranteeStripPair f g#gs) c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>guaranteeStripPair_def</span><span> </span><span>guaranteeStrip_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>While</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; I&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_body</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I &#8745; b) c ({t. (t, &#963;) &#8712; V} &#8745; I),A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8745; -b &#8838; Q&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf V&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnno  b I V c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>wf</span><span> </span><span>deriv_body</span><span> </span><span>P_I</span><span> </span><span>I_Q</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>whileAnno_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>conseqPrePost</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>HoareTotalDef.While</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WhileInvPost</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; I&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>termi_body</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/UNIV<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I &#8745; b) c ({t. (t, &#963;) &#8712; V} &#8745; P),A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_body</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (I &#8745; b) c I,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8745; -b &#8838; Q&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf V&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnno  b I V c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I &#8745; b) c ({t. (t, &#963;) &#8712; V} &#8745; I),A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>&#963;</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>hoare_sound</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv_body</span><span class="delimiter">]</span><span> </span><span>hoaret_sound</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>termi_body</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>of</span><span> </span><span>&#963;</span><span class="delimiter">]</span><span class="delimiter">]</span><span>
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8872;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I &#8745; b) c ({t. (t, &#963;) &#8712; V} &#8745; I),A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>fastforce</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>cvalidt_def</span><span> </span><span>validt_def</span><span> </span><span>cvalid_def</span><span> </span><span>valid_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I &#8745; b) c ({t. (t, &#963;) &#8712; V} &#8745; I),A&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret_complete&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>While</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>P_I</span><span> </span><span>this</span><span> </span><span>I_Q</span><span> </span><span>wf</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="comment"><span class="delete"><span class="delete"><span class="delete"><span class="delete">(* *)</span></span></span></span></span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P &#8745; b) c Q,A &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P &#8745; b) (Seq c (Guard f Q Skip)) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">oops</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* @{term &quot;J&quot;} will be instantiated by tactic with @{term &quot;gs&#39; &#8745; I&quot;} for
  those guards that are not stripped.*}</span></span></span></span></span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WhileAnnoG</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (guards gs 
                    (whileAnno  b J V (Seq c (guards gs Skip)))) Q,A 
        &#10233; 
        &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnnoG gs b I V c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span> </span><span>whileAnno_def</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* This form stems from @{term &quot;strip_guards F (whileAnnoG gs b I V c)&quot;} *}</span></span></span></span></span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WhileNoGuard&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>P_I</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; I&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_body</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I &#8745; b) c ({t. (t, &#963;) &#8712; V} &#8745; I),A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>I_Q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;I &#8745; -b &#8838; Q&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf V&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnno b I V (Seq c Skip)) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>While</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>P_I</span><span> </span><span>_</span><span> </span><span>I_Q</span><span> </span><span>wf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Seq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>deriv_body</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Skip</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WhileAnnoFix</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>consequence</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. (&#8707; Z. s&#8712;I Z &#8743; (I Z &#8745; -b &#8838; Q)) }&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z &#963;. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I Z &#8745; b) (c Z) ({t. (t, &#963;) &#8712; V Z} &#8745; I Z),A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy_constant</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. c Z = c undefined&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. wf (V Z)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnnoFix b I V c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>bdy</span><span> </span><span>bdy_constant</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>bdy&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8896;Z. &#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I Z &#8745; b) (c undefined) 
               ({t. (t, &#963;) &#8712; V Z} &#8745; I Z),A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>Z</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>Z</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>allE</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (I Z) (whileAnnoFix b I V c) (I Z &#8745; -b),A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>rule</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>whileAnnoFix_def</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.While</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>wf</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bdy&#39;</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseq</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consequence</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WhileAnnoFix&#39;</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>consequence</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. (&#8707; Z. s&#8712;I Z &#8743; 
                               (&#8704;t. t &#8712; I Z &#8745; -b &#10230; t &#8712; Q)) }&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z &#963;. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; I Z &#8745; b) (c Z) ({t. (t, &#963;) &#8712; V Z} &#8745; I Z),A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy_constant</span><span class="delimiter">:</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. c Z = c undefined&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. wf (V Z)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnnoFix b I V c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>WhileAnnoFix</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>bdy</span><span> </span><span>bdy_constant</span><span> </span><span>wf</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>consequence</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>WhileAnnoGFix</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>whileAnnoFix</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (guards gs 
                (whileAnnoFix  b J V (&#955;Z. (Seq (c Z) (guards gs Skip))))) Q,A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnnoGFix gs b I V c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>whileAnnoFix</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoGFix_def</span><span> </span><span>whileAnnoFix_def</span><span> </span><span>while_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Bind</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. s &#8712; P&#39; s}&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; s) (c (e s)) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (bind e c) Q,A&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseq</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. {s. s=Z &#8743; s &#8712; P&#39; Z}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. A&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>bind_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.DynCom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>c</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>blast</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adapt</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Block</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. init s &#8712; P&#39; s}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; s) bdy {t. return s t &#8712; R s t},{t. return s t &#8712; A}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (block init bdy return c) Q,A&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseq</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. {s. s=Z &#8743; init s &#8712; P&#39; Z}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. A&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adapt</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.DynCom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{t. return Z t &#8712; R Z t}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SeqSwap</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule_tac</span><span>  </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;. {t. t=Z&#39; &#8743; return Z t &#8712; R Z t}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;. Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;. A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conseq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.DynCom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSwap</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>c</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{t. return Z t &#8712; A}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HoareTotalDef.Catch</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{i. i &#8712; P&#39; Z}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Seq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>bdy</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSwap</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Throw</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BlockSwap</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; s) bdy {t. return s t &#8712; R s t},{t. return s t &#8712; A}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. init s &#8712; P&#39; s}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (block init bdy return c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adapt</span><span> </span><span>bdy</span><span> </span><span>c</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Block</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>BlockSpec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;Z. init s &#8712; P&#39; Z &#8743; 
                             (&#8704;t. t &#8712; Q&#39; Z &#10230; return s t &#8712; R s t) &#8743;
                             (&#8704;t. t &#8712; A&#39; Z &#10230; return s t &#8712; A)}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) bdy (Q&#39; Z),(A&#39; Z)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (block init bdy return c) Q,A&quot;</span></span></span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseq</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. {s. init s &#8712; P&#39; Z &#8743; 
                             (&#8704;t. t &#8712; Q&#39; Z &#10230; return s t &#8712; R s t) &#8743;
                             (&#8704;t. t &#8712; A&#39; Z &#10230; return s t &#8712; A)}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. A&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adapt</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.DynCom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{t. return s t &#8712; R s t}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>SeqSwap</span><span> </span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule_tac</span><span>  </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;. {t. t=Z&#39; &#8743; return s t &#8712; R s t}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;. Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;. A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conseq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.DynCom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSwap</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>c</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{t. return s t &#8712; A}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>HoareTotalDef.Catch</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{i. i &#8712; P&#39; Z}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Seq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseq</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>bdy</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSwap</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Throw</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>Throw</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; A &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Throw Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Throw</span><span> </span><span class="delimiter">[</span><span>THEN</span><span> </span><span>conseqPre</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>Catch</span><span> </span><span class="delimiter">=</span><span> </span><span>hoaret.Catch</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CatchSwap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c<span class="hidden">&#8681;</span><sub>2</sub> Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c<span class="hidden">&#8681;</span><sub>1</sub> Q,R&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Catch c<span class="hidden">&#8681;</span><sub>1</sub> c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Catch</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>raise</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. f s &#8712; A} &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P raise f Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>raise_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Seq</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Throw</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_refl</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>condCatch</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c<span class="hidden">&#8681;</span><sub>1</sub> Q,((b &#8745; R) &#8746; (-b &#8745; A));&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&#10215; 
                  &#10233;  &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P condCatch c<span class="hidden">&#8681;</span><sub>1</sub> b c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>condCatch_def</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Catch</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>assumption</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CondSwap</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>assumption</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.Throw</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>condCatchSwap</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> R c<span class="hidden">&#8681;</span><sub>2</sub> Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c<span class="hidden">&#8681;</span><sub>1</sub> Q,((b &#8745; R) &#8746; (-b &#8745; A))&#10215; 
                     &#10233;  &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P condCatch c<span class="hidden">&#8681;</span><sub>1</sub> b c<span class="hidden">&#8681;</span><sub>2</sub> Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>condCatch</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcSpec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;Z. init s &#8712; P&#39; Z &#8743; 
                             (&#8704;t. t &#8712; Q&#39; Z &#10230; return s t &#8712; R s t) &#8743;
                             (&#8704;t. t &#8712; A&#39; Z &#10230; return s t &#8712; A)}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) Call p (Q&#39; Z),(A&#39; Z)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adapt</span><span> </span><span>c</span><span> </span><span>p</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>call_def</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>BlockSpec</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcSpec&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;Z. init s &#8712; P&#39; Z &#8743; 
                             (&#8704;t &#8712; Q&#39; Z. return s t &#8712; R s t) &#8743;
                             (&#8704;t &#8712; A&#39; Z. return s t &#8712; A)}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) Call p (Q&#39; Z),(A&#39; Z)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcSpec</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>c</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>adapt</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>drule</span><span> </span><span class="delimiter">(</span><span>1</span><span class="delimiter">)</span><span> </span><span>subsetD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>clarsimp</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>x</span><span class="delimiter">=</span><span>Z</span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>exI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcSpecNoAbrupt</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;Z. init s &#8712; P&#39; Z &#8743; 
                             (&#8704;t. t &#8712; Q&#39; Z &#10230; return s t &#8712; R s t)}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) Call p (Q&#39; Z),{}&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcSpec</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>c</span><span> </span><span>p</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adapt</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>FCall</span><span class="delimiter">:</span><span>  
</span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return (&#955;s t. c (result t))) Q,A
&#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (fcall init p return result c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>fcall_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcRec</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_bodies</span><span class="delimiter">:</span><span>  
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p&#8712;Procs. 
    &#8704;&#963; Z. &#915;,&#920;&#8746;(&#8899;q&#8712;Procs. &#8899;Z. 
       {(P q Z &#8745; {s. ((s,q), &#963;,p) &#8712; r},q,Q q Z,A q Z)})
        &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; P p Z) (the (&#915; p)) (Q p Z),(A p Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Procs_defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Procs &#8838; dom &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p&#8712;Procs. &#8704;Z.  
  &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub>(P p Z) Call p (Q p Z),(A p Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>intro</span><span> </span><span>strip</span><span class="delimiter">)</span><span>
</span><span>     </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.CallRec&#39;</span><span> 
</span><span>     </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span>  </span><span>Procs_defined</span><span> </span><span>wf</span><span> </span><span>deriv_bodies</span><span class="delimiter">]</span><span class="delimiter">,</span><span>
</span><span>     </span><span>simp_all</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcRec&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ctxt</span><span class="delimiter">:</span><span> 
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#920;&#39;=(&#955;&#963; p. &#920;&#8746;(&#8899;q&#8712;Procs. 
                   &#8899;Z. {(P q Z &#8745; {s. ((s,q), &#963;,p) &#8712; r},q,Q q Z,A q Z)}))&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_bodies</span><span class="delimiter">:</span><span>   
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p&#8712;Procs. 
    &#8704;&#963; Z. &#915;,&#920;&#39; &#963; p&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; P p Z) (the (&#915; p)) (Q p Z),(A p Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Procs_defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Procs &#8838; dom &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p&#8712;Procs. &#8704;Z.  &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub>(P p Z) Call p (Q p Z),(A p Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>ctxt</span><span> </span><span>deriv_bodies</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>erule</span><span> </span><span>ProcRec</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>wf</span><span> </span><span>Procs_defined</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span> 
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcRecList</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_bodies</span><span class="delimiter">:</span><span>  
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p&#8712;set Procs. 
    &#8704;&#963; Z. &#915;,&#920;&#8746;(&#8899;q&#8712;set Procs. &#8899;Z. 
       {(P q Z &#8745; {s. ((s,q), &#963;,p) &#8712; r},q,Q q Z,A q Z)})
        &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; P p Z) (the (&#915; p)) (Q p Z),(A p Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>dist</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;distinct Procs&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>Procs_defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;set Procs &#8838; dom &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p&#8712;set Procs. &#8704;Z.  
  &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub>(P p Z) Call p (Q p Z),(A p Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>deriv_bodies</span><span> </span><span>wf</span><span> </span><span>Procs_defined</span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcRec</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span>  </span><span>ProcRecSpecs</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#8704;&#963;. &#8704;(P,p,Q,A) &#8712; Specs. 
     &#915;,&#920;&#8746; ((&#955;(P,q,Q,A). (P &#8745; {s. ((s,q),(&#963;,p)) &#8712; r},q,Q,A)) ` Specs)
      &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; P) (the (&#915; p)) Q,A;
    wf r;
    &#8704;(P,p,Q,A) &#8712; Specs. p &#8712; dom &#915;&#10215;
  &#10233; &#8704;(P,p,Q,A) &#8712; Specs. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Call p) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ballI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>case_tac</span><span> </span><span>x</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>x</span><span> </span><span>P</span><span> </span><span>p</span><span> </span><span>Q</span><span> </span><span>A</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret.CallRec</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcRec1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_body</span><span class="delimiter">:</span><span>  
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963; Z. &#915;,&#920;&#8746;(&#8899;Z. {(P Z &#8745; {s. ((s,p), &#963;,p) &#8712; r},p,Q Z,A Z)})
           &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; P Z) (the (&#915; p)) (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>wf</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;wf r&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p_defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; dom &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) Call p (Q Z),(A Z)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>deriv_body</span><span> </span><span>wf</span><span> </span><span>p_defined</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;p&#8712;{p}. &#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) Call p (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span> 
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcRec</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span>  </span><span>A</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;p. A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;p. P&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;p. Q&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp_all</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcNoRec1</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_body</span><span class="delimiter">:</span><span>  
</span><span>   </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) (the (&#915; p)) (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p_defined</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p &#8712; dom &#915;&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) Call p (Q Z),(A Z)&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963; Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; P Z) (the (&#915; p)) (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>conseqPre</span><span> </span><span>deriv_body</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>p_defined</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963; Z. &#915;,&#920;&#8746;(&#8899;Z. {(P Z &#8745; {s. ((s,p), &#963;,p) &#8712; {}},
                         p,Q Z,A Z)})
             &#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({&#963;} &#8745; P Z) (the (&#915; p)) (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>hoaret_augment_context</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span>  
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcRec1</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>p_defined</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcBody</span><span class="delimiter">:</span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>WP</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; P&#39;&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_body</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P&#39; body Q,A&quot;</span></span></span><span> 
</span><span> </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>body</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; p = Some body&quot;</span></span></span><span>
</span><span> </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Call p Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>_</span><span> </span><span>WP</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcNoRec1</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. P&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. A&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>insert</span><span> </span><span>body</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>hoaret_augment_context</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv_body</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>fastforce</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CallBody</span><span class="delimiter">:</span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. init s &#8712; P&#39; s}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>bdy</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; s) body {t. return s t &#8712; R s t},{t. return s t &#8712; A}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>body</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915; p = Some body&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>call_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Block</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>adapt</span><span> </span><span>_</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcBody</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>&#915;</span><span class="delimiter">=</span><span>&#915;</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>bdy</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span> </span><span>body</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ProcModifyReturn</span><span> </span><span class="delimiter">=</span><span> </span><span>HoareTotalProps.ProcModifyReturn</span><span>
</span><span class="keyword1"><span class="command">lemmas</span></span><span> </span><span>ProcModifyReturnSameFaults</span><span> </span><span class="delimiter">=</span><span> </span><span>HoareTotalProps.ProcModifyReturnSameFaults</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcModifyReturnNoAbr</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>result_conform</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; Modif (init s) &#10230; (return&#39; s t) = (return s t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>modifies_spec</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/UNIV<span class="hidden">&#8665;</span></sub> {&#963;} Call p (Modif &#963;),{}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcModifyReturn</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>spec</span><span> </span><span>result_conform</span><span> </span><span>_</span><span> </span><span>modifies_spec</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcModifyReturnNoAbrSameFaults</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>result_conform</span><span class="delimiter">:</span><span>
</span><span>      </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; Modif (init s) &#10230; (return&#39; s t) = (return s t)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>modifies_spec</span><span class="delimiter">:</span><span>  
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {&#963;} Call p (Modif &#963;),{}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (call init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcModifyReturnSameFaults</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>spec</span><span> </span><span>result_conform</span><span> </span><span>_</span><span> </span><span>modifies_spec</span><span class="delimiter">]</span><span class="delimiter">)</span><span> </span><span>simp</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DynProc</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;Z. init s &#8712; P&#39; s Z &#8743;
                          (&#8704;t. t &#8712; Q&#39; s Z &#10230;  return s t &#8712; R s t) &#8743;
                          (&#8704;t. t &#8712; A&#39; s Z &#10230; return s t &#8712; A)}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712; P. &#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; s Z) Call (p s) (Q&#39; s Z),(A&#39; s Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P dynCall init p return c Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseq</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. {s. s=Z &#8743; s &#8712; P}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z. A&quot;</span></span></span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>adapt</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>blast</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>unfold</span><span> </span><span>dynCall_def</span><span> </span><span>call_def</span><span> </span><span>block_def</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.DynCom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.DynCom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>frule</span><span> </span><span>in_mono</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>adapt</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rename_tac</span><span> </span><span>Z&#39;</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Q&#39; Z Z&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Seq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CatchSwap</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSwap</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Throw</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>subset_refl</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>R</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{i. i &#8712; P&#39; Z Z&#39;}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>Seq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule_tac</span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;Q&#39; Z Z&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;A&#39; Z Z&#39;&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conseqPost</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">using</span></span><span> </span><span>p</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>    </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>   </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule_tac</span><span>  </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;&#39;. {t. t=Z&#39;&#39; &#8743; return Z t &#8712; R Z t}&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> 
</span><span>          </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;&#39;. Q&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;Z&#39;&#39;. A&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">in</span></span><span> </span><span>conseq</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">prefer</span></span></span></span><span> </span><span>2</span><span> </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>allI</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoareTotalDef.DynCom</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>SeqSwap</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>rule</span><span> </span><span>c</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Basic</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DynProc&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;Z. init s &#8712; P&#39; s Z &#8743;
                          (&#8704;t &#8712; Q&#39; s Z. return s t &#8712; R s t) &#8743;
                          (&#8704;t &#8712; A&#39; s Z. return s t &#8712; A)}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>p</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712; P. &#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; s Z) Call (p s) (Q&#39; s Z),(A&#39; s Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P dynCall init p return c Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adapt</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. &#8707;Z. init s &#8712; P&#39; s Z &#8743;
                          (&#8704;t. t &#8712; Q&#39; s Z &#10230;  return s t &#8712; R s t) &#8743;
                          (&#8704;t. t &#8712; A&#39; s Z &#10230; return s t &#8712; A)}&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>c</span><span> </span><span>p</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>DynProc</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DynProcStaticSpec</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. s &#8712; S &#8743; (&#8707;Z. init s &#8712; P&#39; Z  &#8743; 
                            (&#8704;&#964;. &#964; &#8712; Q&#39; Z &#10230; return s &#964; &#8712; R s &#964;) &#8743;
                            (&#8704;&#964;. &#964; &#8712; A&#39; Z &#10230; return s &#964; &#8712; A))}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s&#8712;S. &#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) Call (p s) (Q&#39; Z),(A&#39; Z)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>adapt</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>P_S</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; S&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P &#8745; S) (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>DynProc</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>P&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;s Z. P&#39; Z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>Q&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;s Z. Q&#39; Z&quot;</span></span></span><span> 
</span><span>                         </span><span class="keyword2"><span class="keyword">and</span></span><span> </span><span>A&#39;</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;&#955;s Z. A&#39; Z&quot;</span></span></span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>_</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span class="delimiter">(</span><span>frule</span><span> </span><span>in_mono</span><span> </span><span class="delimiter">[</span><span>rule_format</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>adapt</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span>  </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>clarsimp</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>P_S</span><span class="delimiter">,</span><span>blast</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DynProcProcPar</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. p s = q &#8743; (&#8707;Z. init s &#8712; P&#39; Z  &#8743; 
                            (&#8704;&#964;. &#964; &#8712; Q&#39; Z &#10230; return s &#964; &#8712; R s &#964;) &#8743;
                            (&#8704;&#964;. &#964; &#8712; A&#39; Z &#10230; return s &#964; &#8712; A))}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) Call q (Q&#39; Z),(A&#39; Z)&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>DynProcStaticSpec</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{s. p s = q}&quot;</span></span></span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>adapt</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>spec</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DynProcProcParNoAbrupt</span><span class="delimiter">:</span><span> 
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>adapt</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. p s = q &#8743; (&#8707;Z. init s &#8712; P&#39; Z  &#8743; 
                            (&#8704;&#964;. &#964; &#8712; Q&#39; Z &#10230; return s &#964; &#8712; R s &#964;))}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (R s t) (c s t) Q,A&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>spec</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P&#39; Z) Call q (Q&#39; Z),{}&quot;</span></span></span><span>
</span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>  
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. p s = q &#8743; (&#8707; Z. init s &#8712; P&#39; Z &#8743; 
                      (&#8704;t. t &#8712; Q&#39; Z &#10230; return s t &#8712; R s t) &#8743;
                      (&#8704;t. t &#8712; {} &#10230; return s t &#8712; A))}&quot;</span></span></span><span>
</span><span>    </span><span class="delimiter">(</span><span class="keyword2"><span class="keyword">is</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; ?P&#39;&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">proof</span></span><span> 
</span><span>    </span><span class="keyword3"><span class="command">fix</span></span><span> </span><span>s</span><span>
</span><span>    </span><span class="keyword3"><span class="command">assume</span></span><span> </span><span>P</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;P&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>adapt</span><span> </span><span class="keyword3"><span class="command">obtain</span></span><span> </span><span>Z</span><span> </span><span class="keyword2"><span class="keyword">where</span></span><span>
</span><span>      </span><span>Pre</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;p s = q &#8743; init s &#8712; P&#39; Z&quot;</span></span></span><span> </span><span class="keyword2"><span class="keyword">and</span></span><span>
</span><span>      </span><span>adapt_Norm</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#964;. &#964; &#8712; Q&#39; Z &#10230; return s &#964; &#8712; R s &#964;&quot;</span></span></span><span> 
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>    </span><span class="keyword1"><span class="command">from</span></span><span>  </span><span>adapt_Norm</span><span> 
</span><span>    </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;t. t &#8712; Q&#39; Z &#10230; return s t &#8712; R s t&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>    </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;s&#8712;?P&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="keyword1"><span class="command">using</span></span><span> </span><span>Pre</span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">note</span></span><span> </span><span>P</span><span> </span><span class="delimiter">=</span><span> </span><span>this</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>-</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>DynProcStaticSpec</span><span> </span><span class="delimiter">[</span><span class="keyword2"><span class="keyword">where</span></span><span> </span><span>S</span><span class="delimiter">=</span><span class="string"><span class="delete"><span class="delete">&quot;{s. p s = q}&quot;</span></span></span><span class="delimiter">,</span><span>simplified</span><span class="delimiter">,</span><span> </span><span>OF</span><span> </span><span>P</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>spec</span><span class="delimiter">)</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>    </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>DynProcModifyReturnNoAbr</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>to_prove</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ret_nrm_modif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (Modif (init s)) 
                            &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>modif_clause</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s &#8712; P. &#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/UNIV<span class="hidden">&#8665;</span></sub> {&#963;} Call (p s)  (Modif &#963;),{}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ret_nrm_modif</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t  &#8712; (Modif (init s)) 
        &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ret_nrm_modif&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (Modif (init s)) 
                      &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ret_abr_modif&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; {} 
                        &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>to_prove</span><span> </span><span>ret_nrm_modif&#39;</span><span> </span><span>ret_abr_modif&#39;</span><span> </span><span>modif_clause</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dynProcModifyReturn</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcDynModifyReturnNoAbrSameFaults</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>to_prove</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ret_nrm_modif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (Modif (init s)) 
                            &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>modif_clause</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s &#8712; P. &#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {&#963;} (Call (p s)) (Modif &#963;),{}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>ret_nrm_modif</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t  &#8712; (Modif (init s)) 
        &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>iprover</span><span>
</span><span>  </span><span class="keyword1"><span class="command">then</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ret_nrm_modif&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (Modif (init s)) 
                      &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>ret_abr_modif&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; {} 
                        &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>to_prove</span><span> </span><span>ret_nrm_modif&#39;</span><span> </span><span>ret_abr_modif&#39;</span><span> </span><span>modif_clause</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dynProcModifyReturnSameFaults</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcProcParModifyReturn</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. p s = q} &#8745; P&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="comment">&#8213; &#8249;@{thm[source] DynProcProcPar} introduces the same constraint as first conjunction in 
         @{term P&#39;}, so the vcg can simplify it. &#8250;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>to_prove</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P&#39; (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ret_nrm_modif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (Modif (init s)) 
                            &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ret_abr_modif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (ModifAbr (init s)) 
                            &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>modif_clause</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/UNIV<span class="hidden">&#8665;</span></sub> {&#963;} (Call q) (Modif &#963;),(ModifAbr &#963;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>to_prove</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. p s = q} &#8745; P&#39;) (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>ret_nrm_modif</span><span> 
</span><span>       </span><span>ret_abr_modif</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. p s = q} &#8745; P&#39;) (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dynProcModifyReturn</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>modif_clause</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>q</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcProcParModifyReturnSameFaults</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. p s = q} &#8745; P&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="comment">&#8213; &#8249;@{thm[source] DynProcProcPar} introduces the same constraint as first conjunction in 
         @{term P&#39;}, so the vcg can simplify it.&#8250;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>to_prove</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P&#39; (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ret_nrm_modif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (Modif (init s)) 
                            &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ret_abr_modif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (ModifAbr (init s)) 
                            &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>modif_clause</span><span class="delimiter">:</span><span> 
</span><span>          </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {&#963;} Call q (Modif &#963;),(ModifAbr &#963;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>to_prove</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. p s = q} &#8745; P&#39;) (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>ret_nrm_modif</span><span> 
</span><span>       </span><span>ret_abr_modif</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. p s = q} &#8745; P&#39;) (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>dynProcModifyReturnSameFaults</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>modif_clause</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>q</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcProcParModifyReturnNoAbr</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. p s = q} &#8745; P&#39;&quot;</span></span></span><span>
</span><span>   </span><span class="comment">&#8213; &#8249;@{thm[source] DynProcProcParNoAbrupt} introduces the same constraint as 
      first conjunction in @{term P&#39;}, so the vcg can simplify it.&#8250;</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>to_prove</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P&#39; (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ret_nrm_modif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (Modif (init s)) 
                            &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>modif_clause</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/UNIV<span class="hidden">&#8665;</span></sub> {&#963;} (Call q) (Modif &#963;),{}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>to_prove</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. p s = q} &#8745; P&#39;) (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>ret_nrm_modif</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. p s = q} &#8745; P&#39;) (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>DynProcModifyReturnNoAbr</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>modif_clause</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>q</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>ProcProcParModifyReturnNoAbrSameFaults</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>q</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P &#8838; {s. p s = q} &#8745; P&#39;&quot;</span></span></span><span>
</span><span>      </span><span class="comment">&#8213; &#8249;@{thm[source] DynProcProcParNoAbrupt} introduces the same constraint as 
      first conjunction in @{term P&#39;}, so the vcg can simplify it.&#8250;</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>to_prove</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P&#39; (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>ret_nrm_modif</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;s t. t &#8712; (Modif (init s)) 
                            &#10230; return&#39; s t = return s t&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>modif_clause</span><span class="delimiter">:</span><span> 
</span><span>            </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;&#963;. &#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {&#963;} (Call q) (Modif &#963;),{}&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>to_prove</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> 
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. p s = q} &#8745; P&#39;) (dynCall init p return&#39; c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span>blast</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>ret_nrm_modif</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> ({s. p s = q} &#8745; P&#39;) (dynCall init p return c) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>ProcDynModifyReturnNoAbrSameFaults</span><span class="delimiter">)</span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>modif_clause</span><span class="delimiter">,</span><span>auto</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>this</span><span> </span><span>q</span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> 
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>MergeGuards_iff</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P merge_guards c Q,A = &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>MergeGuardsI</span><span> </span><span>MergeGuardsD</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CombineStrip&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c&#39; Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_strip_triv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,{}&#8866;<span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P c&#39;&#39; UNIV,UNIV&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c&#39;&#39;= mark_guards False (strip_guards (-F) c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = merge_guards (mark_guards False c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P c Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>deriv_strip_triv</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span>deriv_strip</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P c&#39;&#39; UNIV,UNIV&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>auto</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>hoare_augment_context</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>deriv_strip</span><span> </span><span class="delimiter">[</span><span>simplified</span><span> </span><span>c&#39;&#39;</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P (strip_guards (- F) c&#39;) UNIV,UNIV&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>HoarePartialProps.MarkGuardsD</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">with</span></span><span> </span><span>deriv</span><span> 
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P c&#39; Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CombineStrip</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P mark_guards False c&#39; Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>MarkGuardsI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P merge_guards (mark_guards False c&#39;) Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>MergeGuardsI</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command">hence</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P merge_guards c Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>c</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword3"><span class="command">thus</span></span><span> </span><span class="var">?thesis</span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>MergeGuardsD</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CombineStrip&#39;&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/{True}<span class="hidden">&#8665;</span></sub> P c&#39; Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_strip_triv</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,{}&#8866;<span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P c&#39;&#39; UNIV,UNIV&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c&#39;&#39;</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;c&#39;&#39;= mark_guards False (strip_guards ({False}) c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>c</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;merge_guards c = merge_guards (mark_guards False c&#39;)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> P c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>CombineStrip&#39;</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv</span><span> </span><span>deriv_strip_triv</span><span> </span><span>_</span><span> </span><span>c</span><span class="delimiter">]</span><span class="delimiter">)</span><span> 
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>insert</span><span> </span><span>c&#39;&#39;</span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span class="delimiter">(</span><span>subgoal_tac</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;- {True} = {False}&quot;</span></span></span><span class="delimiter">)</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span><span> </span><span>auto</span><span>
</span><span>  </span><span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>AsmUN</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8899;Z. {(P Z, p, Q Z,A Z)}) &#8838; &#920; 
  &#10233; 
  &#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) (Call p) (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>hoaret.Asm</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>hoaret_to_hoarep&#39;</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#8704;Z. &#915;,{}&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) p (Q Z),(A Z) &#10233; &#8704;Z. &#915;,{}&#8866;<span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) p (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>total_to_partial</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_context&#39;</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#920; &#8838; &#920;&#39;; &#8704;Z. &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z)  p (Q Z),(A Z)&#10215; 
   &#10233; &#8704;Z. &#915;,&#920;&#39;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) p (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>iprover</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>hoaret_augment_context</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_emptyFaults</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#8704;Z. &#915;,{}&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/{}<span class="hidden">&#8665;</span></sub> (P Z) p (Q Z),(A Z)&#10215; &#10233; 
    &#8704;Z. &#915;,{}&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) p (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>augment_Faults</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>augment_FaultsUNIV</span><span class="delimiter">:</span><span>
</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#8704;Z. &#915;,{}&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P Z) p (Q Z),(A Z)&#10215; &#10233; 
    &#8704;Z. &#915;,{}&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/UNIV<span class="hidden">&#8665;</span></sub> (P Z) p (Q Z),(A Z)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>blast</span><span> </span><span>intro</span><span class="delimiter">:</span><span> </span><span>augment_Faults</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PostConjI</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c R,B&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c (Q &#8745; R),(A &#8745; B)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>PostConjI</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PostConjI&#39;</span><span> </span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c R,B&#10215; 
  &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c (Q &#8745; R),(A &#8745; B)&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>PostConjI</span><span class="delimiter">)</span><span> </span><span>iprover</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>PostConjE</span><span> </span><span class="delimiter">[</span><span>consumes</span><span> </span><span>1</span><span class="delimiter">]</span><span class="delimiter">:</span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>conj</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c (Q &#8745; R),(A &#8745; B)&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>E</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c R,B&#10215; &#10233; S&quot;</span></span></span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conj</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPost</span><span class="delimiter">)</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">moreover</span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>conj</span><span> </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c R,B&quot;</span></span></span><span> </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPost</span><span class="delimiter">)</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>  </span><span class="keyword1"><span class="command">ultimately</span></span><span> </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;S&quot;</span></span></span><span> 
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>E</span><span class="delimiter">)</span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">subsubsection</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{* Rules for Single-Step Proof \label{sec:hoare-isar} *}</span></span></span></span></span><span>
</span><span>
</span><span class="keyword1"><span class="command">text</span></span><span> </span><span class="verbatim"><span class="delete"><span class="delete"><span class="delete"><span class="delete">{*
 We are now ready to introduce a set of Hoare rules to be used in
 single-step structured proofs in Isabelle/Isar.  

 \medskip Assertions of Hoare Logic may be manipulated in
 calculational proofs, with the inclusion expressed in terms of sets
 or predicates.  Reversed order is supported as well.
*}</span></span></span></span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annotateI</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P anno Q,A; c = anno&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annotate_normI</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>deriv_anno</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub>P anno Q,A&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">assumes</span></span><span> </span><span>norm_eq</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;normalize c = normalize anno&quot;</span></span></span><span> 
</span><span>  </span><span class="keyword2"><span class="keyword">shows</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub>P c Q,A&quot;</span></span></span><span>
</span><span class="keyword1"><span class="command">proof</span></span><span> </span><span>-</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>HoareTotalProps.NormalizeI</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>deriv_anno</span><span class="delimiter">]</span><span> </span><span>norm_eq</span><span>
</span><span>  </span><span class="keyword1"><span class="command">have</span></span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F <span class="hidden">&#8665;</span></sub>P normalize c Q,A&quot;</span></span></span><span>
</span><span>    </span><span class="keyword1"><span class="command">by</span></span><span> </span><span>simp</span><span>
</span><span>  </span><span class="keyword1"><span class="command">from</span></span><span> </span><span>NormalizeD</span><span> </span><span class="delimiter">[</span><span>OF</span><span> </span><span>this</span><span class="delimiter">]</span><span>
</span><span>  </span><span class="keyword3"><span class="command">show</span></span><span> </span><span class="var">?thesis</span><span> </span><span class="keyword1"><span class="command">.</span></span><span>
</span><span class="keyword1"><span class="command">qed</span></span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>annotateWhile</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnnoG gs b I V c) Q,A&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (while gs b c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reannotateWhile</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnnoG gs b I V c) Q,A&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnnoG gs b J V c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnnoG_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>reannotateWhileNoGuard</span><span class="delimiter">:</span><span>
</span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnno b I V c) Q,A&#10215; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (whileAnno b J V c) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>simp</span><span> </span><span>add</span><span class="delimiter">:</span><span> </span><span>whileAnno_def</span><span class="delimiter">)</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span> </span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;P&#39; &#8838; P &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P&#39; c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;Q &#8838; Q&#39; &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q,A &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c Q&#39;,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPost</span><span class="delimiter">)</span><span> </span><span>blast</span><span class="delimiter">+</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {s. P s} c Q,A &#10233; (&#8896;s. P&#39; s &#10230; P s) &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {s. P&#39; s} c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;s. P&#39; s &#10230; P s) &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {s. P s} c Q,A &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {s. P&#39; s} c Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPre</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c {s. Q s},A &#10233; (&#8896;s. Q s &#10230; Q&#39; s) &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c {s. Q&#39; s},A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPost</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>    </span><span class="string"><span class="delete"><span class="delete">&quot;(&#8896;s. Q s &#10230; Q&#39; s) &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c {s. Q s},A &#10233; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P c {s. Q&#39; s},A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>conseqPost</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span class="delimiter">[</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span> </span><span class="string"><span class="delete"><span class="delete">&quot;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P Skip P,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Skip</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span>
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CondInt</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">,</span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P &#8745; b) c1 Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> (P &#8745; - b) c2 Q,A&#10215;
   &#10233;
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> P (Cond b c1 c2) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Cond</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span> 
</span><span class="keyword1"><span class="command">lemma</span></span><span> </span><span>CondConj</span><span> </span><span class="delimiter">[</span><span>trans</span><span class="delimiter">,</span><span> </span><span>intro</span><span class="delimiter">?</span><span class="delimiter">]</span><span class="delimiter">:</span><span>
</span><span>  </span><span class="string"><span class="delete"><span class="delete">&quot;&#10214;&#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {s. P s &#8743; b s} c1 Q,A; &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {s. P s &#8743; &#172; b s} c2 Q,A&#10215;
   &#10233; 
   &#915;,&#920;&#8866;<span class="hidden">&#8681;</span><sub>t</sub><span class="hidden">&#8664;</span><sub>/F<span class="hidden">&#8665;</span></sub> {s. P s} (Cond {s. b s} c1 c2) Q,A&quot;</span></span></span><span>
</span><span>  </span><span class="keyword1"><span class="command">by</span></span><span> </span><span class="delimiter">(</span><span>rule</span><span> </span><span>Cond</span><span class="delimiter">)</span><span> </span><span>auto</span><span>
</span><span class="keyword2"><span class="keyword">end</span></span><span>
</span><span>
</span></pre>

</div>
</body>
</html>
